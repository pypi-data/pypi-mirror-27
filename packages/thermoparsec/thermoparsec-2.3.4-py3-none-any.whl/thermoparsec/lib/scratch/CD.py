import json
import numpy as np
from scipy import signal
from numpy import sqrt, pi, exp,loadtxt
from lmfit import Model


def ReadFile(file):
    with open(file) as data_file:    
        data = json.load(data_file)
        return (data)

def GetPScan(spectrum,msOrder):
    scan = PScan()
    scan.FileName = spectrum.FileName
    scan.BasePeakIntensity = spectrum.BasePeakIntensity
    scan.BasePeakMass = spectrum.BasePeakMass
    scan.LowMass = spectrum.LowMass
    scan.HighMass = spectrum.HighMass
    scan.Masses = spectrum.Masses
    scan.PacketType = spectrum.PacketType
    scan.RetentionTime = spectrum.RetentionTime
    scan.ScanNumber = spectrum.ScanNumber
    scan.ScanType = spectrum.ScanType
    scan.TIC = spectrum.TIC
    scan.Intensities = spectrum.Intensities
    scan.Baselines = spectrum.Baselines
    scan.Noises = spectrum.Noises
    scan.Resolutions = spectrum.Resolutions
    scan.Charges = spectrum.Charges
    if msOrder >= 2:
        scan.PrecursorMass = spectrum.PrecursorMass
    return scan

def ScanFromJson(spectrum):
    scan = PScan()
    for i in spectrum:
        if i[0] == 'FileName':
            scan.FileName = i[1]
        if i[0] == 'BasePeakIntensity':
            scan.BasePeakIntensity = i[1]
        if i[0] == 'BasePeakMass':
            scan.BasePeakMass = i[1]
        if i[0] == 'LowMass':
            scan.LowMass = i[1]
        if i[0] == 'HighMass':
            scan.HighMass = i[1]
        if i[0] == 'Masses':
            scan.Masses = i[1]
        if i[0] == 'PacketType':
            scan.PacketType = i[1]
        if i[0] == 'RetentionTime':
            scan.RetentionTime = i[1]
        if i[0] == 'ScanNumber':
            scan.ScanNumber = i[1]
        if i[0] == 'ScanType':
            scan.ScanType = i[1]
        if i[0] == 'TIC':
            scan.TIC = i[1]
        if i[0] == 'Intensities':
            scan.Intensities = i[1]
        if i[0] == 'Baselines':
            scan.Baselines = i[1]
        if i[0] == 'Noises':
            scan.Noises = i[1]
        if i[0] == 'Resolutions':
            scan.Resolutions = i[1]
        if i[0] == 'Charges':
            scan.Charges = i[1]
        if i[0] == 'PrecursorMass':
                scan.PrecursorMass = i[1]
    return scan


def GetScanList(file):
    data = ReadFile(file)
    scanList = []
    for s in data:
        spectrum = s.items()
        scan = ScanFromJson(spectrum)
        scanList.append(scan)
    return scanList

def GetFastTraces(scanList):
    return -1


def GetMassTracesFromScans(scanList):
    """
    Generate all mass traces for a single raw file
    """
    # This is the final dic holding all the mass traces
    massTraces = {}

    # this is the master key list for all mass traces. Use this to add masses to an
    # existing m/z window (bin) or else create a new key
    # Traces are generated by finding the m/z in the scan and then putting +/- 10 ppm window (this can be a parameter)
    master = {}
    # this function takes a tuple where t[0] = FileID and t[1] = a list of scans
    id = scanList[0]
    scans = scanList[1]

    # iterate through all scans and masses (warning) time complexity => n^2
    for scan in scans:
        for i in range(len(scan.Masses)):
            diff = round(GetMassGivenPPM(scan.Masses[i], 10) - scan.Masses[i], 4)
            upper = round((scan.Masses[i] + diff), 4)
            lower = round((scan.Masses[i] - diff), 4)
            key = str(lower) + "_" + str(upper)

            """find the closes mass in the dictionary. If it is null create a new trace centered
               around this m/z and create a key
               TODO Need to add some kind of retention time constraint to find the mass
               within the RT window
            """
            p = FindNearestMass(master, scan.Masses[i], 10)
            # if there are no neighbors this becomes a new bin and key for the trace
            if p == None:
                master.update({key: scan.Masses[i]})
                mT = MassTrace()
                mz = MZ()
                mz.FileID = id
                mT.FileID = id
                mT.TraceID = key
                mz.Mass = scan.Masses[i]
                mz.Intensity = scan.Intensities[i]
                mz.RetentionTime = scan.RetentionTime
                mz.ScanNumber = scan.ScanNumber
                mT.Trace.append(mz)
                massTraces.update({key: mT})
            # we already have a key so just add the m/z to the trace
            else:
                mz = MZ()
                mz.FileID = id
                mz.Mass = scan.Masses[i]
                mz.Intensity = scan.Intensities[i]
                mz.RT = scan.RetentionTime
                mz.ScanNumber = scan.ScanNumber
                massTraces[p].Trace.append(mz)
    return massTraces


def GetPPMError(t, m):
    """
    calculate theoretical (t) and measured (m) ppm 
    """
    return (((t - m) / t) * 1e6)


def GetMassGivenPPM(t, p):
    """
    calculate theoretical mass (t) given a ppm tolerance (p)
    """
    return (t - ((p * t) / 1e6))


def FindNearestMass(m, t, p):
    """
    find nearest mass in the mass list dictionary (m), target mass (t) and ppm tolerance (p) 
    """
    for k, mass in m.items():
        if abs(GetPPMError(mass, t)) < p:
            return k
    return None


def DetectPeaksMF(t, w):
    """
    Detect peaks from mass trace (t) where w is the expected peak width at base (choose odd value)    """
    s = []
    rt = []
    mz = []
    for i in t.Trace:
        s.append(i.Intensity)
        rt.append(i.RT)
        mz.append(i.Mass)
    m = signal.medfilt(s, w)
    r = s - m
    p = Peak()
    p.Intensity = max(r)
    p.RT = round(rt[s.index(max(s))], 1)
    p.MZ = mz[s.index(max(s))]
    p.FileID = t.FileID
    return p


def DetectIsotopes(t):
    """
    input =  tuple (key,Peaklist) peaks are already grouped via RT (the key)
    """
    peaks = sorted(t, key=lambda p: p.MZ, reverse=False)
    return peaks


def GetMedian(a):
    return np.median(a)


def GetMax(a):
    return max(a)


def RemoveZeros(x):
    """
    remove zeros from a list
    """
    return list(filter(lambda a: a != 0, x))


class Peak:
    def __init__(self):
        self.RT = 0
        self.PeakArea = 0
        self.Trace = MassTrace()


class PScan:
    def __init__(self):
        self.FileName = ""
        self.PrecursorMass = 0
        self.BasePeakIntensity = 0
        self.BasePeakMass = 0
        self.HighMass = 0
        self.LowMass = 0
        self.PacketType = 21
        self.RetentionTime = 0
        self.ScanNumber = 0
        self.ScanType = ""
        self.TIC = 0
        self.Baselines = []
        self.Intensities = []
        self.Masses = []
        self.Noises = []
        self.Resolutions = []
        self.Charges = []


    def get_mass_traces(self,list_of_masses):
        """
        Step 1: Get the given PPM , round it off to 4 decimals
        Step 2: find the upper and lower limits of window such that item-0.005 <= item <= item+0.005
        Step 3: Find nearest mass in the window calculated in Step 2. If found add it to same windowkey
                else create a new window key
        :param list_of_masses:
        :return: dictionary of window_value and m/z values
        """
        master = {}
        massTraces = {}
        for item in list_of_masses:
            diff = round(GetMassGivenPPM(item, 10) - item, 4)
            upper = round((item + diff), 4)
            lower = round((item - diff), 4)
            key = str(lower) + "_" + str(upper)
            p = FindNearestMass(master, item, 10)
            if p == None:
                master.update({key: item})
                mass_val = [];
                mass_val.append(item)
                massTraces.update({key: mass_val})
            else:
                massTraces[p].append(item)
        return massTraces

    def get_mass_traces2(self,list_of_masses,scan):
        """
        Step 1: Get the given PPM , round it off to 4 decimals
        Step 2: find the upper and lower limits of window such that item-0.005 <= item <= item+0.005
        Step 3: Find nearest mass in the window calculated in Step 2. If found add it to same windowkey
                else create a new window key
        :param list_of_masses:
        :return: dictionary of window_value and m/z values
        """
        master = {}
        massTraces = {}
        for mass in list_of_masses:
            diff = round(GetMassGivenPPM(mass, 10) - mass, 4)
            upper = round((mass + diff), 4)
            lower = round((mass - diff), 4)
            key = str(lower) + "_" + str(upper)
            p = FindNearestMass(master, mass, 10)
            if p == None:
                master.update({key: mass})
                mass_val = [];
                #mass_val.append(item)
                #massTraces.update({key: mass_val})
                mT = MassTrace()
                mz = MZ()
                mz.FileID = id
                mT.FileID = id
                mT.TraceID = key
                mz.Mass = mass
                mz.Intensity = scan.Intensities[list_of_masses.index(mass)]
                mz.RetentionTime = scan.RetentionTime
                mz.ScanNumber = scan.ScanNumber
                mT.Trace.append(mz)
                mass_val.append(mT)
                massTraces.update({key: mT})

            else:
                #massTraces[p].append(item)
                mz = MZ()
                mz.FileID = id
                mz.Mass = list_of_masses
                mz.Intensity = scan.Intensities[list_of_masses.index(mass)]
                mz.RT = scan.RetentionTime
                mz.ScanNumber = scan.ScanNumber
                massTraces[p].Trace.append(mz)
        return massTraces


class MassTrace:
    def __init__(self):
        self.FileID = ""
        self.TraceID = ""
        self.Trace = []


class MZ:
    def __init__(self):
        self.FileID = ""
        self.Mass = 0
        self.Intensity = 0
        self.RT = 0
        self.ScanNumber = 0


class Peak:
    def __init__(self):
        self.FileID = ""
        self.RT = 0
        self.Intensity = 0
        self.MZ = 0


class Feature:
    def __init__(self):
        self.FileID
        self.Key
        self.RT = 0
        self.Intensity = 0
        self.A0 = 0
        self.Peaks = []


def CreateKVpair(s,o):
    """
    Tuple (file name , scan) where 0 is int for msOrder (e.g ms1 or ms2 or msN)
    """
    scan = GetPScan(s,o)
    return (s.FileName, scan)

def FlattenTraces(d):
    """
    return list of tuples (key,peak)
    """
    l = []
    for k,v in d.items():
        l.append((k,v))
    return l


def KeyPeaks(t):
    rt = round(t[1].RT,1)
    low = round(rt - 0.1,1)
    high = round(rt + 0.1,1)
    key = str(low) + '_' + str(high)
    return (key,t[1])


def DetectPeaks(t):
    p = DetectPeaksMF(t[1],11)
    return (t[0],p)

def KeyPeakByFile(p):
    k = p[0] + '_' + p[1].FileID
    v = p[1]
    return (k,v)

def DetectFeature(t):
    f = DetectIsotopes(t[1])
    return (t[0],f)

def GetTraceForScan(s):
    scan = s[1]
    d = scan.get_mass_traces(scan.Masses)
    return d

def MapMzListForScan(scan):
    return GetMzList(scan[1])

def KeyMz(m):
    return (m.FileID,m)

def GetTraceKeysForScans(scans):
    l = []
    scanList = scans[1]
    for scan in scanList:
        mass_list = scan.Masses
        mass_trace_dict = scan.get_mass_traces(mass_list)
        t = (mass_trace_dict,scan)
        l.append(t)
    return l

def GetMzList(scan):
    """
    Create mz objects from a scan
    """
    l = []
    for i in range(len(scan.Masses)):
        m = MZ()
        m.FileID = scan.FileName
        m.ScanNumber = scan.ScanNumber
        m.RT = scan.RetentionTime
        m.Intensity = scan.Intensities[i]
        m.Mass = scan.Masses[i]
        l.append(m)
    return l

def IntervalGroups(l, start_value, interval):
    """start_value and interval must be integer"""
    ret_list = []
    last_item_as_int = int(l[-1])+1
    for i in range(start_value, last_item_as_int, interval):
        interval_list = [item for item in l if item >= i and item < (i + interval)]
        ret_list.append(interval_list)

    return ret_list

def GetMassTraces(m):
    """
    returns a list of Trace objects from an input list of mz objects from all scans
    """
    r =  []
    f = []
    masses = sorted(m, key=lambda p: p.Mass, reverse=False)
    testmass = masses[0].Mass
    t = MassTrace()
    t.FileID = masses[0].FileID
    for i in range(len(masses)):
        err = GetPPMError(masses[i].Mass,testmass)
        if(abs(err) < 10):
            t.Trace.append(masses[i])
            testmass = masses[i].Mass
            if(len(t.Trace) > 10):
                test = 0
        else:
            #add trace and start new one
            t.FileID = masses[i].FileID
            r.append(t)
            t = MassTrace()
            t.Trace.append(masses[i])
            testmass = masses[i].Mass

    # sort all traces by RT (5 data points minimum)
    for trace in r:
        if(len(trace.Trace) > 5):
            f.append(sorted(trace.Trace, key=lambda p: p.RT, reverse=False))
    return f

def gaussian(x, amp, cen, wid):
    "1-d gaussian: gaussian(x, amp, cen, wid)"
    return (amp/(sqrt(2*pi)*wid)) * exp(-(x-cen)**2 /(2*wid**2))

def PPD(trace,w):
    x = []
    y = []
    for i in range(len(trace)):
        x.append(trace[i].RT)
        y.append(trace[i].Intensity)
    x = np.asarray(x)
    y = np.asarray(y)
    amp = np.median(y)
    cent = np.median(x)
    gmodel = Model(gaussian)

    return gmodel.fit(y, x=x, amp=amp, cen=cent, wid=w)


def KeyTraces(t):
    """
    Input is a list of trace objects and output is a list of key values (id:trace)
    """
    l = []
    traces = GetMassTraces(t[1])
    for i in range(len(traces)):
        l.append((i,traces[i]))
    return l





