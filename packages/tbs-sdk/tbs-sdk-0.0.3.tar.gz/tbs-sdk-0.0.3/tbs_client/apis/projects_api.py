# coding: utf-8

"""
    3blades API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class ProjectsApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def project_copy(self, namespace, project_copy_data, **kwargs):
        """
        Copy a project to your own account.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.project_copy(namespace, project_copy_data, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param ProjectCopyData project_copy_data: (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.project_copy_with_http_info(namespace, project_copy_data, **kwargs)
        else:
            (data) = self.project_copy_with_http_info(namespace, project_copy_data, **kwargs)
            return data

    def project_copy_with_http_info(self, namespace, project_copy_data, **kwargs):
        """
        Copy a project to your own account.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.project_copy_with_http_info(namespace, project_copy_data, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param ProjectCopyData project_copy_data: (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace', 'project_copy_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_copy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `project_copy`")
        # verify the required parameter 'project_copy_data' is set
        if ('project_copy_data' not in params) or (params['project_copy_data'] is None):
            raise ValueError("Missing the required parameter `project_copy_data` when calling `project_copy`")


        collection_formats = {}

        path_params = {}
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_copy_data' in params:
            body_params = params['project_copy_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/project-copy/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Project',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def project_copy_check(self, namespace, project_copy_data, **kwargs):
        """
        Check if you are able to copy a project to your account.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.project_copy_check(namespace, project_copy_data, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param ProjectCopyData1 project_copy_data: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.project_copy_check_with_http_info(namespace, project_copy_data, **kwargs)
        else:
            (data) = self.project_copy_check_with_http_info(namespace, project_copy_data, **kwargs)
            return data

    def project_copy_check_with_http_info(self, namespace, project_copy_data, **kwargs):
        """
        Check if you are able to copy a project to your account.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.project_copy_check_with_http_info(namespace, project_copy_data, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param ProjectCopyData1 project_copy_data: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace', 'project_copy_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_copy_check" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `project_copy_check`")
        # verify the required parameter 'project_copy_data' is set
        if ('project_copy_data' not in params) or (params['project_copy_data'] is None):
            raise ValueError("Missing the required parameter `project_copy_data` when calling `project_copy_check`")


        collection_formats = {}

        path_params = {}
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_copy_data' in params:
            body_params = params['project_copy_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/project-copy-check/', 'HEAD',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_collaborators_create(self, project, namespace, **kwargs):
        """
        Create project collaborators
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_create(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param CollaboratorData collaborator_data:
        :return: Collaborator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_collaborators_create_with_http_info(project, namespace, **kwargs)
        else:
            (data) = self.projects_collaborators_create_with_http_info(project, namespace, **kwargs)
            return data

    def projects_collaborators_create_with_http_info(self, project, namespace, **kwargs):
        """
        Create project collaborators
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_create_with_http_info(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param CollaboratorData collaborator_data:
        :return: Collaborator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'collaborator_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_collaborators_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_collaborators_create`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_collaborators_create`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'collaborator_data' in params:
            body_params = params['collaborator_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/collaborators/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Collaborator',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_collaborators_delete(self, project, namespace, collaborator, **kwargs):
        """
        Delete a project collaborator
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_delete(project, namespace, collaborator, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier. (required)
        :param str namespace: User or team name. (required)
        :param str collaborator: Collaborator unique identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_collaborators_delete_with_http_info(project, namespace, collaborator, **kwargs)
        else:
            (data) = self.projects_collaborators_delete_with_http_info(project, namespace, collaborator, **kwargs)
            return data

    def projects_collaborators_delete_with_http_info(self, project, namespace, collaborator, **kwargs):
        """
        Delete a project collaborator
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_delete_with_http_info(project, namespace, collaborator, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier. (required)
        :param str namespace: User or team name. (required)
        :param str collaborator: Collaborator unique identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'collaborator']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_collaborators_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_collaborators_delete`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_collaborators_delete`")
        # verify the required parameter 'collaborator' is set
        if ('collaborator' not in params) or (params['collaborator'] is None):
            raise ValueError("Missing the required parameter `collaborator` when calling `projects_collaborators_delete`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'collaborator' in params:
            path_params['collaborator'] = params['collaborator']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/collaborators/{collaborator}/', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_collaborators_list(self, project, namespace, **kwargs):
        """
        Get project collaborators
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_list(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str limit: Limit when retrieving items.
        :param str offset: Offset when retrieving items.
        :param str ordering: Ordering when retrieving items.
        :return: list[Collaborator]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_collaborators_list_with_http_info(project, namespace, **kwargs)
        else:
            (data) = self.projects_collaborators_list_with_http_info(project, namespace, **kwargs)
            return data

    def projects_collaborators_list_with_http_info(self, project, namespace, **kwargs):
        """
        Get project collaborators
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_list_with_http_info(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str limit: Limit when retrieving items.
        :param str offset: Offset when retrieving items.
        :param str ordering: Ordering when retrieving items.
        :return: list[Collaborator]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'limit', 'offset', 'ordering']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_collaborators_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_collaborators_list`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_collaborators_list`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'offset' in params:
            query_params.append(('offset', params['offset']))
        if 'ordering' in params:
            query_params.append(('ordering', params['ordering']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/collaborators/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Collaborator]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_collaborators_read(self, project, namespace, collaborator, **kwargs):
        """
        Get a project collaborator
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_read(project, namespace, collaborator, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier. (required)
        :param str namespace: User or team name. (required)
        :param str collaborator: Collaborator unique identifier expressed as UUID or name. (required)
        :return: Collaborator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_collaborators_read_with_http_info(project, namespace, collaborator, **kwargs)
        else:
            (data) = self.projects_collaborators_read_with_http_info(project, namespace, collaborator, **kwargs)
            return data

    def projects_collaborators_read_with_http_info(self, project, namespace, collaborator, **kwargs):
        """
        Get a project collaborator
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_read_with_http_info(project, namespace, collaborator, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier. (required)
        :param str namespace: User or team name. (required)
        :param str collaborator: Collaborator unique identifier expressed as UUID or name. (required)
        :return: Collaborator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'collaborator']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_collaborators_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_collaborators_read`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_collaborators_read`")
        # verify the required parameter 'collaborator' is set
        if ('collaborator' not in params) or (params['collaborator'] is None):
            raise ValueError("Missing the required parameter `collaborator` when calling `projects_collaborators_read`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'collaborator' in params:
            path_params['collaborator'] = params['collaborator']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/collaborators/{collaborator}/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Collaborator',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_collaborators_update(self, project, namespace, collaborator, **kwargs):
        """
        Update project collaborator
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_update(project, namespace, collaborator, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project:  (required)
        :param str namespace: User or team name. (required)
        :param str collaborator:  (required)
        :param CollaboratorData collaborator_data:
        :return: Collaborator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_collaborators_update_with_http_info(project, namespace, collaborator, **kwargs)
        else:
            (data) = self.projects_collaborators_update_with_http_info(project, namespace, collaborator, **kwargs)
            return data

    def projects_collaborators_update_with_http_info(self, project, namespace, collaborator, **kwargs):
        """
        Update project collaborator
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_collaborators_update_with_http_info(project, namespace, collaborator, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project:  (required)
        :param str namespace: User or team name. (required)
        :param str collaborator:  (required)
        :param CollaboratorData collaborator_data:
        :return: Collaborator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'collaborator', 'collaborator_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_collaborators_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_collaborators_update`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_collaborators_update`")
        # verify the required parameter 'collaborator' is set
        if ('collaborator' not in params) or (params['collaborator'] is None):
            raise ValueError("Missing the required parameter `collaborator` when calling `projects_collaborators_update`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'collaborator' in params:
            path_params['collaborator'] = params['collaborator']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'collaborator_data' in params:
            body_params = params['collaborator_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/collaborators/{collaborator}/', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Collaborator',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_create(self, namespace, **kwargs):
        """
        Create a new project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_create(namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param ProjectData project_data:
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_create_with_http_info(namespace, **kwargs)
        else:
            (data) = self.projects_create_with_http_info(namespace, **kwargs)
            return data

    def projects_create_with_http_info(self, namespace, **kwargs):
        """
        Create a new project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_create_with_http_info(namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param ProjectData project_data:
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace', 'project_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_create`")


        collection_formats = {}

        path_params = {}
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_data' in params:
            body_params = params['project_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Project',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_delete(self, namespace, project, **kwargs):
        """
        Delete a project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_delete(namespace, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_delete_with_http_info(namespace, project, **kwargs)
        else:
            (data) = self.projects_delete_with_http_info(namespace, project, **kwargs)
            return data

    def projects_delete_with_http_info(self, namespace, project, **kwargs):
        """
        Delete a project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_delete_with_http_info(namespace, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace', 'project']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_delete`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_delete`")


        collection_formats = {}

        path_params = {}
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'project' in params:
            path_params['project'] = params['project']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_list(self, namespace, **kwargs):
        """
        Get available projects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_list(namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param str limit: Limit when getting data.
        :param str offset: Offset when getting data.
        :param str private: Private project or public project.
        :param str name: Project name.
        :param str ordering: Ordering when getting projects.
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_list_with_http_info(namespace, **kwargs)
        else:
            (data) = self.projects_list_with_http_info(namespace, **kwargs)
            return data

    def projects_list_with_http_info(self, namespace, **kwargs):
        """
        Get available projects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_list_with_http_info(namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param str limit: Limit when getting data.
        :param str offset: Offset when getting data.
        :param str private: Private project or public project.
        :param str name: Project name.
        :param str ordering: Ordering when getting projects.
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace', 'limit', 'offset', 'private', 'name', 'ordering']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_list`")


        collection_formats = {}

        path_params = {}
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'offset' in params:
            query_params.append(('offset', params['offset']))
        if 'private' in params:
            query_params.append(('private', params['private']))
        if 'name' in params:
            query_params.append(('name', params['name']))
        if 'ordering' in params:
            query_params.append(('ordering', params['ordering']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Project]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_files_create(self, project, namespace, **kwargs):
        """
        Create project files
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_create(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier. (required)
        :param str namespace: User or team name. (required)
        :param file file: File to send, to create new file. This parameter is only used with form data and may include multiple files.
        :param str base64_data: Fila data, represented as base64.
        :param str name: File name. May include path when creating file with base64 field.
        :param str path: File path. Defaults to (/).
        :return: ProjectFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_files_create_with_http_info(project, namespace, **kwargs)
        else:
            (data) = self.projects_project_files_create_with_http_info(project, namespace, **kwargs)
            return data

    def projects_project_files_create_with_http_info(self, project, namespace, **kwargs):
        """
        Create project files
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_create_with_http_info(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier. (required)
        :param str namespace: User or team name. (required)
        :param file file: File to send, to create new file. This parameter is only used with form data and may include multiple files.
        :param str base64_data: Fila data, represented as base64.
        :param str name: File name. May include path when creating file with base64 field.
        :param str path: File path. Defaults to (/).
        :return: ProjectFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'file', 'base64_data', 'name', 'path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_files_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_project_files_create`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_project_files_create`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']
        if 'base64_data' in params:
            form_params.append(('base64_data', params['base64_data']))
        if 'name' in params:
            form_params.append(('name', params['name']))
        if 'path' in params:
            form_params.append(('path', params['path']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data', 'application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/project_files/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProjectFile',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_files_delete(self, project, namespace, id, **kwargs):
        """
        Delete a project file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_delete(project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer. (required)
        :param str namespace: User or team name. (required)
        :param str id: File unique identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_files_delete_with_http_info(project, namespace, id, **kwargs)
        else:
            (data) = self.projects_project_files_delete_with_http_info(project, namespace, id, **kwargs)
            return data

    def projects_project_files_delete_with_http_info(self, project, namespace, id, **kwargs):
        """
        Delete a project file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_delete_with_http_info(project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer. (required)
        :param str namespace: User or team name. (required)
        :param str id: File unique identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_files_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_project_files_delete`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_project_files_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_files_delete`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/project_files/{id}/', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_files_list(self, project, namespace, **kwargs):
        """
        Get project files
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_list(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Unique identifier for project file expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str limit: Limit when getting project file list.
        :param str offset: Offset when getting project file list.
        :param str ordering: Ordering of list values when getting project file list.
        :param str filename: Exact file name, relative to the project root. If no such file is found, an empty list will be returned.
        :param str content: Determines whether or not content is returned as base64. Defaults to false.
        :return: list[ProjectFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_files_list_with_http_info(project, namespace, **kwargs)
        else:
            (data) = self.projects_project_files_list_with_http_info(project, namespace, **kwargs)
            return data

    def projects_project_files_list_with_http_info(self, project, namespace, **kwargs):
        """
        Get project files
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_list_with_http_info(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Unique identifier for project file expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str limit: Limit when getting project file list.
        :param str offset: Offset when getting project file list.
        :param str ordering: Ordering of list values when getting project file list.
        :param str filename: Exact file name, relative to the project root. If no such file is found, an empty list will be returned.
        :param str content: Determines whether or not content is returned as base64. Defaults to false.
        :return: list[ProjectFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'limit', 'offset', 'ordering', 'filename', 'content']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_files_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_project_files_list`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_project_files_list`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'offset' in params:
            query_params.append(('offset', params['offset']))
        if 'ordering' in params:
            query_params.append(('ordering', params['ordering']))
        if 'filename' in params:
            query_params.append(('filename', params['filename']))
        if 'content' in params:
            query_params.append(('content', params['content']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/project_files/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[ProjectFile]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_files_read(self, project, namespace, id, **kwargs):
        """
        Get a project file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_read(project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer. (required)
        :param str namespace: User or team name. (required)
        :param str id: File unique identifier. (required)
        :param str content: Determines whether or not content is returned as base64. Defaults to false.
        :return: ProjectFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_files_read_with_http_info(project, namespace, id, **kwargs)
        else:
            (data) = self.projects_project_files_read_with_http_info(project, namespace, id, **kwargs)
            return data

    def projects_project_files_read_with_http_info(self, project, namespace, id, **kwargs):
        """
        Get a project file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_read_with_http_info(project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer. (required)
        :param str namespace: User or team name. (required)
        :param str id: File unique identifier. (required)
        :param str content: Determines whether or not content is returned as base64. Defaults to false.
        :return: ProjectFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'id', 'content']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_files_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_project_files_read`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_project_files_read`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_files_read`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'content' in params:
            query_params.append(('content', params['content']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/project_files/{id}/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProjectFile',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_files_replace(self, project, namespace, id, **kwargs):
        """
        Replace a project file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_replace(project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer. (required)
        :param str namespace: User or team name. (required)
        :param str id: File unique identifier. (required)
        :param file file: File to send, to create new file. This parameter is only used with form data and may include multiple files.
        :param str base64_data: Fila data, represented as base64.
        :param str name: File name. May include path when creating file with base64 field.
        :param str path: File path. Defaults to (/).
        :return: ProjectFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_files_replace_with_http_info(project, namespace, id, **kwargs)
        else:
            (data) = self.projects_project_files_replace_with_http_info(project, namespace, id, **kwargs)
            return data

    def projects_project_files_replace_with_http_info(self, project, namespace, id, **kwargs):
        """
        Replace a project file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_replace_with_http_info(project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer. (required)
        :param str namespace: User or team name. (required)
        :param str id: File unique identifier. (required)
        :param file file: File to send, to create new file. This parameter is only used with form data and may include multiple files.
        :param str base64_data: Fila data, represented as base64.
        :param str name: File name. May include path when creating file with base64 field.
        :param str path: File path. Defaults to (/).
        :return: ProjectFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'id', 'file', 'base64_data', 'name', 'path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_files_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_project_files_replace`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_project_files_replace`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_files_replace`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']
        if 'base64_data' in params:
            form_params.append(('base64_data', params['base64_data']))
        if 'name' in params:
            form_params.append(('name', params['name']))
        if 'path' in params:
            form_params.append(('path', params['path']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/project_files/{id}/', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProjectFile',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_files_update(self, project, namespace, id, **kwargs):
        """
        Update a project file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_update(project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer. (required)
        :param str namespace: User or team name. (required)
        :param str id: File unique identifier. (required)
        :param file file: File to send, to create new file. This parameter is only used with form data and may include multiple files.
        :param str base64_data: Fila data, represented as base64.
        :param str name: File name. May include path when creating file with base64 field.
        :param str path: File path. Defaults to (/).
        :return: ProjectFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_files_update_with_http_info(project, namespace, id, **kwargs)
        else:
            (data) = self.projects_project_files_update_with_http_info(project, namespace, id, **kwargs)
            return data

    def projects_project_files_update_with_http_info(self, project, namespace, id, **kwargs):
        """
        Update a project file
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_files_update_with_http_info(project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer. (required)
        :param str namespace: User or team name. (required)
        :param str id: File unique identifier. (required)
        :param file file: File to send, to create new file. This parameter is only used with form data and may include multiple files.
        :param str base64_data: Fila data, represented as base64.
        :param str name: File name. May include path when creating file with base64 field.
        :param str path: File path. Defaults to (/).
        :return: ProjectFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'id', 'file', 'base64_data', 'name', 'path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_files_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_project_files_update`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_project_files_update`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_files_update`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']
        if 'base64_data' in params:
            form_params.append(('base64_data', params['base64_data']))
        if 'name' in params:
            form_params.append(('name', params['name']))
        if 'path' in params:
            form_params.append(('path', params['path']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/project_files/{id}/', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ProjectFile',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_read(self, namespace, project, **kwargs):
        """
        Get a project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_read(namespace, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_read_with_http_info(namespace, project, **kwargs)
        else:
            (data) = self.projects_read_with_http_info(namespace, project, **kwargs)
            return data

    def projects_read_with_http_info(self, namespace, project, **kwargs):
        """
        Get a project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_read_with_http_info(namespace, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace', 'project']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_read`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_read`")


        collection_formats = {}

        path_params = {}
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'project' in params:
            path_params['project'] = params['project']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Project',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_replace(self, namespace, project, **kwargs):
        """
        Replace a project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_replace(namespace, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team namespace. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param ProjectData project_data:
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_replace_with_http_info(namespace, project, **kwargs)
        else:
            (data) = self.projects_replace_with_http_info(namespace, project, **kwargs)
            return data

    def projects_replace_with_http_info(self, namespace, project, **kwargs):
        """
        Replace a project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_replace_with_http_info(namespace, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team namespace. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param ProjectData project_data:
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace', 'project', 'project_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_replace`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_replace`")


        collection_formats = {}

        path_params = {}
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'project' in params:
            path_params['project'] = params['project']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_data' in params:
            body_params = params['project_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Project',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_api_key(self, project, namespace, server, **kwargs):
        """
        Get server API key
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_api_key(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: JWT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_api_key_with_http_info(project, namespace, server, **kwargs)
        else:
            (data) = self.projects_servers_api_key_with_http_info(project, namespace, server, **kwargs)
            return data

    def projects_servers_api_key_with_http_info(self, project, namespace, server, **kwargs):
        """
        Get server API key
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_api_key_with_http_info(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: JWT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'server']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_api_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_api_key`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_api_key`")
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_api_key`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'server' in params:
            path_params['server'] = params['server']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/api-key/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='JWT',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_auth(self, project, namespace, server, **kwargs):
        """
        Server api key validation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_auth(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_auth_with_http_info(project, namespace, server, **kwargs)
        else:
            (data) = self.projects_servers_auth_with_http_info(project, namespace, server, **kwargs)
            return data

    def projects_servers_auth_with_http_info(self, project, namespace, server, **kwargs):
        """
        Server api key validation
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_auth_with_http_info(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'server']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_auth" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_auth`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_auth`")
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_auth`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'server' in params:
            path_params['server'] = params['server']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/auth/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_create(self, project, namespace, **kwargs):
        """
        Create a new server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_create(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param ServerData server_data:
        :return: Server
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_create_with_http_info(project, namespace, **kwargs)
        else:
            (data) = self.projects_servers_create_with_http_info(project, namespace, **kwargs)
            return data

    def projects_servers_create_with_http_info(self, project, namespace, **kwargs):
        """
        Create a new server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_create_with_http_info(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifer expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param ServerData server_data:
        :return: Server
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'server_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_create`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_create`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'server_data' in params:
            body_params = params['server_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Server',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_delete(self, project, namespace, server, **kwargs):
        """
        Delete a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_delete(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier. (required)
        :param str namespace: User or team name. (required)
        :param str server: User unique identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_delete_with_http_info(project, namespace, server, **kwargs)
        else:
            (data) = self.projects_servers_delete_with_http_info(project, namespace, server, **kwargs)
            return data

    def projects_servers_delete_with_http_info(self, project, namespace, server, **kwargs):
        """
        Delete a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_delete_with_http_info(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier. (required)
        :param str namespace: User or team name. (required)
        :param str server: User unique identifier. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'server']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_delete`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_delete`")
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_delete`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'server' in params:
            path_params['server'] = params['server']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_list(self, project, namespace, **kwargs):
        """
        Retrieve servers
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_list(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str limit: Limit results when getting server list.
        :param str offset: Offset results when getting server list.
        :param str name: Server name.
        :param str ordering: Ordering option when getting server list.
        :return: list[Server]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_list_with_http_info(project, namespace, **kwargs)
        else:
            (data) = self.projects_servers_list_with_http_info(project, namespace, **kwargs)
            return data

    def projects_servers_list_with_http_info(self, project, namespace, **kwargs):
        """
        Retrieve servers
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_list_with_http_info(project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str limit: Limit results when getting server list.
        :param str offset: Offset results when getting server list.
        :param str name: Server name.
        :param str ordering: Ordering option when getting server list.
        :return: list[Server]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'limit', 'offset', 'name', 'ordering']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_list`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_list`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'offset' in params:
            query_params.append(('offset', params['offset']))
        if 'name' in params:
            query_params.append(('name', params['name']))
        if 'ordering' in params:
            query_params.append(('ordering', params['ordering']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Server]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_read(self, project, namespace, server, **kwargs):
        """
        Retrieve a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_read(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: Server
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_read_with_http_info(project, namespace, server, **kwargs)
        else:
            (data) = self.projects_servers_read_with_http_info(project, namespace, server, **kwargs)
            return data

    def projects_servers_read_with_http_info(self, project, namespace, server, **kwargs):
        """
        Retrieve a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_read_with_http_info(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: Server
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'server']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_read`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_read`")
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_read`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'server' in params:
            path_params['server'] = params['server']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Server',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_replace(self, project, namespace, server, **kwargs):
        """
        Replace a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_replace(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param ServerData server_data:
        :return: Server
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_replace_with_http_info(project, namespace, server, **kwargs)
        else:
            (data) = self.projects_servers_replace_with_http_info(project, namespace, server, **kwargs)
            return data

    def projects_servers_replace_with_http_info(self, project, namespace, server, **kwargs):
        """
        Replace a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_replace_with_http_info(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param ServerData server_data:
        :return: Server
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'server', 'server_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_replace`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_replace`")
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_replace`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'server' in params:
            path_params['server'] = params['server']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'server_data' in params:
            body_params = params['server_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Server',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_run_stats_create(self, server, project, namespace, **kwargs):
        """
        Create a new server's run statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_create(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param ServerRunStatisticsData serverrunstats_data:
        :return: ServerRunStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_run_stats_create_with_http_info(server, project, namespace, **kwargs)
        else:
            (data) = self.projects_servers_run_stats_create_with_http_info(server, project, namespace, **kwargs)
            return data

    def projects_servers_run_stats_create_with_http_info(self, server, project, namespace, **kwargs):
        """
        Create a new server's run statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_create_with_http_info(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param ServerRunStatisticsData serverrunstats_data:
        :return: ServerRunStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'serverrunstats_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_run_stats_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_run_stats_create`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_run_stats_create`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_run_stats_create`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'serverrunstats_data' in params:
            body_params = params['serverrunstats_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/run-stats/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerRunStatistics',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_run_stats_delete(self, server, project, namespace, id, **kwargs):
        """
        Delete a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_delete(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server run statistics unique identifier expressed as UUID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_run_stats_delete_with_http_info(server, project, namespace, id, **kwargs)
        else:
            (data) = self.projects_servers_run_stats_delete_with_http_info(server, project, namespace, id, **kwargs)
            return data

    def projects_servers_run_stats_delete_with_http_info(self, server, project, namespace, id, **kwargs):
        """
        Delete a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_delete_with_http_info(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server run statistics unique identifier expressed as UUID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_run_stats_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_run_stats_delete`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_run_stats_delete`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_run_stats_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_servers_run_stats_delete`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/run-stats/{id}/', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_run_stats_read(self, server, project, namespace, id, **kwargs):
        """
        Retrieve statistics for a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_read(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Run statistics unique identifier expressed as UUID. (required)
        :return: ServerRunStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_run_stats_read_with_http_info(server, project, namespace, id, **kwargs)
        else:
            (data) = self.projects_servers_run_stats_read_with_http_info(server, project, namespace, id, **kwargs)
            return data

    def projects_servers_run_stats_read_with_http_info(self, server, project, namespace, id, **kwargs):
        """
        Retrieve statistics for a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_read_with_http_info(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Run statistics unique identifier expressed as UUID. (required)
        :return: ServerRunStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_run_stats_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_run_stats_read`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_run_stats_read`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_run_stats_read`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_servers_run_stats_read`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/run-stats/{id}/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerRunStatistics',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_run_stats_replace(self, server, project, namespace, id, **kwargs):
        """
        Replace a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_replace(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server run statistics expressed as UUID. (required)
        :param ServerRunStatisticsData serverrunstats_data:
        :return: ServerRunStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_run_stats_replace_with_http_info(server, project, namespace, id, **kwargs)
        else:
            (data) = self.projects_servers_run_stats_replace_with_http_info(server, project, namespace, id, **kwargs)
            return data

    def projects_servers_run_stats_replace_with_http_info(self, server, project, namespace, id, **kwargs):
        """
        Replace a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_replace_with_http_info(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server run statistics expressed as UUID. (required)
        :param ServerRunStatisticsData serverrunstats_data:
        :return: ServerRunStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'id', 'serverrunstats_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_run_stats_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_run_stats_replace`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_run_stats_replace`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_run_stats_replace`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_servers_run_stats_replace`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'serverrunstats_data' in params:
            body_params = params['serverrunstats_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/run-stats/{id}/', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerRunStatistics',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_run_stats_update(self, server, project, namespace, id, **kwargs):
        """
        Update a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_update(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server run statistics unique identifier expressed as UUID. (required)
        :param ServerRunStatisticsData serverrunstats_data:
        :return: ServerRunStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_run_stats_update_with_http_info(server, project, namespace, id, **kwargs)
        else:
            (data) = self.projects_servers_run_stats_update_with_http_info(server, project, namespace, id, **kwargs)
            return data

    def projects_servers_run_stats_update_with_http_info(self, server, project, namespace, id, **kwargs):
        """
        Update a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_run_stats_update_with_http_info(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server run statistics unique identifier expressed as UUID. (required)
        :param ServerRunStatisticsData serverrunstats_data:
        :return: ServerRunStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'id', 'serverrunstats_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_run_stats_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_run_stats_update`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_run_stats_update`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_run_stats_update`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_servers_run_stats_update`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'serverrunstats_data' in params:
            body_params = params['serverrunstats_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/run-stats/{id}/', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerRunStatistics',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_ssh_tunnels_create(self, server, project, namespace, **kwargs):
        """
        Create SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_create(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param SshTunnelData sshtunnel_data:
        :return: SshTunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_ssh_tunnels_create_with_http_info(server, project, namespace, **kwargs)
        else:
            (data) = self.projects_servers_ssh_tunnels_create_with_http_info(server, project, namespace, **kwargs)
            return data

    def projects_servers_ssh_tunnels_create_with_http_info(self, server, project, namespace, **kwargs):
        """
        Create SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_create_with_http_info(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param SshTunnelData sshtunnel_data:
        :return: SshTunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'sshtunnel_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_ssh_tunnels_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_ssh_tunnels_create`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_ssh_tunnels_create`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_ssh_tunnels_create`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sshtunnel_data' in params:
            body_params = params['sshtunnel_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/ssh-tunnels/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SshTunnel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_ssh_tunnels_delete(self, server, project, namespace, tunnel, **kwargs):
        """
        Delete an SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_delete(server, project, namespace, tunnel, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str tunnel: SSH tunnel unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_ssh_tunnels_delete_with_http_info(server, project, namespace, tunnel, **kwargs)
        else:
            (data) = self.projects_servers_ssh_tunnels_delete_with_http_info(server, project, namespace, tunnel, **kwargs)
            return data

    def projects_servers_ssh_tunnels_delete_with_http_info(self, server, project, namespace, tunnel, **kwargs):
        """
        Delete an SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_delete_with_http_info(server, project, namespace, tunnel, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str tunnel: SSH tunnel unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'tunnel']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_ssh_tunnels_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_ssh_tunnels_delete`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_ssh_tunnels_delete`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_ssh_tunnels_delete`")
        # verify the required parameter 'tunnel' is set
        if ('tunnel' not in params) or (params['tunnel'] is None):
            raise ValueError("Missing the required parameter `tunnel` when calling `projects_servers_ssh_tunnels_delete`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'tunnel' in params:
            path_params['tunnel'] = params['tunnel']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/ssh-tunnels/{tunnel}/', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_ssh_tunnels_list(self, server, project, namespace, **kwargs):
        """
        Get SSH Tunnels associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_list(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str limit: Limit retrieved items.
        :param str offset: Offset retrieved items.
        :param str ordering: Order retrieved items.
        :return: list[SshTunnel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_ssh_tunnels_list_with_http_info(server, project, namespace, **kwargs)
        else:
            (data) = self.projects_servers_ssh_tunnels_list_with_http_info(server, project, namespace, **kwargs)
            return data

    def projects_servers_ssh_tunnels_list_with_http_info(self, server, project, namespace, **kwargs):
        """
        Get SSH Tunnels associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_list_with_http_info(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str limit: Limit retrieved items.
        :param str offset: Offset retrieved items.
        :param str ordering: Order retrieved items.
        :return: list[SshTunnel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'limit', 'offset', 'ordering']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_ssh_tunnels_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_ssh_tunnels_list`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_ssh_tunnels_list`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_ssh_tunnels_list`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'offset' in params:
            query_params.append(('offset', params['offset']))
        if 'ordering' in params:
            query_params.append(('ordering', params['ordering']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/ssh-tunnels/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[SshTunnel]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_ssh_tunnels_read(self, server, project, namespace, tunnel, **kwargs):
        """
        Get an SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_read(server, project, namespace, tunnel, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str tunnel: SSH tunnel unique identifier expressed as UUID or name. (required)
        :return: SshTunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_ssh_tunnels_read_with_http_info(server, project, namespace, tunnel, **kwargs)
        else:
            (data) = self.projects_servers_ssh_tunnels_read_with_http_info(server, project, namespace, tunnel, **kwargs)
            return data

    def projects_servers_ssh_tunnels_read_with_http_info(self, server, project, namespace, tunnel, **kwargs):
        """
        Get an SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_read_with_http_info(server, project, namespace, tunnel, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str tunnel: SSH tunnel unique identifier expressed as UUID or name. (required)
        :return: SshTunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'tunnel']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_ssh_tunnels_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_ssh_tunnels_read`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_ssh_tunnels_read`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_ssh_tunnels_read`")
        # verify the required parameter 'tunnel' is set
        if ('tunnel' not in params) or (params['tunnel'] is None):
            raise ValueError("Missing the required parameter `tunnel` when calling `projects_servers_ssh_tunnels_read`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'tunnel' in params:
            path_params['tunnel'] = params['tunnel']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/ssh-tunnels/{tunnel}/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SshTunnel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_ssh_tunnels_replace(self, server, project, namespace, tunnel, **kwargs):
        """
        Replace SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_replace(server, project, namespace, tunnel, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str tunnel: SSH tunnel unique identifier expressed as UUID or name. (required)
        :param SshTunnelData sshtunnel_data:
        :return: SshTunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_ssh_tunnels_replace_with_http_info(server, project, namespace, tunnel, **kwargs)
        else:
            (data) = self.projects_servers_ssh_tunnels_replace_with_http_info(server, project, namespace, tunnel, **kwargs)
            return data

    def projects_servers_ssh_tunnels_replace_with_http_info(self, server, project, namespace, tunnel, **kwargs):
        """
        Replace SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_replace_with_http_info(server, project, namespace, tunnel, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str tunnel: SSH tunnel unique identifier expressed as UUID or name. (required)
        :param SshTunnelData sshtunnel_data:
        :return: SshTunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'tunnel', 'sshtunnel_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_ssh_tunnels_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_ssh_tunnels_replace`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_ssh_tunnels_replace`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_ssh_tunnels_replace`")
        # verify the required parameter 'tunnel' is set
        if ('tunnel' not in params) or (params['tunnel'] is None):
            raise ValueError("Missing the required parameter `tunnel` when calling `projects_servers_ssh_tunnels_replace`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'tunnel' in params:
            path_params['tunnel'] = params['tunnel']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sshtunnel_data' in params:
            body_params = params['sshtunnel_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/ssh-tunnels/{tunnel}/', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SshTunnel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_ssh_tunnels_update(self, server, project, namespace, tunnel, **kwargs):
        """
        Update an SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_update(server, project, namespace, tunnel, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server:  (required)
        :param str project:  (required)
        :param str namespace: User or team name. (required)
        :param str tunnel:  (required)
        :param SshTunnelData sshtunnel_data:
        :return: SshTunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_ssh_tunnels_update_with_http_info(server, project, namespace, tunnel, **kwargs)
        else:
            (data) = self.projects_servers_ssh_tunnels_update_with_http_info(server, project, namespace, tunnel, **kwargs)
            return data

    def projects_servers_ssh_tunnels_update_with_http_info(self, server, project, namespace, tunnel, **kwargs):
        """
        Update an SSH Tunnel associated to a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_ssh_tunnels_update_with_http_info(server, project, namespace, tunnel, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server:  (required)
        :param str project:  (required)
        :param str namespace: User or team name. (required)
        :param str tunnel:  (required)
        :param SshTunnelData sshtunnel_data:
        :return: SshTunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'tunnel', 'sshtunnel_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_ssh_tunnels_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_ssh_tunnels_update`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_ssh_tunnels_update`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_ssh_tunnels_update`")
        # verify the required parameter 'tunnel' is set
        if ('tunnel' not in params) or (params['tunnel'] is None):
            raise ValueError("Missing the required parameter `tunnel` when calling `projects_servers_ssh_tunnels_update`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'tunnel' in params:
            path_params['tunnel'] = params['tunnel']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sshtunnel_data' in params:
            body_params = params['sshtunnel_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/ssh-tunnels/{tunnel}/', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SshTunnel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_start(self, project, namespace, server, **kwargs):
        """
        Start a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_start(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_start_with_http_info(project, namespace, server, **kwargs)
        else:
            (data) = self.projects_servers_start_with_http_info(project, namespace, server, **kwargs)
            return data

    def projects_servers_start_with_http_info(self, project, namespace, server, **kwargs):
        """
        Start a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_start_with_http_info(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'server']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_start" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_start`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_start`")
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_start`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'server' in params:
            path_params['server'] = params['server']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/start/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_stats_delete(self, server, project, namespace, id, **kwargs):
        """
        Delete a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stats_delete(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Stats unique identifier expressed as UUID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_stats_delete_with_http_info(server, project, namespace, id, **kwargs)
        else:
            (data) = self.projects_servers_stats_delete_with_http_info(server, project, namespace, id, **kwargs)
            return data

    def projects_servers_stats_delete_with_http_info(self, server, project, namespace, id, **kwargs):
        """
        Delete a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stats_delete_with_http_info(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Stats unique identifier expressed as UUID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_stats_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_stats_delete`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_stats_delete`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_stats_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_servers_stats_delete`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/stats/{id}/', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_stats_read(self, server, project, namespace, id, **kwargs):
        """
        Retrieve a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stats_read(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server statistics unique identifier expressed as UUID. (required)
        :return: ServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_stats_read_with_http_info(server, project, namespace, id, **kwargs)
        else:
            (data) = self.projects_servers_stats_read_with_http_info(server, project, namespace, id, **kwargs)
            return data

    def projects_servers_stats_read_with_http_info(self, server, project, namespace, id, **kwargs):
        """
        Retrieve a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stats_read_with_http_info(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server statistics unique identifier expressed as UUID. (required)
        :return: ServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_stats_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_stats_read`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_stats_read`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_stats_read`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_servers_stats_read`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/stats/{id}/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerStatistics',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_stats_replace(self, server, project, namespace, id, **kwargs):
        """
        Replace a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stats_replace(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server statistics unique identifier expressed as UUID. (required)
        :param ServerStatisticsData serverstats_data:
        :return: ServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_stats_replace_with_http_info(server, project, namespace, id, **kwargs)
        else:
            (data) = self.projects_servers_stats_replace_with_http_info(server, project, namespace, id, **kwargs)
            return data

    def projects_servers_stats_replace_with_http_info(self, server, project, namespace, id, **kwargs):
        """
        Replace a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stats_replace_with_http_info(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server statistics unique identifier expressed as UUID. (required)
        :param ServerStatisticsData serverstats_data:
        :return: ServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'id', 'serverstats_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_stats_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_stats_replace`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_stats_replace`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_stats_replace`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_servers_stats_replace`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'serverstats_data' in params:
            body_params = params['serverstats_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/stats/{id}/', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerStatistics',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_stats_update(self, server, project, namespace, id, **kwargs):
        """
        Update a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stats_update(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server statistics unique identifier expressed as UUID. (required)
        :param ServerStatisticsData serverstats_data:
        :return: ServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_stats_update_with_http_info(server, project, namespace, id, **kwargs)
        else:
            (data) = self.projects_servers_stats_update_with_http_info(server, project, namespace, id, **kwargs)
            return data

    def projects_servers_stats_update_with_http_info(self, server, project, namespace, id, **kwargs):
        """
        Update a server's statistics
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stats_update_with_http_info(server, project, namespace, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str id: Server statistics unique identifier expressed as UUID. (required)
        :param ServerStatisticsData serverstats_data:
        :return: ServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'id', 'serverstats_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_stats_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_stats_update`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_stats_update`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_stats_update`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_servers_stats_update`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'serverstats_data' in params:
            body_params = params['serverstats_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/stats/{id}/', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerStatistics',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_stop(self, project, namespace, server, **kwargs):
        """
        Stop a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stop(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_stop_with_http_info(project, namespace, server, **kwargs)
        else:
            (data) = self.projects_servers_stop_with_http_info(project, namespace, server, **kwargs)
            return data

    def projects_servers_stop_with_http_info(self, project, namespace, server, **kwargs):
        """
        Stop a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_stop_with_http_info(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'server']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_stop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_stop`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_stop`")
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_stop`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'server' in params:
            path_params['server'] = params['server']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/stop/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_servers_update(self, project, namespace, server, **kwargs):
        """
        Update a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_update(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param ServerData server_data:
        :return: Server
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_servers_update_with_http_info(project, namespace, server, **kwargs)
        else:
            (data) = self.projects_servers_update_with_http_info(project, namespace, server, **kwargs)
            return data

    def projects_servers_update_with_http_info(self, project, namespace, server, **kwargs):
        """
        Update a server
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_servers_update_with_http_info(project, namespace, server, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param ServerData server_data:
        :return: Server
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'namespace', 'server', 'server_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_servers_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_servers_update`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_servers_update`")
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `projects_servers_update`")


        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'server' in params:
            path_params['server'] = params['server']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'server_data' in params:
            body_params = params['server_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Server',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_update(self, namespace, project, **kwargs):
        """
        Update a project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_update(namespace, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param ProjectData project_data:
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_update_with_http_info(namespace, project, **kwargs)
        else:
            (data) = self.projects_update_with_http_info(namespace, project, **kwargs)
            return data

    def projects_update_with_http_info(self, namespace, project, **kwargs):
        """
        Update a project
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_update_with_http_info(namespace, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str namespace: User or team name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param ProjectData project_data:
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['namespace', 'project', 'project_data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `projects_update`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_update`")


        collection_formats = {}

        path_params = {}
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'project' in params:
            path_params['project'] = params['project']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_data' in params:
            body_params = params['project_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Project',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def service_trigger_create(self, server, project, namespace, **kwargs):
        """
        Create a new server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_create(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param ServerActionData server_action: Server action.
        :return: ServerAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.service_trigger_create_with_http_info(server, project, namespace, **kwargs)
        else:
            (data) = self.service_trigger_create_with_http_info(server, project, namespace, **kwargs)
            return data

    def service_trigger_create_with_http_info(self, server, project, namespace, **kwargs):
        """
        Create a new server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_create_with_http_info(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param ServerActionData server_action: Server action.
        :return: ServerAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'server_action']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_trigger_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `service_trigger_create`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `service_trigger_create`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `service_trigger_create`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'server_action' in params:
            body_params = params['server_action']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/triggers/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerAction',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def service_trigger_delete(self, server, project, namespace, trigger, **kwargs):
        """
        Delete a server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_delete(server, project, namespace, trigger, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str trigger: Trigger identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.service_trigger_delete_with_http_info(server, project, namespace, trigger, **kwargs)
        else:
            (data) = self.service_trigger_delete_with_http_info(server, project, namespace, trigger, **kwargs)
            return data

    def service_trigger_delete_with_http_info(self, server, project, namespace, trigger, **kwargs):
        """
        Delete a server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_delete_with_http_info(server, project, namespace, trigger, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str trigger: Trigger identifier expressed as UUID or name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'trigger']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_trigger_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `service_trigger_delete`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `service_trigger_delete`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `service_trigger_delete`")
        # verify the required parameter 'trigger' is set
        if ('trigger' not in params) or (params['trigger'] is None):
            raise ValueError("Missing the required parameter `trigger` when calling `service_trigger_delete`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'trigger' in params:
            path_params['trigger'] = params['trigger']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/triggers/{trigger}/', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def service_trigger_list(self, server, project, namespace, **kwargs):
        """
        Retrieve server triggers
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_list(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str name: Trigger name.
        :param str limit: Limit when getting triggers.
        :param str offset: Offset when getting triggers.
        :param str ordering: Ordering when getting triggers.
        :return: list[ServerAction]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.service_trigger_list_with_http_info(server, project, namespace, **kwargs)
        else:
            (data) = self.service_trigger_list_with_http_info(server, project, namespace, **kwargs)
            return data

    def service_trigger_list_with_http_info(self, server, project, namespace, **kwargs):
        """
        Retrieve server triggers
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_list_with_http_info(server, project, namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str name: Trigger name.
        :param str limit: Limit when getting triggers.
        :param str offset: Offset when getting triggers.
        :param str ordering: Ordering when getting triggers.
        :return: list[ServerAction]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'name', 'limit', 'offset', 'ordering']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_trigger_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `service_trigger_list`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `service_trigger_list`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `service_trigger_list`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'offset' in params:
            query_params.append(('offset', params['offset']))
        if 'ordering' in params:
            query_params.append(('ordering', params['ordering']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/triggers/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[ServerAction]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def service_trigger_read(self, server, project, namespace, trigger, **kwargs):
        """
        Get a server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_read(server, project, namespace, trigger, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str trigger: Trigger unique identifier. (required)
        :return: ServerAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.service_trigger_read_with_http_info(server, project, namespace, trigger, **kwargs)
        else:
            (data) = self.service_trigger_read_with_http_info(server, project, namespace, trigger, **kwargs)
            return data

    def service_trigger_read_with_http_info(self, server, project, namespace, trigger, **kwargs):
        """
        Get a server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_read_with_http_info(server, project, namespace, trigger, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str trigger: Trigger unique identifier. (required)
        :return: ServerAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'trigger']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_trigger_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `service_trigger_read`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `service_trigger_read`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `service_trigger_read`")
        # verify the required parameter 'trigger' is set
        if ('trigger' not in params) or (params['trigger'] is None):
            raise ValueError("Missing the required parameter `trigger` when calling `service_trigger_read`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'trigger' in params:
            path_params['trigger'] = params['trigger']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/triggers/{trigger}/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerAction',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def service_trigger_replace(self, server, project, namespace, trigger, **kwargs):
        """
        Replace a server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_replace(server, project, namespace, trigger, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str trigger: Trigger unique identifier. (required)
        :param ServerActionData server_action:
        :return: ServerAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.service_trigger_replace_with_http_info(server, project, namespace, trigger, **kwargs)
        else:
            (data) = self.service_trigger_replace_with_http_info(server, project, namespace, trigger, **kwargs)
            return data

    def service_trigger_replace_with_http_info(self, server, project, namespace, trigger, **kwargs):
        """
        Replace a server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_replace_with_http_info(server, project, namespace, trigger, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str trigger: Trigger unique identifier. (required)
        :param ServerActionData server_action:
        :return: ServerAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'trigger', 'server_action']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_trigger_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `service_trigger_replace`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `service_trigger_replace`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `service_trigger_replace`")
        # verify the required parameter 'trigger' is set
        if ('trigger' not in params) or (params['trigger'] is None):
            raise ValueError("Missing the required parameter `trigger` when calling `service_trigger_replace`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'trigger' in params:
            path_params['trigger'] = params['trigger']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'server_action' in params:
            body_params = params['server_action']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/triggers/{trigger}/', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerAction',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def service_trigger_update(self, server, project, namespace, trigger, **kwargs):
        """
        Update a server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_update(server, project, namespace, trigger, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str trigger: Trigger identifier expressed as UUID or name. (required)
        :param ServerActionData server_action:
        :return: ServerAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.service_trigger_update_with_http_info(server, project, namespace, trigger, **kwargs)
        else:
            (data) = self.service_trigger_update_with_http_info(server, project, namespace, trigger, **kwargs)
            return data

    def service_trigger_update_with_http_info(self, server, project, namespace, trigger, **kwargs):
        """
        Update a server trigger
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.service_trigger_update_with_http_info(server, project, namespace, trigger, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str server: Server unique identifier expressed as UUID or name. (required)
        :param str project: Project unique identifier expressed as UUID or name. (required)
        :param str namespace: User or team name. (required)
        :param str trigger: Trigger identifier expressed as UUID or name. (required)
        :param ServerActionData server_action:
        :return: ServerAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'project', 'namespace', 'trigger', 'server_action']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_trigger_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params) or (params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `service_trigger_update`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `service_trigger_update`")
        # verify the required parameter 'namespace' is set
        if ('namespace' not in params) or (params['namespace'] is None):
            raise ValueError("Missing the required parameter `namespace` when calling `service_trigger_update`")
        # verify the required parameter 'trigger' is set
        if ('trigger' not in params) or (params['trigger'] is None):
            raise ValueError("Missing the required parameter `trigger` when calling `service_trigger_update`")


        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']
        if 'project' in params:
            path_params['project'] = params['project']
        if 'namespace' in params:
            path_params['namespace'] = params['namespace']
        if 'trigger' in params:
            path_params['trigger'] = params['trigger']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'server_action' in params:
            body_params = params['server_action']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/html'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['jwt']

        return self.api_client.call_api('/v1/{namespace}/projects/{project}/servers/{server}/triggers/{trigger}/', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ServerAction',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
