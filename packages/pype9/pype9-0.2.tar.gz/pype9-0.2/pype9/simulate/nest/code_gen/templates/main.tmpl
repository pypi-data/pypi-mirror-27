{% import "macros.tmpl" as macros %}

{% macro elseif(first) %}{% if first %}if{% else %}} else if{% endif %}{% endmacro %}
{% macro endif(last) %}{% if last %}}{% endif %}{% endmacro %}

/* This file was generated by PyPe9 version {{version}} on {{timestamp}} */

#include <limits>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#include "{{component_name}}.h"
#include "exceptions.h"
#include "kernel_manager.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include "universal_data_logger_impl.h"


/******************************************************************
 * Template specialization that needs to be in the nest namesapce *
 ******************************************************************/

nest::RecordablesMap<nineml::{{component_name}}> nineml::{{component_name}}::recordablesMap_;

namespace nest{
  template <> void RecordablesMap<nineml::{{component_name}}>::create() {
{% for sv in component_class.state_variables %}
    insert_("{{sv.name}}", &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::{{sv.name}}_INDEX>);
{% endfor %}
    insert_(CURRENT_REGIME, &nineml::{{component_name}}::get_current_regime_index);
  }
}

/************************************************
 * Evaluation of dynamics for a single timestep *
 ************************************************/

namespace nineml {

extern "C" void {{component_name}}_dump_gsl_state(gsl_odeiv2_evolve * e, double y[]) {

    std::cout << "y0:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << e->y0[i] << " ";
    std::cout << std::endl;
    std::cout << "yerr:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << e->yerr[i] << " ";
    std::cout << std::endl;
    std::cout << "dydt_in:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << e->dydt_in[i] << " ";
    std::cout << std::endl;
    std::cout << "dydt_out:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << e->dydt_out[i] << " ";
    std::cout << std::endl;
    std::cout << "last_step:" << e->last_step << std::endl;
    std::cout << "count:" << e->count << std::endl;
    std::cout << "failed_steps:" << e->failed_steps << std::endl;
    std::cout << "y:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << y[i] << " ";
    std::cout << std::endl;

}

std::string {{component_name}}::ExceededMaximumSimultaneousTransitions::message() {
    std::ostringstream msg;
    msg << "Exceeded maxium number of simultaneous transitions (" << num_transitions << ")";
    msg << " in " << model << " at " << t << " ms. Probable infinite loop.";
    return msg.str();
}


{{component_name}}::Regime_::~Regime_() {
    for (std::vector<OnCondition_*>::iterator it = on_conditions.begin(); it != on_conditions.end(); ++it)
        delete *it;
    for (std::vector<OnEvent_*>::iterator it = on_events.begin(); it != on_events.end(); ++it)    
        delete *it;
}

{{component_name}}::Transition_* {{component_name}}::Regime_::transition(double end_of_step_t) {

    // Get vector of transitions (both OnConditions and OnEvents) that are triggered in the current timestep
    std::vector<Transition_*> occurred;
    for (std::vector<OnCondition_*>::iterator it = on_conditions.begin(); it != on_conditions.end(); ++it)
        if ((*it)->triggered(end_of_step_t))
            occurred.push_back(*it);
            
    for (std::vector<OnEvent_*>::iterator it = on_events.begin(); it != on_events.end(); ++it)
        if ((*it)->received())
            occurred.push_back(*it);

    // Get the earliest transition to be triggered
    Transition_* transition;
    if (!occurred.size())
        transition = NULL;
    else if (occurred.size() == 1)
        transition = occurred[0];
    else {
        std::vector<double> times;
        for (std::vector<Transition_*>::iterator it = occurred.begin(); it != occurred.end(); ++it) 
            times.push_back((*it)->time_occurred(end_of_step_t));
        int min_index = std::min_element(times.begin(), times.end()) - times.begin();
        transition = occurred[min_index];
    }
    // Deactivate the transition trigger (if on-condition) so that it doesn't
    // 'fire' before its trigger condition has transitioned back from true to false again.
    if (transition) 
        transition->deactivate();

    return transition;
}


void {{component_name}}::Regime_::set_triggers() {
    // Check whether trigger should be activated
    for (std::vector<OnCondition_*>::iterator it = on_conditions.begin(); it != on_conditions.end(); ++it)
        (*it)->set_trigger();
}


{% for regime in component_class.regimes %}

/**
 *  Dynamics and transitions for {{regime.name}} regime
 */

    {% if regime.num_time_derivatives %}
extern "C" int {{component_name}}_{{regime.name}}_dynamics{% include "dynamics_signature.tmpl" %} {

    // Get references to the members of the model
    assert(pnode_);
    const {{component_name}}& node_ = *(reinterpret_cast<{{component_name}}*>(pnode_));
    const {{component_name}}::Parameters_& P_ = node_.P_;
    const {{component_name}}::State_& S_ = node_.S_;
    const {{component_name}}::Buffers_& B_ = node_.B_;
    
    // State Variables from y_ vector
        {% for td in regime.time_derivatives %}
    double {{td.dependent_variable}} = ITEM(y_, {{component_name}}::{{regime.name}}Regime_::{{td.dependent_variable}}_INDEX);
        {% endfor %}

    {{macros.map_required_vars_locally(regime.time_derivatives, component_class, component_name, unit_handler, [], list(regime.time_derivative_variables)) | indent(4)}}

    // Evaluate differential equations
        {% for td, scaled_expr, units in unit_handler.scale_time_derivatives(regime.time_derivatives) %}
    ITEM(f_, {{component_name}}::{{regime.name}}Regime_::{{td.dependent_variable}}_INDEX) = {{scaled_expr.rhs_cstr}};  // ({{units}})
        {% endfor %}

        {% include "solver_return.tmpl" %}
}        
    {% endif %}
    
/* Jacobian for the {{regime.name}} regime if required by the solver */
    {% if regime.num_time_derivatives %}
{% include "solver_jacobian.tmpl" %}
    {% endif %}


{{component_name}}::{{regime.name}}Regime_::{{regime.name}}Regime_({{component_name}}* cell)
  : Regime_(cell, "{{regime.name}}", {{regime.name | upper}}_REGIME){% if regime.num_time_derivatives %}{% include "solver_construct.tmpl" %}{% endif %} {
  
    // Construct OnConditions specific to the regime.
    {% for on_condition in regime.on_conditions %}
    on_conditions.push_back(new {{regime.name}}OnCondition{{regime.index_of(on_condition)}}(this));
    {% endfor %}

    // Construct OnConditions specific to the regime.
    {% for on_event in regime.on_events %}
    on_events.push_back(new {{regime.name}}On{{on_event.src_port_name}}Event(this));              
    {% endfor %}

}

{{component_name}}::{{regime.name}}Regime_::~{{regime.name}}Regime_() {
    {% if regime.num_time_derivatives %}    
    {% include "solver_destruct.tmpl" %}
    {% endif %}
}

void {{component_name}}::{{regime.name}}Regime_::init_solver() {
    {% if regime.num_time_derivatives %}    
    {% include "solver_init.tmpl" %}
    {% endif %}
    
}

void {{component_name}}::{{regime.name}}Regime_::step_ode() {
    {% if regime.num_time_derivatives %}
    // Copy states from cell state vector to the (potentially) truncated
    // regime-specific state vector (i.e. containing only the states that
    // have a derivative in the regime)
        {% for td in regime.time_derivatives %}
    ITEM(ode_y_, {{td.dependent_variable}}_INDEX) = cell->S_.y_[{{component_name}}::State_::{{td.dependent_variable}}_INDEX];
        {% endfor %}

    // Step ODE solver
{% include "solver_update.tmpl" %}
    
    // Copy states back from the regime-specific state vector to the cell
    // state vector
        {% for td in regime.time_derivatives %}
    cell->S_.y_[{{component_name}}::State_::{{td.dependent_variable}}_INDEX] = ITEM(ode_y_, {{td.dependent_variable}}_INDEX);
        {% endfor %}
    {% endif %}
}

// Transition methods for {{regime.name}} regime

    {% for transition in regime.transitions %}
        {% if transition.nineml_type == 'OnCondition' %}
            {% set TransitionClassName = '{}OnCondition{}'.format(regime.name, regime.index_of(transition)) %}
        {% else %}
            {% set TransitionClassName = '{}On{}Event'.format(regime.name, transition.src_port_name) %}
        {% endif %}

bool {{component_name}}::{{TransitionClassName}}::body() {
    // Map all variables/expressions to the local namespace that are required to evaluate the state assignments that were not required for the triggers


    State_& S_ = regime->cell->S_;
    Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
    Variables_& V_ = regime->cell->V_;
    
        {% if transition.nineml_type == 'OnEvent' %}
    // Get the next weight and remove it from the unprocessed list
    double_t weight_ = B_.{{transition.src_port_name}}_events->front();
    B_.{{transition.src_port_name}}_events->pop_front();
            {% if transition.src_port_name in component_class.connection_parameter_set_keys %}
    // FIXME: Need to properly check beforehand that there is only one 
    //        connection parameter for this source port (which is a current
    //        limitaiton of NEST) before rendering the template. The following
    //        code will at least cause a compile error if there is
    double_t {{' '.join(component_class.connection_parameter_set(transition.src_port_name).parameter_names)}} = weight_;
            {% endif %}
        {% endif %}
    
    // Get time stored in state
    double t = S_.t;
    
    {{macros.map_required_vars_locally(transition.state_assignments, component_class, component_name, unit_handler, [], []) | indent(4)}}

    // State assignments
        {% for sa, scaled_expr, units in unit_handler.scale_aliases(transition.state_assignments) %}
    S_.y_[{{component_name}}::State_::{{sa.name}}_INDEX] = {{scaled_expr.rhs_cstr}};  // ({{units}})
        {% endfor %}
            
    // Output events
        {% for output_event in transition.output_events %}
    ++B_.num_{{output_event.port.name}}_events;

        {% endfor %}
        
        {% if transition.num_state_assignments %}
    return true;  // Transition contains discontinuous changes in state
        {% else %}
    return false;  // Transition doesn't contain discontinuous changes in state
        {% endif %}
}

    {% endfor %}
    {% for on_event in regime.on_events %}
            {% set TransitionClassName = '{}On{}Event'.format(regime.name, on_event.src_port_name) %}
    
double {{component_name}}::{{TransitionClassName}}::time_occurred(double end_of_step_t) {
    //FIXME: Should use the exact spike time specified in the spike event
    return end_of_step_t;
}


bool {{component_name}}::{{TransitionClassName}}::received() {
    return (bool)regime->cell->B_.{{on_event.src_port_name}}_events->size();
}

    {% endfor %}
    {% for on_condition in regime.on_conditions %}
        {% set TransitionClassName = '{}OnCondition{}'.format(regime.name, regime.index_of(on_condition)) %}
bool {{component_name}}::{{TransitionClassName}}::triggered(double end_of_step_t) {

    if (active) {
        const State_& S_ = regime->cell->S_;
        const Buffers_& B_ = regime->cell->B_;
        const Parameters_& P_ = regime->cell->P_;
        
        // Use time at end of the ODE step to check whether the on-condition is triggered within it.
        double t = end_of_step_t;
            
        {{macros.map_required_vars_locally(on_condition.trigger, component_class, component_name, unit_handler, [], []) | indent(8)}}
    
        return {{on_condition.trigger.rhs_cstr}};
    } else
        return false;

}

void {{component_name}}::{{TransitionClassName}}::set_trigger() {
    
    if (!active) {
        const State_& S_ = regime->cell->S_;
        const Buffers_& B_ = regime->cell->B_;
        const Parameters_& P_ = regime->cell->P_;

        // Get time stored in state
        double t = S_.t;
        
        {{macros.map_required_vars_locally(on_condition.trigger.reactivate_condition, component_class, component_name, unit_handler, [], []) | indent(8)}}
    
        active = {{on_condition.trigger.reactivate_condition.rhs_cstr}};
    }
}

double {{component_name}}::{{TransitionClassName}}::time_occurred(double end_of_step_t) {
       {% set exact_time_expr = on_condition.trigger.crossing_time_expr %}
       {% if exact_time_expr %}

    const State_& S_ = regime->cell->S_;
    const Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;

    {{macros.map_required_vars_locally(exact_time_expr, component_class, component_name, unit_handler, [], []) | indent(4)}}       
    // The trigger expression depends on 't' so determine the exact time that the threshold was crossed.
    double t = {{exact_time_expr.rhs_cstr}};
       {% else %}
    // The trigger expression doesn't soley (in terms of state-vars) depend on 't' so just return the end of the window
    double t = end_of_step_t;
       {% endif %}
    return t;       
}

    {% endfor %}
{% endfor %}


/**********************************************
 * Calculation of the residual for IDA solver *
 **********************************************/

{% include "residual.tmpl" %}

/***********************
 * Steady-sate solvers *
 ***********************/

{% include "fsolve.tmpl" %}

{# ********Old steady state implementation*******
{% if steadystate.localVars %}
  double {{steadystate.localVars | join(", ")}};
{% endif %}

  // params is a reference to the model parameters
  const struct {{component_name}}::Parameters_* params = (struct {{component_name}}::Parameters_ *)pnode;

{% for parameterDef in steadystate.parameterDefs %}
  {{parameterDef}}
{% endfor %}

{% for eq in steadystate.SSgetStateDefs %}
  {{eq}}
{% endfor %}

{% for eq in steadystate.SScurrentEqDefs %}
  {{eq}}
{% endfor %}

{% for eq in init.initOrder %}
  {{eq}}
{% endfor %}

{% for x in steadystate.SSsetStateDefsLbs %}
    {% if x.lbs %}
  double {{x.lbs | join(", ")}};
    {% endif %}

    {% for eq in x.defs %}
  {{eq}}
    {% endfor %}

{% endfor %}
***************************#}


/****************
 * Constructors *
 ****************/

{{component_name}}::{{component_name}}()
    : Archiving_Node(),
      P_(),
      S_(P_, (Regime_*)NULL),
      B_(*this) {

    construct_regimes(); 
    S_.current_regime = regimes[0];

    recordablesMap_.create();
        
}

{{component_name}}::{{component_name}}(const {{component_name}}& n)
    : Archiving_Node(n),
      P_(n.P_),
      S_(n.S_),
      B_(n.B_, *this) {
      
    construct_regimes();

    // Update current_regime in state to match regimes in this component.
    bool found_matching_regime = false;
    for (std::vector<Regime_*>::iterator regime_it = regimes.begin(); regime_it != regimes.end(); ++regime_it)
        if ((*regime_it)->get_name() == S_.current_regime->get_name()) {
            assert(!found_matching_regime);
            S_.current_regime = *regime_it; 
            found_matching_regime = true;
        }
    assert(found_matching_regime);
}

/**
 * Constructs all regimes (and their transitions) in the component class
 */      
void {{component_name}}::construct_regimes() {

    // Construct all regimes in order of their index
{% for regime in sorted_regimes %}
    regimes.push_back(new {{regime.name}}Regime_(this)) ;
{% endfor %}

    // Set target regimes in all transitions
    for (std::vector<Regime_*>::iterator regime_it = regimes.begin(); regime_it != regimes.end(); ++regime_it) {
        for (std::vector<OnEvent_*>::iterator on_event_it = (*regime_it)->on_events.begin(); on_event_it != (*regime_it)->on_events.end(); ++on_event_it)
            (*on_event_it)->set_target_regime(regimes);
        for (std::vector<OnCondition_*>::iterator on_condition_it = (*regime_it)->on_conditions.begin(); on_condition_it != (*regime_it)->on_conditions.end(); ++on_condition_it)
            (*on_condition_it)->set_target_regime(regimes);   
    }
}

void {{component_name}}::init_node_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    P_ = pr.P_;
    S_ = State_(P_, regimes[0]);
}

void {{component_name}}::init_state_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    S_ = State_(pr.P_, regimes[0]);
}

/**************
 * Destructor *
 **************/

{{component_name}}::~{{component_name}} () {
    // Destruct all regimes
    for (std::vector<Regime_*>::iterator it = regimes.begin(); it != regimes.end(); ++it)
        delete *it;
    regimes.clear();
}


/**********************************
 * Define parameters of the model *
 **********************************/

{{component_name}}::Parameters_::Parameters_()
{% for i, param in enumerate(component_class.parameters) %}
  {%if loop.first%}:{% endif %}
    {{param.name}} (0.0){% if not loop.last %},
{% endif %}
{% endfor %} {
// Check constraints on parameters
{#
{% for param in component_class.parameters %}
    {% for constraint in param.constraints %}
    {{constraint}}
    {% endfor %}
{% endfor %}
#}
}

/************************************
 * Construct state from parameters.
 ************************************/

{{component_name}}::State_::State_(const Parameters_& p, Regime_* current_regime) :
  current_regime(current_regime) {

    const Parameters_ *params = &p;

    // FIXME: need to add initial state here
{% for sv in component_class.state_variables %}
    y_[{{sv.name}}_INDEX] = 0.0;
{% endfor %}

    // Initialise time state just before t=0 to allow triggers at t=0 to be set
    t = -std::numeric_limits<double>::min();
    
{% include "solve_steady_state.tmpl" %}
}

/***********************************
 * Copy constructor for State class
 ***********************************/
{{component_name}}::State_::State_(const State_& s) :
  current_regime(s.current_regime), t(s.t) {
  
{% if component_class.num_state_variables %}
   for (int i = 0; i < {{component_class.num_state_variables}}; ++i)
       y_[i] = s.y_[i];
{% endif %}
}

/********************************************
 * Assignment of a State from another State *
 ********************************************/

{{component_name}}::State_& {{component_name}}::State_::operator=(const State_& s) {
  assert(this != &s);
{% if component_class.num_state_variables %}
    for (size_t i = 0 ; i < {{component_class.num_state_variables}} ; ++i)
        y_[i] = s.y_[i];
{% endif %}

    // Copy current regime and time
    current_regime = s.current_regime;
    t = s.t;

    return *this;
}

void {{component_name}}::calibrate() {

    // Check that the current regime is in the regimes vector
    bool found_current_regime = false;
    for (std::vector<{{component_name}}::Regime_*>::iterator regime_it = regimes.begin(); regime_it != regimes.end(); ++regime_it)
        if (*regime_it == S_.current_regime)
            found_current_regime = true;
    assert(found_current_regime); 
    S_.current_regime->init_solver();
    B_.logger_.init();
    V_.rng_ = nest::kernel().rng_manager.get_rng( get_thread() );
}

/***************************
 * Accessors and Modifiers *
 ***************************/

void {{component_name}}::Parameters_::get (DictionaryDatum &d_) const {

{# TODO: Should change this to names::{{name}}, {{name}} once I work out where
         to put the "names" declarations (probably in the header#}
    // Update dictionary from internal parameters, scaling if required.
{% for p in component_class.parameters %}
    def<double_t>(d_, "{{p.name}}", {{p.name}}{% if name in parameter_scales %} / {{parameter_scales[name]}}{% endif %});
{% endfor %}

}

void {{component_name}}::Parameters_::set (const DictionaryDatum &d_) {

    // Update internal parameters from dictionary
{% for p in component_class.parameters %}
    updateValue<double_t>(d_, "{{p.name}}", {{p.name}});
{% endfor %}

    // Scale parameters as required
{# Not sure if this is necessary
{% for name, scale in parameter_scales) %}
    {{name}} *= {{scale}};
{% endfor %}
#}
}

void {{component_name}}::State_::get (DictionaryDatum &d_) const {
    // Get states from internal variables
{% for i, sv in enumerate(component_class.state_variables) %}
    def<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
    def<std::string>(d_, CURRENT_REGIME, current_regime->get_name());
}

void {{component_name}}::State_::set(const DictionaryDatum &d_, const Parameters_&, Regime_* regime) {
    // Set internal state variables from dictionary values
{% for i, sv in enumerate(component_class.state_variables) %}
    updateValue<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}

    bool found_regime = false;
    for (std::vector<{{component_name}}::Regime_*>::iterator regime_it = current_regime->cell->regimes.begin(); regime_it != current_regime->cell->regimes.end(); ++regime_it) {
        if (*regime_it == regime)
            found_regime = true;
    }
    assert(found_regime);

    current_regime = regime;
}

/***********
 * Buffers *
 ***********/

{{component_name}}::Buffers_::Buffers_({{component_name}}& n)
    : logger_(n) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

{{component_name}}::Buffers_::Buffers_(const Buffers_&, {{component_name}}& n)
    : logger_(n) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

void {{component_name}}::init_buffers_() {

    // Clear event buffers
{% for p in component_class.event_receive_ports %}
    B_.{{p.name}}_event_port.clear();
{% endfor %}

    // Clear analog buffers
{% for p in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    B_.{{p.name}}_analog_port.clear();
{% endfor %}

    Archiving_Node::clear_history();

    B_.logger_.reset();

    B_.step_ = nest::Time::get_resolution().get_ms();

{% for p in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    B_.{{p.name}}_value = 0.0;
{% endfor %}

    // Set triggers in current regime
    S_.current_regime->set_triggers();
    S_.current_regime->init_solver();

}


void {{component_name}}::refresh_events(const long& lag) {
{% for port in component_class.event_send_ports %}
    B_.num_{{port.name}}_events = 0;
{% endfor %}
{% for port in component_class.event_receive_ports %}
    B_.{{port.name}}_events = &B_.{{port.name}}_event_port.get_list(lag);
{% endfor %}
}

/************************************************************************
 * Function to be solved for its roots be solver to exact trigger times *
 ************************************************************************/

{% include "trigger_roots.tmpl" %}

/***********************
 * Evaluate the update *
 ***********************/

void {{component_name}}::update(nest::Time const & origin, const long from, const long to) {

    assert(to >= 0 && (nest::delay) from < nest::kernel().connection_manager.get_min_delay());
    assert(from < to);

    long current_steps = origin.get_steps();

    double dt = nest::Time::get_resolution().get_ms();    

    for (long lag = from; lag < to; ++lag) {
    
        // Update time stored in state
        S_.t = origin.get_ms();
    
{% if 'ode' in debug_print %}
        std::cout << "Before ODE step - " << S_.to_str(S_.t) << std::endl;
{% endif %}
        /***** Solve ODE over timestep *****/
        S_.current_regime->step_ode();
    
{% if 'ode' in debug_print  %}
        std::cout << "After ODE step - " << S_.to_str(S_.t) << std::endl;
{% endif %}

        /***** Transition handling *****/
        // Get multiplicity incoming events for the current lag and reset multiplicity of outgoing events
        refresh_events(lag);
        
        // Set times for checking on-condition triggers
        double end_of_step_t = origin.get_ms() + lag * dt;  // The time at the end of the lag step
        
        // Pointer to the next transition
        Transition_* transition;
        int simultaneous_transition_count = 0;
        
        while ((transition = S_.current_regime->transition(end_of_step_t))) {  // Check for a transition (i.e. the output of current_regime->transition is not NULL) and record it in the 'transition' variable.
                    
            double t = transition->time_occurred(end_of_step_t);  // Get the exact time the transition occurred (if trigger is a solvable expression of 't')
            if (t == S_.t) {
                ++simultaneous_transition_count;
                if (simultaneous_transition_count > MAX_SIMULTANEOUS_TRANSITIONS)
                    throw ExceededMaximumSimultaneousTransitions("{{component_name}}", simultaneous_transition_count, t);
            } else {
                S_.t = t;  // Update time stored in state
                simultaneous_transition_count = 0;
            }

{% if 'transition' in debug_print %}
        std::cout << "Before transition from '" << S_.current_regime->get_name() << "' to '" << transition->get_target_regime()->get_name() << "' at " << S_.to_str(S_.t) << std::endl;
{% endif %}
            // Execute body of transition, flagging a discontinuity in the ODE system
            // if either the body contains state assignments (i.e. not just output
            // events) or the regime changes
            bool discontinuous = transition->body() || (transition->get_target_regime() != S_.current_regime);
            // Update the current regime
            S_.current_regime = transition->get_target_regime();
            // Set all triggers, i.e. activate all triggers for which their trigger condition 
            // evaluates to false.
            S_.current_regime->set_triggers();
            // Reinitialise the solver if the was a discontinuity in the ODE system
            if (discontinuous)
                S_.current_regime->init_solver();  // Reset the solver if the transition contains state assignments or switches to a new regime.

{% if 'transition' in debug_print %}
        std::cout << "After transition to '" << S_.current_regime->get_name() << "' at " << S_.to_str(S_.t) << std::endl;
{% endif %}                
        }
        
        // Update time stored in state before setting triggers
        S_.t = end_of_step_t;

        // Set active on-condition triggers before the next state update.
        // FIXME: This implementation can't detect multiple within-step
        //        triggers. Will need to use a solver that can detect zero
        //        crossings (e.g. CVODE), supply it with an appropriate
        //        equation (i.e. unwrap logical expressions and convert inequalties
        //        to equalities = 0, e.g. a < b ==> a - b == 0, (a < b) | (c > d)
        //        ==> (a - b) * (c - d) == 0, (a < b) & (c > d) ==>
        //        abs(a - b) + abs(c - d) == 0).
        S_.current_regime->set_triggers();
        
        /***** Send output events for each event send port *****/
        // FIXME: Need to specify different output ports in a way that can be read by the receiving nodes
        // Output events        
{% for port in component_class.event_send_ports %}
        if (B_.num_{{port.name}}_events) {
            set_spiketime(nest::Time::step(origin.get_steps()+lag+1));
            nest::SpikeEvent se;
            se.set_multiplicity(B_.num_{{port.name}}_events);
            nest::kernel().event_delivery_manager.send(*this, se, lag); 
        }
{% endfor %}

        /***** Get analog port values *****/
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
        B_.{{port.name}}_value = B_.{{port.name}}_analog_port.get_value(lag);
{% endfor %}

        /***** Record data *****/
        B_.logger_.record_data(current_steps + lag);
        
    }
}

/*****************
 * Event Handles *
 *****************/

void {{component_name}}::handle(nest::SpikeEvent & e) {
    assert(e.get_delay() > 0);

    // Get buffer for event receive port
    nest::ListRingBuffer* event_buffer;
{% for port in component_class.event_receive_ports %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_EVENT_PORT) {
        event_buffer = &B_.{{port.name}}_event_port;
    {% if loop.last %}
    } else
    {% endif %}
{% endfor %}
        assert(false);  // Unrecognised port 
    
    const unsigned int multiplicity = e.get_multiplicity();
    const unsigned int lag = e.get_rel_delivery_steps(nest::kernel().simulation_manager.get_slice_origin()); 
    const double_t weight = e.get_weight();

    // Append received events to buffer
    for (unsigned int i = 0; i < multiplicity; ++i)
        event_buffer->append_value(lag, weight);

}

void {{component_name}}::handle(nest::CurrentEvent& e) {
    assert(e.get_delay() > 0);

    //Get buffer for current receive port
    nest::RingBuffer* current_buffer;
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_ANALOG_PORT) {
        current_buffer = &B_.{{port.name}}_analog_port;
    {% if loop.last %}
    } else
    {% endif %}        
{% endfor %}
        assert(false);  // Unrecognised port

    const double_t c = e.get_current();
    const double_t w = e.get_weight();
    const unsigned int lag = e.get_rel_delivery_steps(nest::kernel().simulation_manager.get_slice_origin());

    // Append current value for lag
    current_buffer->add_value(lag, w * c);

}

void {{component_name}}::handle(nest::DataLoggingRequest& e) {
    B_.logger_.handle(e);
}


}  // End 'nineml' namespace
