{"version":3,"sources":["reviewRequestPageModel.es6.js"],"names":[],"mappings":"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","file":"reviewRequestPageModel.js","sourcesContent":["/**\n * Model for the review request page.\n *\n * This manages state specific to the review request page, and handles\n * watching for server-side updates relevant to entries and UI on the page.\n */\nRB.ReviewRequestPage.ReviewRequestPage = RB.ReviewablePage.extend({\n    defaults: _.defaults({\n        updatesURL: null,\n    }, RB.ReviewablePage.prototype.defaults),\n\n    /**\n     * Initialize the model.\n     */\n    initialize() {\n        RB.ReviewablePage.prototype.initialize.apply(this, arguments);\n\n        this._watchedEntries = {};\n        this._watchedUpdatesPeriodMS = null;\n        this._watchedUpdatesTimeout = null;\n        this._watchedUpdatesLastScheduleTime = null;\n\n        this.entries = new Backbone.Collection([], {\n            model: RB.ReviewRequestPage.Entry,\n        });\n    },\n\n    /**\n     * Parse the data for the page.\n     *\n     * This will take data from the server and turn it into a series of\n     * objects and attributes needed for parts of the page.\n     *\n     * Args:\n     *     rsp (object):\n     *         The incoming data provided for the page.\n     *\n     * Returns:\n     *     object:\n     *     The resulting attributes for the page.\n     */\n    parse(rsp) {\n        return _.extend({\n            updatesURL: rsp.updatesURL,\n        }, RB.ReviewablePage.prototype.parse.call(this, rsp));\n    },\n\n    /**\n     * Add an entry to the page.\n     *\n     * The entry's ``page`` attribute will be set to this page, for reference,\n     * and then the entry will be added to the ``entries`` collection.\n     *\n     * Args:\n     *     entry (RB.ReviewRequestPage.Entry):\n     *         The entry to add.\n     */\n    addEntry(entry) {\n        entry.set('page', this);\n        this.entries.add(entry);\n    },\n\n    /**\n     * Watch for updates to an entry.\n     *\n     * The entry will be checked for updates at least once every ``periodMS``\n     * milliseconds.\n     *\n     * Args:\n     *     entry (RB.ReviewRequestPage.Entry):\n     *         The entry being watched for updates.\n     *\n     *     periodMS (number):\n     *         The frequency at which the updates should be polled. Updates\n     *         will be checked at least this often.\n     */\n    watchEntryUpdates(entry, periodMS) {\n        /*\n         * If we already have a check in progress, and this new update\n         * request wants to check sooner than the current check is scheduled,\n         * then disconnect the old timer so we can reconnect it with the new\n         * delay.\n         */\n        if (this._watchedUpdatesPeriodMS === null ||\n            periodMS < this._watchedUpdatesPeriodMS) {\n            /*\n             * This is either the only update requested, or it's more frequent\n             * than other ones. Now we just need to check if we need to cancel\n             * any previous update checks that are scheduled later than the\n             * new check would be.\n             */\n            if (this._watchedUpdatesTimeout !== null &&\n                (Date.now() -\n                 this._watchedUpdatesLastScheduleTime) > periodMS) {\n                clearTimeout(this._watchedUpdatesTimeout);\n                this._watchedUpdatesTimeout = null;\n            }\n\n            this._watchedUpdatesPeriodMS = periodMS;\n        }\n\n        this._watchedEntries[entry.id] = {\n            entry: entry,\n            periodMS: periodMS,\n        };\n\n        this._scheduleCheckUpdates();\n    },\n\n    /**\n     * Stop watching for updates to an entry.\n     *\n     * Args:\n     *     entry (RB.ReviewRequestPage.Entry):\n     *         The entry being watched for updates.\n     */\n    stopWatchingEntryUpdates(entry) {\n        if (!this._watchedEntries.hasOwnProperty(entry.id)) {\n            return;\n        }\n\n        delete this._watchedEntries[entry.id];\n\n        /*\n         * We'll either be clearing this for now, or recomputing. Either way,\n         * we want this null for the next steps.\n         */\n        this._watchedUpdatesPeriodMS = null;\n\n        if (_.isEmpty(this._watchedEntries)) {\n            /*\n             * There's nothing left to watch, so cancel the timeout (if set)\n             * and clear state.\n             */\n            if (this._watchedUpdatesTimeout !== null) {\n                clearTimeout(this._watchedUpdatesTimeout);\n                this._watchedUpdatesTimeout = null;\n            }\n\n            this._watchedUpdatesLastScheduleTime = null;\n        } else {\n            /*\n             * There's still other entries being watched. We need to\n             * update state accordingly.\n             *\n             * We'll let any current timeouts continue as-is.\n             */\n            for (let key in this._watchedEntries) {\n                if (this._watchedEntries.hasOwnProperty(key)) {\n                    const periodMS = this._watchedEntries[key].periodMS;\n\n                    this._watchedUpdatesPeriodMS =\n                        (this._watchedUpdatesPeriodMS === null\n                         ? periodMS\n                         : Math.min(this._watchedUpdatesPeriodMS, periodMS));\n                }\n            }\n        }\n    },\n\n    /**\n     * Schedule the next updates check.\n     *\n     * The check will only be scheduled so long as there are still entries\n     * being watched. Any data returned in the check will trigger reloads\n     * of parts of the page.\n     */\n    _scheduleCheckUpdates() {\n        if (this._watchedUpdatesTimeout !== null ||\n            this._watchedUpdatesPeriodMS === null) {\n            return;\n        }\n\n        this._watchedUpdatesLastScheduleTime = Date.now();\n        this._watchedUpdatesTimeout = setTimeout(\n            () => {\n                this._watchedUpdatesTimeout = null;\n                this._loadUpdates({\n                    entries: _.pluck(this._watchedEntries, 'entry'),\n                    onDone: this._scheduleCheckUpdates.bind(this),\n                });\n            },\n            this._watchedUpdatesPeriodMS);\n    },\n\n    /**\n     * Load updates from the server.\n     *\n     * Args:\n     *     options (object, optional):\n     *         Options that control the types of updates loaded from the\n     *         server.\n     *\n     * Option Args:\n     *     entries (Array):\n     *         A list of entry models that need to be checked for updates.\n     *\n     *     onDone (function, optional):\n     *         Optional function to call after everything is loaded.\n     */\n    _loadUpdates(options={}) {\n        const updatesURL = this.get('updatesURL');\n        const allEntryIDs = {};\n        const entries = options.entries || [];\n\n        const urlQuery = [];\n\n        if (entries.length > 0) {\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                const typeID = entry.get('typeID');\n\n                if (!allEntryIDs.hasOwnProperty(typeID)) {\n                    allEntryIDs[typeID] = [];\n                }\n\n                allEntryIDs[typeID].push(entry.id);\n            }\n\n            const urlEntryTypeIDs = [];\n\n            for (let entryTypeID in allEntryIDs) {\n                if (allEntryIDs.hasOwnProperty(entryTypeID)) {\n                    /*\n                     * Sort the IDs numerically, so that we have a stable URL\n                     * for caching.\n                     */\n                    allEntryIDs[entryTypeID].sort((a, b) => a - b);\n\n                    const entryIDs = allEntryIDs[entryTypeID].join(',');\n                    urlEntryTypeIDs.push(`${entryTypeID}:${entryIDs}`);\n                }\n            }\n\n            urlQuery.push(`entries=${urlEntryTypeIDs.join(';')}`);\n        }\n\n        /*\n         * Like above, sort the URL queries, so that we have a stable URL\n         * for caching.\n         */\n        urlQuery.sort();\n\n        Backbone.sync(\n            'read',\n            this,\n            {\n                url: `${updatesURL}?${urlQuery.join('&')}`,\n                dataType: 'text',\n                noActivityIndicator: true,\n                success: rsp => {\n                    this._processUpdates(rsp);\n\n                    if (_.isFunction(options.onDone)) {\n                        options.onDone();\n                    }\n                },\n            });\n    },\n\n    /**\n     * Process an updates payload from the server.\n     *\n     * This will parse the payload and then update each of the entries\n     * or other parts of the UI referenced.\n     *\n     * Args:\n     *     rsp (string):\n     *         The updates payload.\n     */\n    _processUpdates(rsp) {\n        const len = rsp.length;\n        let i = 0;\n\n        while (i < len) {\n            /* Read the length of the metadata. */\n            let j = rsp.indexOf('\\n', i);\n            const metadataLen = parseInt(rsp.substr(i, j - i), 10);\n            i = j + 1;\n\n            /* Read the metadata content and parse it. */\n            const metadata = JSON.parse(rsp.substr(i, metadataLen));\n            i += metadataLen;\n\n            /* Read the length of the HTML content. */\n            j = rsp.indexOf('\\n', i);\n            const htmlLen = parseInt(rsp.substr(i, j - i), 10);\n            i = j + 1;\n\n            /* Read the HTML content. */\n            const html = rsp.substr(i, htmlLen);\n            i += htmlLen;\n\n            /*\n             * Based on the update, we can now start updating the UI, if\n             * we can find the matching entry or UI component.\n             */\n            if (metadata.type === 'entry') {\n                this._processEntryUpdate(metadata, html);\n            } else {\n                this._reloadFromUpdate(null, metadata, html);\n            }\n        }\n\n        this.trigger('updatesProcessed');\n    },\n\n    /**\n     * Process the update to an entry.\n     *\n     * This will locate the existing entry on the page, check if it needs\n     * updating, and then update the entry's attributes and HTML.\n     *\n     * Args:\n     *     metadata (object):\n     *         The metadata for the entry update.\n     *\n     *     html (string):\n     *         The new HTML for the entry.\n     */\n    _processEntryUpdate(metadata, html) {\n        /*\n         * TODO: We'll eventually want to handle new entries we don't\n         *       know about. This would be part of a larger dynamic\n         *       page updates change.\n         */\n        const entry = this.entries.get(metadata.entryID);\n\n        if (!entry) {\n            return;\n        }\n\n        console.assert(entry.get('typeID') === metadata.entryType);\n\n        /* Only reload this entry if its updated timestamp has changed. */\n        const newTimestamp = new Date(metadata.updatedTimestamp);\n\n        if (newTimestamp <= entry.get('updatedTimestamp')) {\n            return;\n        }\n\n        this._reloadFromUpdate(entry, metadata, html);\n    },\n\n    /**\n     * Reload a component's attributes and HTML based on an update.\n     *\n     * This will update the attributes for a model, notifying listeners of\n     * each stage of the update so that models and views can react\n     * appropriately.\n     *\n     * If the model has ``beforeApplyUpdate`` and/or ``afterApplyUpdate``\n     * methods, they'll be called before and after any updates are made,\n     * respectively.\n     *\n     * Args:\n     *     model (Backbone.Model):\n     *         The model to update.\n     *\n     *     metadata (object):\n     *         The metadata for the update.\n     *\n     *     html (string):\n     *         The new HTML for the view.\n     */\n    _reloadFromUpdate(model, metadata, html) {\n        this.trigger(`applyingUpdate:${metadata.type}`, metadata, html);\n\n        if (model) {\n            this.trigger(`applyingUpdate:${metadata.type}:${model.id}`,\n                         metadata, html);\n\n            if (_.isFunction(model.beforeApplyUpdate)) {\n                model.beforeApplyUpdate(metadata);\n            }\n\n            if (metadata.modelData) {\n                model.set(model.parse(_.extend({},\n                                               model.attributes,\n                                               metadata.modelData)));\n            }\n\n            this.trigger(`appliedModelUpdate:${metadata.type}:${model.id}`,\n                         metadata, html);\n\n            if (_.isFunction(model.afterApplyUpdate)) {\n                model.afterApplyUpdate(metadata);\n            }\n\n            this.trigger(`appliedUpdate:${metadata.type}:${model.id}`,\n                         metadata, html);\n        }\n\n        this.trigger(`appliedUpdate:${metadata.type}`, metadata, html);\n    },\n});\n"]}