# encoding: utf-8
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import emq.common.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class MessageAttribute(object):
  """
  Copyright 2015, Xiaomi.
  All rights reserved.
  Author: shenyuannan@xiaomi.com

  Attributes:
   - type: must start with "STRING" or "BINARY", with an optional "." and a user-defined sub-type
  like "STRING.INTEGER" or "BINARY.JPEG"
  do not contain characters excepts alphabets, digits or "."

   - stringValue: must be set if type is "STRING"

   - binaryValue: must be set if type is "BINARY"

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type', None, None, ), # 1
    (2, TType.STRING, 'stringValue', None, None, ), # 2
    (3, TType.STRING, 'binaryValue', None, None, ), # 3
  )

  def __init__(self, type=None, stringValue=None, binaryValue=None,):
    self.type = type
    self.stringValue = stringValue
    self.binaryValue = binaryValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.binaryValue = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MessageAttribute')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 1)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 2)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    if self.binaryValue is not None:
      oprot.writeFieldBegin('binaryValue', TType.STRING, 3)
      oprot.writeString(self.binaryValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.stringValue)
    value = (value * 31) ^ hash(self.binaryValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - messageBody: Message body;

   - delaySeconds: Delay seconds for this message, this will overwrite delaySecond of this
  queue, default 0s (0s ~ 15min);

   - invisibilitySeconds: Invisibility seconds for this message, this will overwrite
  invisibilitySeconds of this queue, default 30s (2s ~ 12hour);

   - messageAttributes: User-defined attributes attached to message

   - topic: Topic of this message

   - priority: The priority of the message, default 8 (1 ~ 16);

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'messageBody', None, None, ), # 2
    (3, TType.I32, 'delaySeconds', None, None, ), # 3
    (4, TType.I32, 'invisibilitySeconds', None, None, ), # 4
    (5, TType.MAP, 'messageAttributes', (TType.STRING,None,TType.STRUCT,(MessageAttribute, MessageAttribute.thrift_spec)), None, ), # 5
    (6, TType.STRING, 'topic', None, None, ), # 6
    (7, TType.I32, 'priority', None, None, ), # 7
  )

  def __init__(self, queueName=None, messageBody=None, delaySeconds=None, invisibilitySeconds=None, messageAttributes=None, topic=None, priority=None,):
    self.queueName = queueName
    self.messageBody = messageBody
    self.delaySeconds = delaySeconds
    self.invisibilitySeconds = invisibilitySeconds
    self.messageAttributes = messageAttributes
    self.topic = topic
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.messageBody = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.delaySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.messageAttributes = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in range(_size0):
            _key5 = iprot.readString();
            _val6 = MessageAttribute()
            _val6.read(iprot)
            self.messageAttributes[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.topic = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.messageBody is not None:
      oprot.writeFieldBegin('messageBody', TType.STRING, 2)
      oprot.writeString(self.messageBody)
      oprot.writeFieldEnd()
    if self.delaySeconds is not None:
      oprot.writeFieldBegin('delaySeconds', TType.I32, 3)
      oprot.writeI32(self.delaySeconds)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 4)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    if self.messageAttributes is not None:
      oprot.writeFieldBegin('messageAttributes', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.messageAttributes))
      for kiter7,viter8 in list(self.messageAttributes.items()):
        oprot.writeString(kiter7)
        viter8.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.topic is not None:
      oprot.writeFieldBegin('topic', TType.STRING, 6)
      oprot.writeString(self.topic)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 7)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.messageBody is None:
      raise TProtocol.TProtocolException(message='Required field messageBody is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.messageBody)
    value = (value * 31) ^ hash(self.delaySeconds)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    value = (value * 31) ^ hash(self.messageAttributes)
    value = (value * 31) ^ hash(self.topic)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageResponse(object):
  """
  Attributes:
   - messageID: MessageID for the send message

   - bodyLength: Length of message body

   - bodyMd5: MD5 string of the message body

   - sendTimestamp: timestamp when the message arrived servers

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'messageID', None, None, ), # 1
    (2, TType.I32, 'bodyLength', None, None, ), # 2
    (3, TType.STRING, 'bodyMd5', None, None, ), # 3
    (4, TType.I64, 'sendTimestamp', None, None, ), # 4
  )

  def __init__(self, messageID=None, bodyLength=None, bodyMd5=None, sendTimestamp=None,):
    self.messageID = messageID
    self.bodyLength = bodyLength
    self.bodyMd5 = bodyMd5
    self.sendTimestamp = sendTimestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.messageID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.bodyLength = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.bodyMd5 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.sendTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageResponse')
    if self.messageID is not None:
      oprot.writeFieldBegin('messageID', TType.STRING, 1)
      oprot.writeString(self.messageID)
      oprot.writeFieldEnd()
    if self.bodyLength is not None:
      oprot.writeFieldBegin('bodyLength', TType.I32, 2)
      oprot.writeI32(self.bodyLength)
      oprot.writeFieldEnd()
    if self.bodyMd5 is not None:
      oprot.writeFieldBegin('bodyMd5', TType.STRING, 3)
      oprot.writeString(self.bodyMd5)
      oprot.writeFieldEnd()
    if self.sendTimestamp is not None:
      oprot.writeFieldBegin('sendTimestamp', TType.I64, 4)
      oprot.writeI64(self.sendTimestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.messageID is None:
      raise TProtocol.TProtocolException(message='Required field messageID is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.messageID)
    value = (value * 31) ^ hash(self.bodyLength)
    value = (value * 31) ^ hash(self.bodyMd5)
    value = (value * 31) ^ hash(self.sendTimestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageBatchRequestEntry(object):
  """
  Attributes:
   - entryId: The identifier for this particular receipt handle;
  Using to identify the result in response;
  Need to be unique within one batch

   - messageBody: Message body;

   - delaySeconds: Delay seconds for this message, this will overwrite delaySecond of this
  queue, default 0s (0s ~ 15min);

   - invisibilitySeconds: Invisibility seconds for this message, this will overwrite
  invisibilitySeconds of this queue, default 30s (2s ~ 12hour);

   - messageAttributes: User-defined attributes attached to message

   - priority: The priority of the message, default 8 (1 ~ 16);

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'entryId', None, None, ), # 1
    (2, TType.STRING, 'messageBody', None, None, ), # 2
    (3, TType.I32, 'delaySeconds', None, None, ), # 3
    (4, TType.I32, 'invisibilitySeconds', None, None, ), # 4
    (5, TType.MAP, 'messageAttributes', (TType.STRING,None,TType.STRUCT,(MessageAttribute, MessageAttribute.thrift_spec)), None, ), # 5
    (6, TType.I32, 'priority', None, None, ), # 6
  )

  def __init__(self, entryId=None, messageBody=None, delaySeconds=None, invisibilitySeconds=None, messageAttributes=None, priority=None,):
    self.entryId = entryId
    self.messageBody = messageBody
    self.delaySeconds = delaySeconds
    self.invisibilitySeconds = invisibilitySeconds
    self.messageAttributes = messageAttributes
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.entryId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.messageBody = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.delaySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.messageAttributes = {}
          (_ktype10, _vtype11, _size9 ) = iprot.readMapBegin()
          for _i13 in range(_size9):
            _key14 = iprot.readString();
            _val15 = MessageAttribute()
            _val15.read(iprot)
            self.messageAttributes[_key14] = _val15
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageBatchRequestEntry')
    if self.entryId is not None:
      oprot.writeFieldBegin('entryId', TType.STRING, 1)
      oprot.writeString(self.entryId)
      oprot.writeFieldEnd()
    if self.messageBody is not None:
      oprot.writeFieldBegin('messageBody', TType.STRING, 2)
      oprot.writeString(self.messageBody)
      oprot.writeFieldEnd()
    if self.delaySeconds is not None:
      oprot.writeFieldBegin('delaySeconds', TType.I32, 3)
      oprot.writeI32(self.delaySeconds)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 4)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    if self.messageAttributes is not None:
      oprot.writeFieldBegin('messageAttributes', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.messageAttributes))
      for kiter16,viter17 in list(self.messageAttributes.items()):
        oprot.writeString(kiter16)
        viter17.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 6)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.entryId is None:
      raise TProtocol.TProtocolException(message='Required field entryId is unset!')
    if self.messageBody is None:
      raise TProtocol.TProtocolException(message='Required field messageBody is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.entryId)
    value = (value * 31) ^ hash(self.messageBody)
    value = (value * 31) ^ hash(self.delaySeconds)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    value = (value * 31) ^ hash(self.messageAttributes)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageBatchRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - sendMessageBatchRequestEntryList: List of SendMessageBatchRequestEntry;

   - topic: Topic of this message-list

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.LIST, 'sendMessageBatchRequestEntryList', (TType.STRUCT,(SendMessageBatchRequestEntry, SendMessageBatchRequestEntry.thrift_spec)), None, ), # 2
    (3, TType.STRING, 'topic', None, None, ), # 3
  )

  def __init__(self, queueName=None, sendMessageBatchRequestEntryList=None, topic=None,):
    self.queueName = queueName
    self.sendMessageBatchRequestEntryList = sendMessageBatchRequestEntryList
    self.topic = topic

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sendMessageBatchRequestEntryList = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in range(_size18):
            _elem23 = SendMessageBatchRequestEntry()
            _elem23.read(iprot)
            self.sendMessageBatchRequestEntryList.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.topic = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageBatchRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.sendMessageBatchRequestEntryList is not None:
      oprot.writeFieldBegin('sendMessageBatchRequestEntryList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.sendMessageBatchRequestEntryList))
      for iter24 in self.sendMessageBatchRequestEntryList:
        iter24.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.topic is not None:
      oprot.writeFieldBegin('topic', TType.STRING, 3)
      oprot.writeString(self.topic)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.sendMessageBatchRequestEntryList is None:
      raise TProtocol.TProtocolException(message='Required field sendMessageBatchRequestEntryList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.sendMessageBatchRequestEntryList)
    value = (value * 31) ^ hash(self.topic)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageBatchResponseEntry(object):
  """
  Attributes:
   - entryId: corresponding to the entryId in request

   - messageID: MessageID for the send message

   - bodyLength: Length of message body

   - bodyMd5: MD5 string of the message body

   - sendTimestamp: timestamp when the message arrived servers

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'entryId', None, None, ), # 1
    (2, TType.STRING, 'messageID', None, None, ), # 2
    (3, TType.I32, 'bodyLength', None, None, ), # 3
    (4, TType.STRING, 'bodyMd5', None, None, ), # 4
    (5, TType.I64, 'sendTimestamp', None, None, ), # 5
  )

  def __init__(self, entryId=None, messageID=None, bodyLength=None, bodyMd5=None, sendTimestamp=None,):
    self.entryId = entryId
    self.messageID = messageID
    self.bodyLength = bodyLength
    self.bodyMd5 = bodyMd5
    self.sendTimestamp = sendTimestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.entryId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.messageID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.bodyLength = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.bodyMd5 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.sendTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageBatchResponseEntry')
    if self.entryId is not None:
      oprot.writeFieldBegin('entryId', TType.STRING, 1)
      oprot.writeString(self.entryId)
      oprot.writeFieldEnd()
    if self.messageID is not None:
      oprot.writeFieldBegin('messageID', TType.STRING, 2)
      oprot.writeString(self.messageID)
      oprot.writeFieldEnd()
    if self.bodyLength is not None:
      oprot.writeFieldBegin('bodyLength', TType.I32, 3)
      oprot.writeI32(self.bodyLength)
      oprot.writeFieldEnd()
    if self.bodyMd5 is not None:
      oprot.writeFieldBegin('bodyMd5', TType.STRING, 4)
      oprot.writeString(self.bodyMd5)
      oprot.writeFieldEnd()
    if self.sendTimestamp is not None:
      oprot.writeFieldBegin('sendTimestamp', TType.I64, 5)
      oprot.writeI64(self.sendTimestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.entryId is None:
      raise TProtocol.TProtocolException(message='Required field entryId is unset!')
    if self.messageID is None:
      raise TProtocol.TProtocolException(message='Required field messageID is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.entryId)
    value = (value * 31) ^ hash(self.messageID)
    value = (value * 31) ^ hash(self.bodyLength)
    value = (value * 31) ^ hash(self.bodyMd5)
    value = (value * 31) ^ hash(self.sendTimestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MessageBatchErrorEntry(object):
  """
  Attributes:
   - id: corresponding to the entryId/receiptHandle in request

   - reason: The exception indicate why the request entry failed

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'reason', (emq.common.ttypes.GalaxyEmqServiceException, emq.common.ttypes.GalaxyEmqServiceException.thrift_spec), None, ), # 2
  )

  def __init__(self, id=None, reason=None,):
    self.id = id
    self.reason = reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.reason = emq.common.ttypes.GalaxyEmqServiceException()
          self.reason.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MessageBatchErrorEntry')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.reason is not None:
      oprot.writeFieldBegin('reason', TType.STRUCT, 2)
      self.reason.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.reason is None:
      raise TProtocol.TProtocolException(message='Required field reason is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.reason)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageBatchResponse(object):
  """
  Attributes:
   - successful: The successful results list;

   - failed: Failed results list;

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'successful', (TType.STRUCT,(SendMessageBatchResponseEntry, SendMessageBatchResponseEntry.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'failed', (TType.STRUCT,(MessageBatchErrorEntry, MessageBatchErrorEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, successful=None, failed=None,):
    self.successful = successful
    self.failed = failed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.successful = []
          (_etype28, _size25) = iprot.readListBegin()
          for _i29 in range(_size25):
            _elem30 = SendMessageBatchResponseEntry()
            _elem30.read(iprot)
            self.successful.append(_elem30)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.failed = []
          (_etype34, _size31) = iprot.readListBegin()
          for _i35 in range(_size31):
            _elem36 = MessageBatchErrorEntry()
            _elem36.read(iprot)
            self.failed.append(_elem36)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageBatchResponse')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.successful))
      for iter37 in self.successful:
        iter37.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.failed is not None:
      oprot.writeFieldBegin('failed', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.failed))
      for iter38 in self.failed:
        iter38.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.failed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReceiveMessageRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - maxReceiveMessageNumber: Max receive message number, default 100 (1 ~ 100);

   - maxReceiveMessageWaitSeconds: Max receive message wait seconds, default 20s (0 ~ 20), 0s means no wait;

   - attributeName: Attribute name to match
  case-sensitive

   - attributeValue: Attribute value to match, corresponding to attributeName
  case-sensitive

   - tagName: If this field is not_set/null/empty, default queue tag will be used

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.I32, 'maxReceiveMessageNumber', None, 100, ), # 2
    (3, TType.I32, 'maxReceiveMessageWaitSeconds', None, 0, ), # 3
    (4, TType.STRING, 'attributeName', None, None, ), # 4
    (5, TType.STRUCT, 'attributeValue', (MessageAttribute, MessageAttribute.thrift_spec), None, ), # 5
    (6, TType.STRING, 'tagName', None, None, ), # 6
  )

  def __init__(self, queueName=None, maxReceiveMessageNumber=thrift_spec[2][4], maxReceiveMessageWaitSeconds=thrift_spec[3][4], attributeName=None, attributeValue=None, tagName=None,):
    self.queueName = queueName
    self.maxReceiveMessageNumber = maxReceiveMessageNumber
    self.maxReceiveMessageWaitSeconds = maxReceiveMessageWaitSeconds
    self.attributeName = attributeName
    self.attributeValue = attributeValue
    self.tagName = tagName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxReceiveMessageNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxReceiveMessageWaitSeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.attributeName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attributeValue = MessageAttribute()
          self.attributeValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.tagName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReceiveMessageRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.maxReceiveMessageNumber is not None:
      oprot.writeFieldBegin('maxReceiveMessageNumber', TType.I32, 2)
      oprot.writeI32(self.maxReceiveMessageNumber)
      oprot.writeFieldEnd()
    if self.maxReceiveMessageWaitSeconds is not None:
      oprot.writeFieldBegin('maxReceiveMessageWaitSeconds', TType.I32, 3)
      oprot.writeI32(self.maxReceiveMessageWaitSeconds)
      oprot.writeFieldEnd()
    if self.attributeName is not None:
      oprot.writeFieldBegin('attributeName', TType.STRING, 4)
      oprot.writeString(self.attributeName)
      oprot.writeFieldEnd()
    if self.attributeValue is not None:
      oprot.writeFieldBegin('attributeValue', TType.STRUCT, 5)
      self.attributeValue.write(oprot)
      oprot.writeFieldEnd()
    if self.tagName is not None:
      oprot.writeFieldBegin('tagName', TType.STRING, 6)
      oprot.writeString(self.tagName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.maxReceiveMessageNumber)
    value = (value * 31) ^ hash(self.maxReceiveMessageWaitSeconds)
    value = (value * 31) ^ hash(self.attributeName)
    value = (value * 31) ^ hash(self.attributeValue)
    value = (value * 31) ^ hash(self.tagName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReceiveMessageResponse(object):
  """
  Attributes:
   - messageID: MessageID for the received message;

   - receiptHandle: Receipt Handle for the received message
  Using when change visibility time/delete message

   - messageBody: Message body for the received message;

   - attributes: Attributes of message, including:
  - senderId
  - priority
  - messageLength
  - md5OfBody
  - sendTimestamp
  - receiveTimestamp
  - firstReceiveTimestamp
  - receiveCount

  If the message is received from a dead letter queue,
  it has another four attributes:
  - sourceQueueName
  - sourceTag
  - deadTimestamp
  - originalMessageID
  - originalReceiveCount

  If the message has been set topic
  - topic

   - messageAttributes: User-defined attributes attached to message

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'messageID', None, None, ), # 1
    (2, TType.STRING, 'receiptHandle', None, None, ), # 2
    (3, TType.STRING, 'messageBody', None, None, ), # 3
    (4, TType.MAP, 'attributes', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.MAP, 'messageAttributes', (TType.STRING,None,TType.STRUCT,(MessageAttribute, MessageAttribute.thrift_spec)), None, ), # 5
  )

  def __init__(self, messageID=None, receiptHandle=None, messageBody=None, attributes=None, messageAttributes=None,):
    self.messageID = messageID
    self.receiptHandle = receiptHandle
    self.messageBody = messageBody
    self.attributes = attributes
    self.messageAttributes = messageAttributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.messageID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.messageBody = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin()
          for _i43 in range(_size39):
            _key44 = iprot.readString();
            _val45 = iprot.readString();
            self.attributes[_key44] = _val45
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.messageAttributes = {}
          (_ktype47, _vtype48, _size46 ) = iprot.readMapBegin()
          for _i50 in range(_size46):
            _key51 = iprot.readString();
            _val52 = MessageAttribute()
            _val52.read(iprot)
            self.messageAttributes[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReceiveMessageResponse')
    if self.messageID is not None:
      oprot.writeFieldBegin('messageID', TType.STRING, 1)
      oprot.writeString(self.messageID)
      oprot.writeFieldEnd()
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 2)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    if self.messageBody is not None:
      oprot.writeFieldBegin('messageBody', TType.STRING, 3)
      oprot.writeString(self.messageBody)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
      for kiter53,viter54 in list(self.attributes.items()):
        oprot.writeString(kiter53)
        oprot.writeString(viter54)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.messageAttributes is not None:
      oprot.writeFieldBegin('messageAttributes', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.messageAttributes))
      for kiter55,viter56 in list(self.messageAttributes.items()):
        oprot.writeString(kiter55)
        viter56.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.messageID is None:
      raise TProtocol.TProtocolException(message='Required field messageID is unset!')
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    if self.messageBody is None:
      raise TProtocol.TProtocolException(message='Required field messageBody is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.messageID)
    value = (value * 31) ^ hash(self.receiptHandle)
    value = (value * 31) ^ hash(self.messageBody)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.messageAttributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChangeMessageVisibilityRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - receiptHandle: receiptHandle for change visibility;

   - invisibilitySeconds: The extra invisibilitySeconds for this message (0s ~ 12hour)

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'receiptHandle', None, None, ), # 2
    (3, TType.I32, 'invisibilitySeconds', None, None, ), # 3
  )

  def __init__(self, queueName=None, receiptHandle=None, invisibilitySeconds=None,):
    self.queueName = queueName
    self.receiptHandle = receiptHandle
    self.invisibilitySeconds = invisibilitySeconds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChangeMessageVisibilityRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 2)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 3)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    if self.invisibilitySeconds is None:
      raise TProtocol.TProtocolException(message='Required field invisibilitySeconds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.receiptHandle)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChangeMessageVisibilityBatchRequestEntry(object):
  """
  Attributes:
   - receiptHandle: receiptHandle for change visibility;

   - invisibilitySeconds: The extra invisibilitySeconds for this message (0s ~ 12hour)

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'receiptHandle', None, None, ), # 1
    (2, TType.I32, 'invisibilitySeconds', None, None, ), # 2
  )

  def __init__(self, receiptHandle=None, invisibilitySeconds=None,):
    self.receiptHandle = receiptHandle
    self.invisibilitySeconds = invisibilitySeconds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChangeMessageVisibilityBatchRequestEntry')
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 1)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 2)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    if self.invisibilitySeconds is None:
      raise TProtocol.TProtocolException(message='Required field invisibilitySeconds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.receiptHandle)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChangeMessageVisibilityBatchRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - changeMessageVisibilityRequestEntryList: List of ChangeMessageVisibilityRequest;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.LIST, 'changeMessageVisibilityRequestEntryList', (TType.STRUCT,(ChangeMessageVisibilityBatchRequestEntry, ChangeMessageVisibilityBatchRequestEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, queueName=None, changeMessageVisibilityRequestEntryList=None,):
    self.queueName = queueName
    self.changeMessageVisibilityRequestEntryList = changeMessageVisibilityRequestEntryList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.changeMessageVisibilityRequestEntryList = []
          (_etype60, _size57) = iprot.readListBegin()
          for _i61 in range(_size57):
            _elem62 = ChangeMessageVisibilityBatchRequestEntry()
            _elem62.read(iprot)
            self.changeMessageVisibilityRequestEntryList.append(_elem62)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChangeMessageVisibilityBatchRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.changeMessageVisibilityRequestEntryList is not None:
      oprot.writeFieldBegin('changeMessageVisibilityRequestEntryList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.changeMessageVisibilityRequestEntryList))
      for iter63 in self.changeMessageVisibilityRequestEntryList:
        iter63.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.changeMessageVisibilityRequestEntryList is None:
      raise TProtocol.TProtocolException(message='Required field changeMessageVisibilityRequestEntryList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.changeMessageVisibilityRequestEntryList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChangeMessageVisibilityBatchResponse(object):
  """
  Attributes:
   - successful: The successful receipt handle;

   - failed: Failed results list;
  Using receipt handle to index

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'successful', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'failed', (TType.STRUCT,(MessageBatchErrorEntry, MessageBatchErrorEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, successful=None, failed=None,):
    self.successful = successful
    self.failed = failed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.successful = []
          (_etype67, _size64) = iprot.readListBegin()
          for _i68 in range(_size64):
            _elem69 = iprot.readString();
            self.successful.append(_elem69)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.failed = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in range(_size70):
            _elem75 = MessageBatchErrorEntry()
            _elem75.read(iprot)
            self.failed.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChangeMessageVisibilityBatchResponse')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.successful))
      for iter76 in self.successful:
        oprot.writeString(iter76)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.failed is not None:
      oprot.writeFieldBegin('failed', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.failed))
      for iter77 in self.failed:
        iter77.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.failed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteMessageRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - receiptHandle: receipt handle of message to delete;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'receiptHandle', None, None, ), # 2
  )

  def __init__(self, queueName=None, receiptHandle=None,):
    self.queueName = queueName
    self.receiptHandle = receiptHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteMessageRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 2)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.receiptHandle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteMessageBatchRequestEntry(object):
  """
  Attributes:
   - receiptHandle: receipt handle of message to delete;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'receiptHandle', None, None, ), # 1
  )

  def __init__(self, receiptHandle=None,):
    self.receiptHandle = receiptHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteMessageBatchRequestEntry')
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 1)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.receiptHandle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteMessageBatchRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - deleteMessageBatchRequestEntryList: List of DeleteMessageRequest;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.LIST, 'deleteMessageBatchRequestEntryList', (TType.STRUCT,(DeleteMessageBatchRequestEntry, DeleteMessageBatchRequestEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, queueName=None, deleteMessageBatchRequestEntryList=None,):
    self.queueName = queueName
    self.deleteMessageBatchRequestEntryList = deleteMessageBatchRequestEntryList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.deleteMessageBatchRequestEntryList = []
          (_etype81, _size78) = iprot.readListBegin()
          for _i82 in range(_size78):
            _elem83 = DeleteMessageBatchRequestEntry()
            _elem83.read(iprot)
            self.deleteMessageBatchRequestEntryList.append(_elem83)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteMessageBatchRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.deleteMessageBatchRequestEntryList is not None:
      oprot.writeFieldBegin('deleteMessageBatchRequestEntryList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.deleteMessageBatchRequestEntryList))
      for iter84 in self.deleteMessageBatchRequestEntryList:
        iter84.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.deleteMessageBatchRequestEntryList is None:
      raise TProtocol.TProtocolException(message='Required field deleteMessageBatchRequestEntryList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.deleteMessageBatchRequestEntryList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteMessageBatchResponse(object):
  """
  Attributes:
   - successful: The successful receipt handle;

   - failed: Failed results list;
  Using receipt handle to index

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'successful', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'failed', (TType.STRUCT,(MessageBatchErrorEntry, MessageBatchErrorEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, successful=None, failed=None,):
    self.successful = successful
    self.failed = failed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.successful = []
          (_etype88, _size85) = iprot.readListBegin()
          for _i89 in range(_size85):
            _elem90 = iprot.readString();
            self.successful.append(_elem90)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.failed = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in range(_size91):
            _elem96 = MessageBatchErrorEntry()
            _elem96.read(iprot)
            self.failed.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteMessageBatchResponse')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.successful))
      for iter97 in self.successful:
        oprot.writeString(iter97)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.failed is not None:
      oprot.writeFieldBegin('failed', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.failed))
      for iter98 in self.failed:
        iter98.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.failed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeadMessageRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - receiptHandle: receipt handle of message to die;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'receiptHandle', None, None, ), # 2
  )

  def __init__(self, queueName=None, receiptHandle=None,):
    self.queueName = queueName
    self.receiptHandle = receiptHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeadMessageRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 2)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.receiptHandle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeadMessageBatchRequestEntry(object):
  """
  Attributes:
   - receiptHandle: receipt handle of message to die;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'receiptHandle', None, None, ), # 1
  )

  def __init__(self, receiptHandle=None,):
    self.receiptHandle = receiptHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeadMessageBatchRequestEntry')
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 1)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.receiptHandle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeadMessageBatchRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - deadMessageBatchRequestEntryList: List of DeadMessageBatchRequestEntry;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.LIST, 'deadMessageBatchRequestEntryList', (TType.STRUCT,(DeadMessageBatchRequestEntry, DeadMessageBatchRequestEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, queueName=None, deadMessageBatchRequestEntryList=None,):
    self.queueName = queueName
    self.deadMessageBatchRequestEntryList = deadMessageBatchRequestEntryList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.deadMessageBatchRequestEntryList = []
          (_etype102, _size99) = iprot.readListBegin()
          for _i103 in range(_size99):
            _elem104 = DeadMessageBatchRequestEntry()
            _elem104.read(iprot)
            self.deadMessageBatchRequestEntryList.append(_elem104)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeadMessageBatchRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.deadMessageBatchRequestEntryList is not None:
      oprot.writeFieldBegin('deadMessageBatchRequestEntryList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.deadMessageBatchRequestEntryList))
      for iter105 in self.deadMessageBatchRequestEntryList:
        iter105.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.deadMessageBatchRequestEntryList is None:
      raise TProtocol.TProtocolException(message='Required field deadMessageBatchRequestEntryList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.deadMessageBatchRequestEntryList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeadMessageBatchResponse(object):
  """
  Attributes:
   - successful: The successful receipt handle;

   - failed: Failed results list;
  Using receipt handle to index

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'successful', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'failed', (TType.STRUCT,(MessageBatchErrorEntry, MessageBatchErrorEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, successful=None, failed=None,):
    self.successful = successful
    self.failed = failed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.successful = []
          (_etype109, _size106) = iprot.readListBegin()
          for _i110 in range(_size106):
            _elem111 = iprot.readString();
            self.successful.append(_elem111)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.failed = []
          (_etype115, _size112) = iprot.readListBegin()
          for _i116 in range(_size112):
            _elem117 = MessageBatchErrorEntry()
            _elem117.read(iprot)
            self.failed.append(_elem117)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeadMessageBatchResponse')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.successful))
      for iter118 in self.successful:
        oprot.writeString(iter118)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.failed is not None:
      oprot.writeFieldBegin('failed', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.failed))
      for iter119 in self.failed:
        iter119.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.failed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
