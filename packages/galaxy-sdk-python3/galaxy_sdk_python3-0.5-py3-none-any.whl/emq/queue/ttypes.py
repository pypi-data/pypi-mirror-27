# encoding: utf-8
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import emq.common.ttypes
import emq.message.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Permission(object):
  NONE = 0
  SEND_MESSAGE = 1
  RECEIVE_MESSAGE = 2
  SEND_RECEIVE_MESSAGE = 3
  HANDLE_MESSAGE = 4
  SEND_HANDLE_MESSAGE = 5
  GET_QUEUE_INFO = 6
  USE_QUEUE = 7
  ADMIN_QUEUE = 8
  FULL_CONTROL = 9

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "SEND_MESSAGE",
    2: "RECEIVE_MESSAGE",
    3: "SEND_RECEIVE_MESSAGE",
    4: "HANDLE_MESSAGE",
    5: "SEND_HANDLE_MESSAGE",
    6: "GET_QUEUE_INFO",
    7: "USE_QUEUE",
    8: "ADMIN_QUEUE",
    9: "FULL_CONTROL",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "SEND_MESSAGE": 1,
    "RECEIVE_MESSAGE": 2,
    "SEND_RECEIVE_MESSAGE": 3,
    "HANDLE_MESSAGE": 4,
    "SEND_HANDLE_MESSAGE": 5,
    "GET_QUEUE_INFO": 6,
    "USE_QUEUE": 7,
    "ADMIN_QUEUE": 8,
    "FULL_CONTROL": 9,
  }


class QueueAttribute(object):
  """
  Copyright 2015, Xiaomi.
  All rights reserved.
  Author: shenyuannan@xiaomi.com

  Attributes:
   - delaySeconds: Queue delay seconds, message send to this queue will invisible until after
  delaySeconds, default 0s (0s ~ 15min)

   - invisibilitySeconds: Queue invisibility seconds, after message received form this queue, in
  invisibilitySeconds this will not received through receiveMessage. When
  after invisibilitySeconds if no deleteMessage called for this message, this
  message will receive again, default 30s (2s ~ 12hour)

   - receiveMessageWaitSeconds: The seconds wait when receiveMessage called, default 0s (0s ~ 20s)

   - receiveMessageMaximumNumber: Maximum receive message number in this queue, default 100(1 ~ 100)

   - messageRetentionSeconds: message retention seconds in this queue, default 4days (60s ~ 14days)

   - messageMaximumBytes: Max message size in this queue, default 256K (1K ~ 256K)

   - partitionNumber: Partition number for this queue default 4 (1 ~ 255)

   - userAttributes: User-defined attributes;

  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'delaySeconds', None, None, ), # 1
    (2, TType.I32, 'invisibilitySeconds', None, None, ), # 2
    (3, TType.I32, 'receiveMessageWaitSeconds', None, None, ), # 3
    (4, TType.I32, 'receiveMessageMaximumNumber', None, None, ), # 4
    (5, TType.I32, 'messageRetentionSeconds', None, None, ), # 5
    (6, TType.I32, 'messageMaximumBytes', None, None, ), # 6
    (7, TType.I32, 'partitionNumber', None, None, ), # 7
    (8, TType.MAP, 'userAttributes', (TType.STRING,None,TType.STRING,None), None, ), # 8
  )

  def __init__(self, delaySeconds=None, invisibilitySeconds=None, receiveMessageWaitSeconds=None, receiveMessageMaximumNumber=None, messageRetentionSeconds=None, messageMaximumBytes=None, partitionNumber=None, userAttributes=None,):
    self.delaySeconds = delaySeconds
    self.invisibilitySeconds = invisibilitySeconds
    self.receiveMessageWaitSeconds = receiveMessageWaitSeconds
    self.receiveMessageMaximumNumber = receiveMessageMaximumNumber
    self.messageRetentionSeconds = messageRetentionSeconds
    self.messageMaximumBytes = messageMaximumBytes
    self.partitionNumber = partitionNumber
    self.userAttributes = userAttributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.delaySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.receiveMessageWaitSeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.receiveMessageMaximumNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.messageRetentionSeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.messageMaximumBytes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.partitionNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.userAttributes = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in range(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readString();
            self.userAttributes[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueueAttribute')
    if self.delaySeconds is not None:
      oprot.writeFieldBegin('delaySeconds', TType.I32, 1)
      oprot.writeI32(self.delaySeconds)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 2)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    if self.receiveMessageWaitSeconds is not None:
      oprot.writeFieldBegin('receiveMessageWaitSeconds', TType.I32, 3)
      oprot.writeI32(self.receiveMessageWaitSeconds)
      oprot.writeFieldEnd()
    if self.receiveMessageMaximumNumber is not None:
      oprot.writeFieldBegin('receiveMessageMaximumNumber', TType.I32, 4)
      oprot.writeI32(self.receiveMessageMaximumNumber)
      oprot.writeFieldEnd()
    if self.messageRetentionSeconds is not None:
      oprot.writeFieldBegin('messageRetentionSeconds', TType.I32, 5)
      oprot.writeI32(self.messageRetentionSeconds)
      oprot.writeFieldEnd()
    if self.messageMaximumBytes is not None:
      oprot.writeFieldBegin('messageMaximumBytes', TType.I32, 6)
      oprot.writeI32(self.messageMaximumBytes)
      oprot.writeFieldEnd()
    if self.partitionNumber is not None:
      oprot.writeFieldBegin('partitionNumber', TType.I32, 7)
      oprot.writeI32(self.partitionNumber)
      oprot.writeFieldEnd()
    if self.userAttributes is not None:
      oprot.writeFieldBegin('userAttributes', TType.MAP, 8)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.userAttributes))
      for kiter7,viter8 in list(self.userAttributes.items()):
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.delaySeconds)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    value = (value * 31) ^ hash(self.receiveMessageWaitSeconds)
    value = (value * 31) ^ hash(self.receiveMessageMaximumNumber)
    value = (value * 31) ^ hash(self.messageRetentionSeconds)
    value = (value * 31) ^ hash(self.messageMaximumBytes)
    value = (value * 31) ^ hash(self.partitionNumber)
    value = (value * 31) ^ hash(self.userAttributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueueState(object):
  """
  Attributes:
   - createTimestamp: Queue create timestamp;

   - lastModifiedTimestamp: Queue last modified timestamp;

   - approximateMessageNumber: The approximate message number in this queue;

   - approximateAvailableMessageNumber: The available message number in this queue, this is for message that could
  be get using receivedMessage

   - approximateInvisibilityMessageNumber: The invisibility message number in this queue, this is for received message
  that in invisibilitySeconds and not deleted;

  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'createTimestamp', None, None, ), # 1
    (2, TType.I64, 'lastModifiedTimestamp', None, None, ), # 2
    (3, TType.I64, 'approximateMessageNumber', None, None, ), # 3
    (4, TType.I64, 'approximateAvailableMessageNumber', None, None, ), # 4
    (5, TType.I64, 'approximateInvisibilityMessageNumber', None, None, ), # 5
  )

  def __init__(self, createTimestamp=None, lastModifiedTimestamp=None, approximateMessageNumber=None, approximateAvailableMessageNumber=None, approximateInvisibilityMessageNumber=None,):
    self.createTimestamp = createTimestamp
    self.lastModifiedTimestamp = lastModifiedTimestamp
    self.approximateMessageNumber = approximateMessageNumber
    self.approximateAvailableMessageNumber = approximateAvailableMessageNumber
    self.approximateInvisibilityMessageNumber = approximateInvisibilityMessageNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.createTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.lastModifiedTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.approximateMessageNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.approximateAvailableMessageNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.approximateInvisibilityMessageNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueueState')
    if self.createTimestamp is not None:
      oprot.writeFieldBegin('createTimestamp', TType.I64, 1)
      oprot.writeI64(self.createTimestamp)
      oprot.writeFieldEnd()
    if self.lastModifiedTimestamp is not None:
      oprot.writeFieldBegin('lastModifiedTimestamp', TType.I64, 2)
      oprot.writeI64(self.lastModifiedTimestamp)
      oprot.writeFieldEnd()
    if self.approximateMessageNumber is not None:
      oprot.writeFieldBegin('approximateMessageNumber', TType.I64, 3)
      oprot.writeI64(self.approximateMessageNumber)
      oprot.writeFieldEnd()
    if self.approximateAvailableMessageNumber is not None:
      oprot.writeFieldBegin('approximateAvailableMessageNumber', TType.I64, 4)
      oprot.writeI64(self.approximateAvailableMessageNumber)
      oprot.writeFieldEnd()
    if self.approximateInvisibilityMessageNumber is not None:
      oprot.writeFieldBegin('approximateInvisibilityMessageNumber', TType.I64, 5)
      oprot.writeI64(self.approximateInvisibilityMessageNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.createTimestamp is None:
      raise TProtocol.TProtocolException(message='Required field createTimestamp is unset!')
    if self.lastModifiedTimestamp is None:
      raise TProtocol.TProtocolException(message='Required field lastModifiedTimestamp is unset!')
    if self.approximateMessageNumber is None:
      raise TProtocol.TProtocolException(message='Required field approximateMessageNumber is unset!')
    if self.approximateAvailableMessageNumber is None:
      raise TProtocol.TProtocolException(message='Required field approximateAvailableMessageNumber is unset!')
    if self.approximateInvisibilityMessageNumber is None:
      raise TProtocol.TProtocolException(message='Required field approximateInvisibilityMessageNumber is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.createTimestamp)
    value = (value * 31) ^ hash(self.lastModifiedTimestamp)
    value = (value * 31) ^ hash(self.approximateMessageNumber)
    value = (value * 31) ^ hash(self.approximateAvailableMessageNumber)
    value = (value * 31) ^ hash(self.approximateInvisibilityMessageNumber)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Throughput(object):
  """
  Attributes:
   - readQps: Queue read qps;

   - writeQps: Queue write qps;

  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'readQps', None, None, ), # 1
    (2, TType.I64, 'writeQps', None, None, ), # 2
  )

  def __init__(self, readQps=None, writeQps=None,):
    self.readQps = readQps
    self.writeQps = writeQps

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.readQps = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.writeQps = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Throughput')
    if self.readQps is not None:
      oprot.writeFieldBegin('readQps', TType.I64, 1)
      oprot.writeI64(self.readQps)
      oprot.writeFieldEnd()
    if self.writeQps is not None:
      oprot.writeFieldBegin('writeQps', TType.I64, 2)
      oprot.writeI64(self.writeQps)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.readQps)
    value = (value * 31) ^ hash(self.writeQps)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueueQuota(object):
  """
  Attributes:
   - throughput: Queue read and qps;

  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRUCT, 'throughput', (Throughput, Throughput.thrift_spec), None, ), # 2
  )

  def __init__(self, throughput=None,):
    self.throughput = throughput

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRUCT:
          self.throughput = Throughput()
          self.throughput.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueueQuota')
    if self.throughput is not None:
      oprot.writeFieldBegin('throughput', TType.STRUCT, 2)
      self.throughput.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.throughput)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateQueueRequest(object):
  """
  Attributes:
   - queueName: The queue name;

   - queueAttribute: The queue attribute;

   - queueQuota: The queue quota, including space quota, read qps, and write qps;

   - deadLetterQueue: Set the queue be a dead letter queue or not;

   - enablePriority: Set the queue using priority of not;

   - topicQueue: Set the queue be a topic queue or not;
  All messages with the same topic in topic queue will be received one by one
  Default: false

   - deleteMessageForce: Purge expired messages even if they have not been received by users
  Default: true

   - defaultTagName: Name default tag
  You can use "" as default tag name while receiving messages if this field is not set

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'queueQuota', (QueueQuota, QueueQuota.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'deadLetterQueue', None, None, ), # 4
    (5, TType.BOOL, 'enablePriority', None, None, ), # 5
    (6, TType.BOOL, 'topicQueue', None, None, ), # 6
    (7, TType.BOOL, 'deleteMessageForce', None, True, ), # 7
    (8, TType.STRING, 'defaultTagName', None, None, ), # 8
  )

  def __init__(self, queueName=None, queueAttribute=None, queueQuota=None, deadLetterQueue=None, enablePriority=None, topicQueue=None, deleteMessageForce=thrift_spec[7][4], defaultTagName=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute
    self.queueQuota = queueQuota
    self.deadLetterQueue = deadLetterQueue
    self.enablePriority = enablePriority
    self.topicQueue = topicQueue
    self.deleteMessageForce = deleteMessageForce
    self.defaultTagName = defaultTagName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.queueQuota = QueueQuota()
          self.queueQuota.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deadLetterQueue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.enablePriority = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.topicQueue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.deleteMessageForce = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.defaultTagName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateQueueRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    if self.queueQuota is not None:
      oprot.writeFieldBegin('queueQuota', TType.STRUCT, 3)
      self.queueQuota.write(oprot)
      oprot.writeFieldEnd()
    if self.deadLetterQueue is not None:
      oprot.writeFieldBegin('deadLetterQueue', TType.BOOL, 4)
      oprot.writeBool(self.deadLetterQueue)
      oprot.writeFieldEnd()
    if self.enablePriority is not None:
      oprot.writeFieldBegin('enablePriority', TType.BOOL, 5)
      oprot.writeBool(self.enablePriority)
      oprot.writeFieldEnd()
    if self.topicQueue is not None:
      oprot.writeFieldBegin('topicQueue', TType.BOOL, 6)
      oprot.writeBool(self.topicQueue)
      oprot.writeFieldEnd()
    if self.deleteMessageForce is not None:
      oprot.writeFieldBegin('deleteMessageForce', TType.BOOL, 7)
      oprot.writeBool(self.deleteMessageForce)
      oprot.writeFieldEnd()
    if self.defaultTagName is not None:
      oprot.writeFieldBegin('defaultTagName', TType.STRING, 8)
      oprot.writeString(self.defaultTagName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    value = (value * 31) ^ hash(self.queueQuota)
    value = (value * 31) ^ hash(self.deadLetterQueue)
    value = (value * 31) ^ hash(self.enablePriority)
    value = (value * 31) ^ hash(self.topicQueue)
    value = (value * 31) ^ hash(self.deleteMessageForce)
    value = (value * 31) ^ hash(self.defaultTagName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateQueueResponse(object):
  """
  Attributes:
   - queueName: The queue name;
  The name returned here may be a little different from user set in request (with developerId as prefix).
  So the user should use the name returned by this response for those following operations

   - queueAttribute: The queue attribute;

   - queueQuota: The queue quota;

   - deadLetterQueue: The queue is a dead letter queue or not;

   - enablePriority: The queue is using priority of not;

   - topicQueue: Set the queue be a topic queue or not;

   - deleteMessageForce: Purge expired messages even if they have not been received by users

   - defaultTagName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'queueQuota', (QueueQuota, QueueQuota.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'deadLetterQueue', None, None, ), # 4
    (5, TType.BOOL, 'enablePriority', None, None, ), # 5
    (6, TType.BOOL, 'topicQueue', None, None, ), # 6
    (7, TType.BOOL, 'deleteMessageForce', None, None, ), # 7
    (8, TType.STRING, 'defaultTagName', None, None, ), # 8
  )

  def __init__(self, queueName=None, queueAttribute=None, queueQuota=None, deadLetterQueue=None, enablePriority=None, topicQueue=None, deleteMessageForce=None, defaultTagName=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute
    self.queueQuota = queueQuota
    self.deadLetterQueue = deadLetterQueue
    self.enablePriority = enablePriority
    self.topicQueue = topicQueue
    self.deleteMessageForce = deleteMessageForce
    self.defaultTagName = defaultTagName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.queueQuota = QueueQuota()
          self.queueQuota.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deadLetterQueue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.enablePriority = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.topicQueue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.deleteMessageForce = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.defaultTagName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateQueueResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    if self.queueQuota is not None:
      oprot.writeFieldBegin('queueQuota', TType.STRUCT, 3)
      self.queueQuota.write(oprot)
      oprot.writeFieldEnd()
    if self.deadLetterQueue is not None:
      oprot.writeFieldBegin('deadLetterQueue', TType.BOOL, 4)
      oprot.writeBool(self.deadLetterQueue)
      oprot.writeFieldEnd()
    if self.enablePriority is not None:
      oprot.writeFieldBegin('enablePriority', TType.BOOL, 5)
      oprot.writeBool(self.enablePriority)
      oprot.writeFieldEnd()
    if self.topicQueue is not None:
      oprot.writeFieldBegin('topicQueue', TType.BOOL, 6)
      oprot.writeBool(self.topicQueue)
      oprot.writeFieldEnd()
    if self.deleteMessageForce is not None:
      oprot.writeFieldBegin('deleteMessageForce', TType.BOOL, 7)
      oprot.writeBool(self.deleteMessageForce)
      oprot.writeFieldEnd()
    if self.defaultTagName is not None:
      oprot.writeFieldBegin('defaultTagName', TType.STRING, 8)
      oprot.writeString(self.defaultTagName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.queueAttribute is None:
      raise TProtocol.TProtocolException(message='Required field queueAttribute is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    value = (value * 31) ^ hash(self.queueQuota)
    value = (value * 31) ^ hash(self.deadLetterQueue)
    value = (value * 31) ^ hash(self.enablePriority)
    value = (value * 31) ^ hash(self.topicQueue)
    value = (value * 31) ^ hash(self.deleteMessageForce)
    value = (value * 31) ^ hash(self.defaultTagName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteQueueRequest(object):
  """
  Attributes:
   - queueName: The queue name;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteQueueRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PurgeQueueRequest(object):
  """
  Attributes:
   - queueName: The queue name;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PurgeQueueRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetQueueAttributesRequest(object):
  """
  Attributes:
   - queueName: The queue name;

   - queueAttribute: The queue attribute;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, queueAttribute=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetQueueAttributesRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetQueueAttributesResponse(object):
  """
  Attributes:
   - queueName: The queue name;

   - queueAttribute: The queue attribute;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, queueAttribute=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetQueueAttributesResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.queueAttribute is None:
      raise TProtocol.TProtocolException(message='Required field queueAttribute is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetQueueQuotaRequest(object):
  """
  Attributes:
   - queueName: The queue name;

   - queueQuota: The queue quota;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueQuota', (QueueQuota, QueueQuota.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, queueQuota=None,):
    self.queueName = queueName
    self.queueQuota = queueQuota

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueQuota = QueueQuota()
          self.queueQuota.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetQueueQuotaRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueQuota is not None:
      oprot.writeFieldBegin('queueQuota', TType.STRUCT, 2)
      self.queueQuota.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueQuota)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetQueueQuotaResponse(object):
  """
  Attributes:
   - queueName: The queue name;

   - queueQuota: The queue quota;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueQuota', (QueueQuota, QueueQuota.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, queueQuota=None,):
    self.queueName = queueName
    self.queueQuota = queueQuota

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueQuota = QueueQuota()
          self.queueQuota.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetQueueQuotaResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueQuota is not None:
      oprot.writeFieldBegin('queueQuota', TType.STRUCT, 2)
      self.queueQuota.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueQuota)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RedrivePolicy(object):
  """
  Attributes:
   - dlqName: The dead letter queue name;

   - maxReceiveTime: The max receive time;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dlqName', None, None, ), # 1
    (2, TType.I32, 'maxReceiveTime', None, None, ), # 2
  )

  def __init__(self, dlqName=None, maxReceiveTime=None,):
    self.dlqName = dlqName
    self.maxReceiveTime = maxReceiveTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dlqName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxReceiveTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RedrivePolicy')
    if self.dlqName is not None:
      oprot.writeFieldBegin('dlqName', TType.STRING, 1)
      oprot.writeString(self.dlqName)
      oprot.writeFieldEnd()
    if self.maxReceiveTime is not None:
      oprot.writeFieldBegin('maxReceiveTime', TType.I32, 2)
      oprot.writeI32(self.maxReceiveTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dlqName is None:
      raise TProtocol.TProtocolException(message='Required field dlqName is unset!')
    if self.maxReceiveTime is None:
      raise TProtocol.TProtocolException(message='Required field maxReceiveTime is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dlqName)
    value = (value * 31) ^ hash(self.maxReceiveTime)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetQueueInfoRequest(object):
  """
  Attributes:
   - queueName: The queue name;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetQueueInfoRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetQueueInfoResponse(object):
  """
  Attributes:
   - queueName: The queue name;

   - queueAttribute: The queue attribute;

   - queueState: The queue state;

   - queueQuota: The queue quota;

   - isDeadLetterQueue: Whether the queue is a dead letter queue;

   - redrivePolicy: The queue redrive policy, dead letter queue doesn't have redrive policy;

   - enablePriority: The queue using priority of not;

   - topicQueue: Set the queue be a topic queue or not;

   - deleteMessageForce: Purge expired messages even if they have not been received by users

   - defaultTagName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'queueState', (QueueState, QueueState.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'queueQuota', (QueueQuota, QueueQuota.thrift_spec), None, ), # 4
    (5, TType.BOOL, 'isDeadLetterQueue', None, None, ), # 5
    (6, TType.STRUCT, 'redrivePolicy', (RedrivePolicy, RedrivePolicy.thrift_spec), None, ), # 6
    (7, TType.BOOL, 'enablePriority', None, None, ), # 7
    (8, TType.BOOL, 'topicQueue', None, None, ), # 8
    (9, TType.BOOL, 'deleteMessageForce', None, None, ), # 9
    (10, TType.STRING, 'defaultTagName', None, None, ), # 10
  )

  def __init__(self, queueName=None, queueAttribute=None, queueState=None, queueQuota=None, isDeadLetterQueue=None, redrivePolicy=None, enablePriority=None, topicQueue=None, deleteMessageForce=None, defaultTagName=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute
    self.queueState = queueState
    self.queueQuota = queueQuota
    self.isDeadLetterQueue = isDeadLetterQueue
    self.redrivePolicy = redrivePolicy
    self.enablePriority = enablePriority
    self.topicQueue = topicQueue
    self.deleteMessageForce = deleteMessageForce
    self.defaultTagName = defaultTagName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.queueState = QueueState()
          self.queueState.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.queueQuota = QueueQuota()
          self.queueQuota.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isDeadLetterQueue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.redrivePolicy = RedrivePolicy()
          self.redrivePolicy.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.enablePriority = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.topicQueue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.deleteMessageForce = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.defaultTagName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetQueueInfoResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    if self.queueState is not None:
      oprot.writeFieldBegin('queueState', TType.STRUCT, 3)
      self.queueState.write(oprot)
      oprot.writeFieldEnd()
    if self.queueQuota is not None:
      oprot.writeFieldBegin('queueQuota', TType.STRUCT, 4)
      self.queueQuota.write(oprot)
      oprot.writeFieldEnd()
    if self.isDeadLetterQueue is not None:
      oprot.writeFieldBegin('isDeadLetterQueue', TType.BOOL, 5)
      oprot.writeBool(self.isDeadLetterQueue)
      oprot.writeFieldEnd()
    if self.redrivePolicy is not None:
      oprot.writeFieldBegin('redrivePolicy', TType.STRUCT, 6)
      self.redrivePolicy.write(oprot)
      oprot.writeFieldEnd()
    if self.enablePriority is not None:
      oprot.writeFieldBegin('enablePriority', TType.BOOL, 7)
      oprot.writeBool(self.enablePriority)
      oprot.writeFieldEnd()
    if self.topicQueue is not None:
      oprot.writeFieldBegin('topicQueue', TType.BOOL, 8)
      oprot.writeBool(self.topicQueue)
      oprot.writeFieldEnd()
    if self.deleteMessageForce is not None:
      oprot.writeFieldBegin('deleteMessageForce', TType.BOOL, 9)
      oprot.writeBool(self.deleteMessageForce)
      oprot.writeFieldEnd()
    if self.defaultTagName is not None:
      oprot.writeFieldBegin('defaultTagName', TType.STRING, 10)
      oprot.writeString(self.defaultTagName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.queueAttribute is None:
      raise TProtocol.TProtocolException(message='Required field queueAttribute is unset!')
    if self.queueState is None:
      raise TProtocol.TProtocolException(message='Required field queueState is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    value = (value * 31) ^ hash(self.queueState)
    value = (value * 31) ^ hash(self.queueQuota)
    value = (value * 31) ^ hash(self.isDeadLetterQueue)
    value = (value * 31) ^ hash(self.redrivePolicy)
    value = (value * 31) ^ hash(self.enablePriority)
    value = (value * 31) ^ hash(self.topicQueue)
    value = (value * 31) ^ hash(self.deleteMessageForce)
    value = (value * 31) ^ hash(self.defaultTagName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetQueueRedrivePolicyRequest(object):
  """
  Attributes:
   - queueName
   - redrivePolicy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'redrivePolicy', (RedrivePolicy, RedrivePolicy.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, redrivePolicy=None,):
    self.queueName = queueName
    self.redrivePolicy = redrivePolicy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.redrivePolicy = RedrivePolicy()
          self.redrivePolicy.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetQueueRedrivePolicyRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.redrivePolicy is not None:
      oprot.writeFieldBegin('redrivePolicy', TType.STRUCT, 2)
      self.redrivePolicy.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.redrivePolicy is None:
      raise TProtocol.TProtocolException(message='Required field redrivePolicy is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.redrivePolicy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetQueueRedrivePolicyResponse(object):
  """
  Attributes:
   - queueName
   - redrivePolicy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'redrivePolicy', (RedrivePolicy, RedrivePolicy.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, redrivePolicy=None,):
    self.queueName = queueName
    self.redrivePolicy = redrivePolicy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.redrivePolicy = RedrivePolicy()
          self.redrivePolicy.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetQueueRedrivePolicyResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.redrivePolicy is not None:
      oprot.writeFieldBegin('redrivePolicy', TType.STRUCT, 2)
      self.redrivePolicy.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.redrivePolicy is None:
      raise TProtocol.TProtocolException(message='Required field redrivePolicy is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.redrivePolicy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveQueueRedrivePolicyRequest(object):
  """
  Attributes:
   - queueName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveQueueRedrivePolicyRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListDeadLetterSourceQueuesRequest(object):
  """
  Attributes:
   - dlqName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dlqName', None, None, ), # 1
  )

  def __init__(self, dlqName=None,):
    self.dlqName = dlqName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dlqName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListDeadLetterSourceQueuesRequest')
    if self.dlqName is not None:
      oprot.writeFieldBegin('dlqName', TType.STRING, 1)
      oprot.writeString(self.dlqName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dlqName is None:
      raise TProtocol.TProtocolException(message='Required field dlqName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dlqName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListDeadLetterSourceQueuesResponse(object):
  """
  Attributes:
   - dlqName: The dead letter queue name;

   - sourceQueues: The source queues, only a dead letter queue has source queues;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dlqName', None, None, ), # 1
    (2, TType.LIST, 'sourceQueues', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, dlqName=None, sourceQueues=None,):
    self.dlqName = dlqName
    self.sourceQueues = sourceQueues

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dlqName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sourceQueues = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in range(_size9):
            _elem14 = iprot.readString();
            self.sourceQueues.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListDeadLetterSourceQueuesResponse')
    if self.dlqName is not None:
      oprot.writeFieldBegin('dlqName', TType.STRING, 1)
      oprot.writeString(self.dlqName)
      oprot.writeFieldEnd()
    if self.sourceQueues is not None:
      oprot.writeFieldBegin('sourceQueues', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.sourceQueues))
      for iter15 in self.sourceQueues:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dlqName is None:
      raise TProtocol.TProtocolException(message='Required field dlqName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dlqName)
    value = (value * 31) ^ hash(self.sourceQueues)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListQueueRequest(object):
  """
  Attributes:
   - queueNamePrefix: The queue name prefix;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueNamePrefix', None, "", ), # 1
  )

  def __init__(self, queueNamePrefix=thrift_spec[1][4],):
    self.queueNamePrefix = queueNamePrefix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueNamePrefix = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListQueueRequest')
    if self.queueNamePrefix is not None:
      oprot.writeFieldBegin('queueNamePrefix', TType.STRING, 1)
      oprot.writeString(self.queueNamePrefix)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueNamePrefix)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListQueueResponse(object):
  """
  Attributes:
   - queueName: The queueName list with queueNamePrefix;

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'queueName', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.queueName = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in range(_size16):
            _elem21 = iprot.readString();
            self.queueName.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListQueueResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.queueName))
      for iter22 in self.queueName:
        oprot.writeString(iter22)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPermissionRequest(object):
  """
  Attributes:
   - queueName
   - developerId
   - permission
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
    (3, TType.I32, 'permission', None, None, ), # 3
  )

  def __init__(self, queueName=None, developerId=None, permission=None,):
    self.queueName = queueName
    self.developerId = developerId
    self.permission = permission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.permission = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPermissionRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    if self.permission is not None:
      oprot.writeFieldBegin('permission', TType.I32, 3)
      oprot.writeI32(self.permission)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.developerId is None:
      raise TProtocol.TProtocolException(message='Required field developerId is unset!')
    if self.permission is None:
      raise TProtocol.TProtocolException(message='Required field permission is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.developerId)
    value = (value * 31) ^ hash(self.permission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RevokePermissionRequest(object):
  """
  Attributes:
   - queueName
   - developerId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
  )

  def __init__(self, queueName=None, developerId=None,):
    self.queueName = queueName
    self.developerId = developerId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RevokePermissionRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.developerId is None:
      raise TProtocol.TProtocolException(message='Required field developerId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.developerId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryPermissionRequest(object):
  """
  Attributes:
   - queueName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryPermissionRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryPermissionResponse(object):
  """
  Attributes:
   - permission
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'permission', None, None, ), # 1
  )

  def __init__(self, permission=None,):
    self.permission = permission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.permission = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryPermissionResponse')
    if self.permission is not None:
      oprot.writeFieldBegin('permission', TType.I32, 1)
      oprot.writeI32(self.permission)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.permission is None:
      raise TProtocol.TProtocolException(message='Required field permission is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.permission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryPermissionForIdRequest(object):
  """
  Attributes:
   - queueName
   - developerId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
  )

  def __init__(self, queueName=None, developerId=None,):
    self.queueName = queueName
    self.developerId = developerId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryPermissionForIdRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.developerId is None:
      raise TProtocol.TProtocolException(message='Required field developerId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.developerId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryPermissionForIdResponse(object):
  """
  Attributes:
   - permission
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'permission', None, None, ), # 1
  )

  def __init__(self, permission=None,):
    self.permission = permission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.permission = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryPermissionForIdResponse')
    if self.permission is not None:
      oprot.writeFieldBegin('permission', TType.I32, 1)
      oprot.writeI32(self.permission)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.permission is None:
      raise TProtocol.TProtocolException(message='Required field permission is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.permission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListPermissionsRequest(object):
  """
  Attributes:
   - queueName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListPermissionsRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListPermissionsResponse(object):
  """
  Attributes:
   - permissionList
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'permissionList', (TType.STRING,None,TType.I32,None), None, ), # 1
  )

  def __init__(self, permissionList=None,):
    self.permissionList = permissionList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.permissionList = {}
          (_ktype24, _vtype25, _size23 ) = iprot.readMapBegin()
          for _i27 in range(_size23):
            _key28 = iprot.readString();
            _val29 = iprot.readI32();
            self.permissionList[_key28] = _val29
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListPermissionsResponse')
    if self.permissionList is not None:
      oprot.writeFieldBegin('permissionList', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.permissionList))
      for kiter30,viter31 in list(self.permissionList.items()):
        oprot.writeString(kiter30)
        oprot.writeI32(viter31)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.permissionList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateTagRequest(object):
  """
  Attributes:
   - queueName
   - tagName
   - startTimestamp
   - readQPSQuota
   - attributeName
   - attributeValue
   - userAttributes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'tagName', None, None, ), # 2
    (3, TType.I64, 'startTimestamp', None, None, ), # 3
    (4, TType.I64, 'readQPSQuota', None, None, ), # 4
    (5, TType.STRING, 'attributeName', None, None, ), # 5
    (6, TType.STRUCT, 'attributeValue', (emq.message.ttypes.MessageAttribute, emq.message.ttypes.MessageAttribute.thrift_spec), None, ), # 6
    (7, TType.MAP, 'userAttributes', (TType.STRING,None,TType.STRING,None), None, ), # 7
  )

  def __init__(self, queueName=None, tagName=None, startTimestamp=None, readQPSQuota=None, attributeName=None, attributeValue=None, userAttributes=None,):
    self.queueName = queueName
    self.tagName = tagName
    self.startTimestamp = startTimestamp
    self.readQPSQuota = readQPSQuota
    self.attributeName = attributeName
    self.attributeValue = attributeValue
    self.userAttributes = userAttributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tagName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.startTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.readQPSQuota = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.attributeName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.attributeValue = emq.message.ttypes.MessageAttribute()
          self.attributeValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.userAttributes = {}
          (_ktype33, _vtype34, _size32 ) = iprot.readMapBegin()
          for _i36 in range(_size32):
            _key37 = iprot.readString();
            _val38 = iprot.readString();
            self.userAttributes[_key37] = _val38
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateTagRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.tagName is not None:
      oprot.writeFieldBegin('tagName', TType.STRING, 2)
      oprot.writeString(self.tagName)
      oprot.writeFieldEnd()
    if self.startTimestamp is not None:
      oprot.writeFieldBegin('startTimestamp', TType.I64, 3)
      oprot.writeI64(self.startTimestamp)
      oprot.writeFieldEnd()
    if self.readQPSQuota is not None:
      oprot.writeFieldBegin('readQPSQuota', TType.I64, 4)
      oprot.writeI64(self.readQPSQuota)
      oprot.writeFieldEnd()
    if self.attributeName is not None:
      oprot.writeFieldBegin('attributeName', TType.STRING, 5)
      oprot.writeString(self.attributeName)
      oprot.writeFieldEnd()
    if self.attributeValue is not None:
      oprot.writeFieldBegin('attributeValue', TType.STRUCT, 6)
      self.attributeValue.write(oprot)
      oprot.writeFieldEnd()
    if self.userAttributes is not None:
      oprot.writeFieldBegin('userAttributes', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.userAttributes))
      for kiter39,viter40 in list(self.userAttributes.items()):
        oprot.writeString(kiter39)
        oprot.writeString(viter40)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.tagName is None:
      raise TProtocol.TProtocolException(message='Required field tagName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.tagName)
    value = (value * 31) ^ hash(self.startTimestamp)
    value = (value * 31) ^ hash(self.readQPSQuota)
    value = (value * 31) ^ hash(self.attributeName)
    value = (value * 31) ^ hash(self.attributeValue)
    value = (value * 31) ^ hash(self.userAttributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateTagResponse(object):
  """
  Attributes:
   - queueName
   - tagName
   - startTimestamp
   - readQPSQuota
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'tagName', None, None, ), # 2
    (3, TType.I64, 'startTimestamp', None, None, ), # 3
    (4, TType.I64, 'readQPSQuota', None, None, ), # 4
  )

  def __init__(self, queueName=None, tagName=None, startTimestamp=None, readQPSQuota=None,):
    self.queueName = queueName
    self.tagName = tagName
    self.startTimestamp = startTimestamp
    self.readQPSQuota = readQPSQuota

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tagName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.startTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.readQPSQuota = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateTagResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.tagName is not None:
      oprot.writeFieldBegin('tagName', TType.STRING, 2)
      oprot.writeString(self.tagName)
      oprot.writeFieldEnd()
    if self.startTimestamp is not None:
      oprot.writeFieldBegin('startTimestamp', TType.I64, 3)
      oprot.writeI64(self.startTimestamp)
      oprot.writeFieldEnd()
    if self.readQPSQuota is not None:
      oprot.writeFieldBegin('readQPSQuota', TType.I64, 4)
      oprot.writeI64(self.readQPSQuota)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.tagName is None:
      raise TProtocol.TProtocolException(message='Required field tagName is unset!')
    if self.startTimestamp is None:
      raise TProtocol.TProtocolException(message='Required field startTimestamp is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.tagName)
    value = (value * 31) ^ hash(self.startTimestamp)
    value = (value * 31) ^ hash(self.readQPSQuota)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteTagRequest(object):
  """
  Attributes:
   - queueName
   - tagName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'tagName', None, None, ), # 2
  )

  def __init__(self, queueName=None, tagName=None,):
    self.queueName = queueName
    self.tagName = tagName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tagName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteTagRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.tagName is not None:
      oprot.writeFieldBegin('tagName', TType.STRING, 2)
      oprot.writeString(self.tagName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.tagName is None:
      raise TProtocol.TProtocolException(message='Required field tagName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.tagName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTagInfoRequest(object):
  """
  Attributes:
   - queueName
   - tagName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'tagName', None, None, ), # 2
  )

  def __init__(self, queueName=None, tagName=None,):
    self.queueName = queueName
    self.tagName = tagName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tagName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTagInfoRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.tagName is not None:
      oprot.writeFieldBegin('tagName', TType.STRING, 2)
      oprot.writeString(self.tagName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.tagName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTagInfoResponse(object):
  """
  Attributes:
   - queueName
   - tagName
   - tagState
   - startTimestamp
   - readQPSQuota
   - attributeName
   - attributeValue
   - userAttributes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'tagName', None, None, ), # 2
    (3, TType.STRUCT, 'tagState', (QueueState, QueueState.thrift_spec), None, ), # 3
    (4, TType.I64, 'startTimestamp', None, None, ), # 4
    (5, TType.I64, 'readQPSQuota', None, None, ), # 5
    (6, TType.STRING, 'attributeName', None, None, ), # 6
    (7, TType.STRUCT, 'attributeValue', (emq.message.ttypes.MessageAttribute, emq.message.ttypes.MessageAttribute.thrift_spec), None, ), # 7
    (8, TType.MAP, 'userAttributes', (TType.STRING,None,TType.STRING,None), None, ), # 8
  )

  def __init__(self, queueName=None, tagName=None, tagState=None, startTimestamp=None, readQPSQuota=None, attributeName=None, attributeValue=None, userAttributes=None,):
    self.queueName = queueName
    self.tagName = tagName
    self.tagState = tagState
    self.startTimestamp = startTimestamp
    self.readQPSQuota = readQPSQuota
    self.attributeName = attributeName
    self.attributeValue = attributeValue
    self.userAttributes = userAttributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tagName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.tagState = QueueState()
          self.tagState.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.startTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.readQPSQuota = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.attributeName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.attributeValue = emq.message.ttypes.MessageAttribute()
          self.attributeValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.userAttributes = {}
          (_ktype42, _vtype43, _size41 ) = iprot.readMapBegin()
          for _i45 in range(_size41):
            _key46 = iprot.readString();
            _val47 = iprot.readString();
            self.userAttributes[_key46] = _val47
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTagInfoResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.tagName is not None:
      oprot.writeFieldBegin('tagName', TType.STRING, 2)
      oprot.writeString(self.tagName)
      oprot.writeFieldEnd()
    if self.tagState is not None:
      oprot.writeFieldBegin('tagState', TType.STRUCT, 3)
      self.tagState.write(oprot)
      oprot.writeFieldEnd()
    if self.startTimestamp is not None:
      oprot.writeFieldBegin('startTimestamp', TType.I64, 4)
      oprot.writeI64(self.startTimestamp)
      oprot.writeFieldEnd()
    if self.readQPSQuota is not None:
      oprot.writeFieldBegin('readQPSQuota', TType.I64, 5)
      oprot.writeI64(self.readQPSQuota)
      oprot.writeFieldEnd()
    if self.attributeName is not None:
      oprot.writeFieldBegin('attributeName', TType.STRING, 6)
      oprot.writeString(self.attributeName)
      oprot.writeFieldEnd()
    if self.attributeValue is not None:
      oprot.writeFieldBegin('attributeValue', TType.STRUCT, 7)
      self.attributeValue.write(oprot)
      oprot.writeFieldEnd()
    if self.userAttributes is not None:
      oprot.writeFieldBegin('userAttributes', TType.MAP, 8)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.userAttributes))
      for kiter48,viter49 in list(self.userAttributes.items()):
        oprot.writeString(kiter48)
        oprot.writeString(viter49)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.tagState is None:
      raise TProtocol.TProtocolException(message='Required field tagState is unset!')
    if self.startTimestamp is None:
      raise TProtocol.TProtocolException(message='Required field startTimestamp is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.tagName)
    value = (value * 31) ^ hash(self.tagState)
    value = (value * 31) ^ hash(self.startTimestamp)
    value = (value * 31) ^ hash(self.readQPSQuota)
    value = (value * 31) ^ hash(self.attributeName)
    value = (value * 31) ^ hash(self.attributeValue)
    value = (value * 31) ^ hash(self.userAttributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTagRequest(object):
  """
  Attributes:
   - queueName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTagRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTagResponse(object):
  """
  Attributes:
   - queueName
   - tagName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.LIST, 'tagName', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, queueName=None, tagName=None,):
    self.queueName = queueName
    self.tagName = tagName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tagName = []
          (_etype53, _size50) = iprot.readListBegin()
          for _i54 in range(_size50):
            _elem55 = iprot.readString();
            self.tagName.append(_elem55)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTagResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.tagName is not None:
      oprot.writeFieldBegin('tagName', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tagName))
      for iter56 in self.tagName:
        oprot.writeString(iter56)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.tagName is None:
      raise TProtocol.TProtocolException(message='Required field tagName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.tagName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryMetricRequest(object):
  """
  Attributes:
   - queueName
   - startTime
   - endTime
   - metrics: metric name

   - tags: tags, reference to opentsdb,
  e.g. <"type", "">

   - aggregator: data aggregator, reference to opentsdb,
  e.g. max, avg, min

   - downsampleAggregator: similar to aggregator above

   - downsampleInterval
   - downsampleTimeUnit: downsample interval unit, reference to opentsdb,
  e.g. ms(milliseconds), s(seconds), d(day)

   - calRate
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.I64, 'startTime', None, None, ), # 2
    (3, TType.I64, 'endTime', None, None, ), # 3
    (4, TType.STRING, 'metrics', None, None, ), # 4
    (5, TType.MAP, 'tags', (TType.STRING,None,TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'aggregator', None, None, ), # 6
    (7, TType.STRING, 'downsampleAggregator', None, None, ), # 7
    (8, TType.I32, 'downsampleInterval', None, None, ), # 8
    (9, TType.STRING, 'downsampleTimeUnit', None, None, ), # 9
    (10, TType.BOOL, 'calRate', None, None, ), # 10
  )

  def __init__(self, queueName=None, startTime=None, endTime=None, metrics=None, tags=None, aggregator=None, downsampleAggregator=None, downsampleInterval=None, downsampleTimeUnit=None, calRate=None,):
    self.queueName = queueName
    self.startTime = startTime
    self.endTime = endTime
    self.metrics = metrics
    self.tags = tags
    self.aggregator = aggregator
    self.downsampleAggregator = downsampleAggregator
    self.downsampleInterval = downsampleInterval
    self.downsampleTimeUnit = downsampleTimeUnit
    self.calRate = calRate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.startTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.endTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.metrics = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.tags = {}
          (_ktype58, _vtype59, _size57 ) = iprot.readMapBegin()
          for _i61 in range(_size57):
            _key62 = iprot.readString();
            _val63 = iprot.readString();
            self.tags[_key62] = _val63
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.aggregator = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.downsampleAggregator = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.downsampleInterval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.downsampleTimeUnit = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.calRate = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryMetricRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 2)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.I64, 3)
      oprot.writeI64(self.endTime)
      oprot.writeFieldEnd()
    if self.metrics is not None:
      oprot.writeFieldBegin('metrics', TType.STRING, 4)
      oprot.writeString(self.metrics)
      oprot.writeFieldEnd()
    if self.tags is not None:
      oprot.writeFieldBegin('tags', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tags))
      for kiter64,viter65 in list(self.tags.items()):
        oprot.writeString(kiter64)
        oprot.writeString(viter65)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.aggregator is not None:
      oprot.writeFieldBegin('aggregator', TType.STRING, 6)
      oprot.writeString(self.aggregator)
      oprot.writeFieldEnd()
    if self.downsampleAggregator is not None:
      oprot.writeFieldBegin('downsampleAggregator', TType.STRING, 7)
      oprot.writeString(self.downsampleAggregator)
      oprot.writeFieldEnd()
    if self.downsampleInterval is not None:
      oprot.writeFieldBegin('downsampleInterval', TType.I32, 8)
      oprot.writeI32(self.downsampleInterval)
      oprot.writeFieldEnd()
    if self.downsampleTimeUnit is not None:
      oprot.writeFieldBegin('downsampleTimeUnit', TType.STRING, 9)
      oprot.writeString(self.downsampleTimeUnit)
      oprot.writeFieldEnd()
    if self.calRate is not None:
      oprot.writeFieldBegin('calRate', TType.BOOL, 10)
      oprot.writeBool(self.calRate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.startTime)
    value = (value * 31) ^ hash(self.endTime)
    value = (value * 31) ^ hash(self.metrics)
    value = (value * 31) ^ hash(self.tags)
    value = (value * 31) ^ hash(self.aggregator)
    value = (value * 31) ^ hash(self.downsampleAggregator)
    value = (value * 31) ^ hash(self.downsampleInterval)
    value = (value * 31) ^ hash(self.downsampleTimeUnit)
    value = (value * 31) ^ hash(self.calRate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimeSeriesData(object):
  """
  metrics time series data

  Attributes:
   - metric: metric name
   - tags: tags
   - data: data, {timestamp => value}
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'metric', None, None, ), # 1
    (2, TType.MAP, 'tags', (TType.STRING,None,TType.STRING,None), None, ), # 2
    (3, TType.MAP, 'data', (TType.I64,None,TType.DOUBLE,None), None, ), # 3
  )

  def __init__(self, metric=None, tags=None, data=None,):
    self.metric = metric
    self.tags = tags
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.metric = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.tags = {}
          (_ktype67, _vtype68, _size66 ) = iprot.readMapBegin()
          for _i70 in range(_size66):
            _key71 = iprot.readString();
            _val72 = iprot.readString();
            self.tags[_key71] = _val72
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.data = {}
          (_ktype74, _vtype75, _size73 ) = iprot.readMapBegin()
          for _i77 in range(_size73):
            _key78 = iprot.readI64();
            _val79 = iprot.readDouble();
            self.data[_key78] = _val79
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimeSeriesData')
    if self.metric is not None:
      oprot.writeFieldBegin('metric', TType.STRING, 1)
      oprot.writeString(self.metric)
      oprot.writeFieldEnd()
    if self.tags is not None:
      oprot.writeFieldBegin('tags', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tags))
      for kiter80,viter81 in list(self.tags.items()):
        oprot.writeString(kiter80)
        oprot.writeString(viter81)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.MAP, 3)
      oprot.writeMapBegin(TType.I64, TType.DOUBLE, len(self.data))
      for kiter82,viter83 in list(self.data.items()):
        oprot.writeI64(kiter82)
        oprot.writeDouble(viter83)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metric)
    value = (value * 31) ^ hash(self.tags)
    value = (value * 31) ^ hash(self.data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
