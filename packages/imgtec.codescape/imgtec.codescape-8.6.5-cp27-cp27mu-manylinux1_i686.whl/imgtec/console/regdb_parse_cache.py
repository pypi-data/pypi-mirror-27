from imgtec.console.regdb_types import *
conditions={'CPC_PRESENT_AND_ENABLED': And(Op('==', Reg('Config3::CMGCR'), 1), Op('==', Reg('GCR_CPC_STATUS::CPC_EX'), 1), Op('==', Reg('GCR_CPC_BASE::CPC_EN'), 1)),
 'FDC_PRESENT': And(Op('==', Reg('Config3::CDMM'), 1), Op('==', Reg('CDMMBase::EN'), 1)),
 'FPU_Present': Op('==', Reg('Config1::FP'), 1),
 'GIC_PRESENT_AND_ENABLED': And(Op('==', Reg('Config3::CMGCR'), 1), Op('==', Reg('GCR_GIC_STATUS::GIC_EX'), 1), Op('==', Reg('GCR_GIC_BASE::GIC_EN'), 1)),
 'Has_DSP': Op('==', Reg('Config3::DSPP'), 1),
 'Has_ITagLo_DTagLo': Or(CPUNameMatches('20Kc'), CPUNameMatches('24K.*'), CPUNameMatches('1004K.*'), CPUNameMatches('74K.*'), CPUNameMatches('34K.*'), CPUNameMatches('InterAptiv.*'), CPUNameMatches('1074K.*'), CPUNameMatches('ProAptiv.*'), CPUNameMatches('P5600.*')),
 'Has_ITagLo_Only': Not(CPUNameMatches('M4K.*, M14K.*, M51[05]0')),
 'Has_L2_Registers': Or(Op('gt', Reg('Config2::SL'), 0), CPUNameMatches('24K.*'), CPUNameMatches('1004K.*'), CPUNameMatches('34K.*'), CPUNameMatches('74K.*'), CPUNameMatches('1074K.*')),
 'Has_SmartMIPS': Op('==', Reg('Config3::SM'), 1),
 'IF_Ver2': And(Op('==', Condition('IFlowtrace'), True), Op('==', Condition('IF_Ver3'), False), False),
 'IF_Ver3': And(Op('==', Condition('IFlowtrace'), True), Op('==', Reg('0xff303fc0 and 0x00010000'), 65536)),
 'IFlowtrace': Op('==', Reg('Config3::ITL'), 1),
 'PDtrace': And(Op('==', Reg('Config3::TL'), 1)),
 'Trace_BPCProcessor': CPUNameMatches('4KE.*'),
 'VPEScheduling': And(Op('==', Reg('Config3::MT'), 1), CPUNameMatches('1004K.*, 34K.*, InterAptiv.*')),
 'WatchLoX64Cores': Or(CPUNameMatches('I6[45]00.*'), CPUNameMatches('P6600.*')),
 'ejtag_present': And(Op('==', Reg('Config1::EP'), 1), Op('==', Condition('oci32_present'), False), Op('==', Condition('oci64_present'), False)),
 'oci32_present': Or(CPUNameMatches('M70\\d\\d.*'), CPUNameMatches('I72\\d\\d.*')),
 'oci64_present': Or(CPUNameMatches('I6400.*'), CPUNameMatches('I6500.*'))}
templates={'32bit_FPU': {'': [Field('Sign', Bits(31), 'Sign Bit'),
                    Field('Exponent', Bits(30, 23), 'Exponent'),
                    Field('Fraction', Bits(22, 0), 'Fraction')]},
 '64bit_FPU': {'': [Field('Sign', Bits(63), 'Sign Bit'),
                    Field('Exponent', Bits(62, 52), 'Exponent'),
                    Field('Fraction', Bits(51, 0), 'Fraction')]},
 'CMD_REG_FIELDS': {'': [Field('Reserved', Bits(31, 4)),
                         Field('CMD', Bits(3, 0), '', [Value('Reserved', 0), Value('ClockOff', 1), Value('PwrDown', 2), Value('PwrUp', 3), Value('Reset', 4)])]},
 'Cx_COHERENCE_FIELDS': {'': [Field('Reserved', Bits(31, 8), 'Reads as 0x0. Writes ignored. Must be written with a value of 0x0.'),
                              Field('COH_DOMAIN_EN', Bits(7, 0), 'Each bit in this field represents a coherent requester within    the CPS. Setting a bit within this field will enable interventions    to this Core from that requester.${p}    The requestor bit which represents the local core is used to    enable or disable coherence mode in the local core.${p}    Changing the coherence mode for a local core from 0x1 to    0x0 can only be done after flushing and invalidating all the    cache lines in the core; otherwise, the system behavior is    UNDEFINED.')]},
 'Cx_CONFIG_FIELDS': {'': [Field('Reserved', Bits(31, 12), 'Reads as 0x0. Writes ignored. Must be written with a value of 0x0.'),
                           Field('IOCU_TYPE', Bits(11, 10), '0x0 = This is a ${proc} core and not an    IOCU. Only the ${proc} core can access priority     values in the GCR_Cx_TCID_n_PRIORITY registers.${p}    0x1: This is a non-caching IOCU (no intervention    port). The IOCU does not access the GCR_Cx_TCID_n_PRIORITY     registers.${p}    0x2 = This is a caching IOCU (not currently implemented     by MIPS).${p}    Note that the first encoding is redundant information    for convenience. It is possible for the system    to determine if a core is an IOCU or not by reading    the Global Config register.', [Value('This is a core and not an IOCU', 0), Value('This is a non-caching IOCU', 1), Value('This is a caching IOCU', 2)]),
                           Field('PVPE', Bits(9, 0), 'Number of VPEs in this core. For IOCUs, this field is     hard coded to 0x0. Number of VPEs is (field value + 1)${p}    Note that in the 1074K and proAptiv.*cores, the term VPE is     analogous to a core since there is one VPE per core.')]},
 'Cx_ID_FIELDS': {'': [Field('CORENUM', Bits(31, 0), 'This number is used as an index to the registers     within the GCR when accessing the Core-local control     block for this core.')]},
 'Cx_OTHER_FIELDS': {'': [Field('CORENUM', Bits(31, 16), 'Core number of the register set to be accessed     in the Core-Other address space.'),
                          Field('Reserved', Bits(15, 0), 'Reads as 0x0. Writes ignored. Must be written with a value of 0x0.')]},
 'Cx_RESET_BASE_FIELDS': {'': [Field('BEVEXCBase', Bits(31, 12), 'Bits [31:12] of the virtual address that the local core will    use as the exception base in the boot environment (C0P0    Status[BEV]=1).'),
                               Field('Reserved', Bits(11, 0), 'Reads as 0x0. Must be written with a value of 0x0.')]},
 'Cx_RESET_EXT_BASE_FIELDS': {'': [Field('EVAReset', Bits(31), 'Assertion of this bit indicates to the core to come up in    the EVA configuration at reset. This bit is originally set    based on the state of the EVAReset pin during reset.'),
                                   Field('UseExceptionBase', Bits(30), u'UseExceptionBase address. This bit reflects the state of    the SI_UseExceptionBase pin at reset.${p}    In the legacy configuration, if the    SI_UseExceptionBase pin is not asserted, then the    BEV location defaults to 0xBFC0_0000.${p}    If the SI_UseExceptionBase pin is asserted, address    bits SI_ExceptionBase[31:30] are forced to a value of    2\u2019b10 to force the BEV location into the KSEG0/    KSEG1 space.${p}    Refer to Section 3.7.2 in Chapter 3 for more information.    This pin is only used in the legacy configuration.    There is one SI_UseExceptionBase pin per core.'),
                                   Field('Reserved', Bits(29, 28), 'Reads as 0x0. Must be written with a value of 0x0.'),
                                   Field('BEVExceptionBaseMask', Bits(27, 20), 'This field is used to determine the size of the boot    exception vector overlay region from 1 MB to 256 MB    in powers of two. This field reflects the state of the    SI_ExceptionBaseMask[27:20] pins at reset.    This field is used to mask bits [27:20] of the virtual    address that the local core will use as the exception base    in the boot environment (C0P0 StatusBEV = 1).    These pins are used in both the legacy and EVA configurations.    There is one set of SI_ExceptionBaseMask    pins per core.'),
                                   Field('Reserved', Bits(19, 8), 'Reads as 0x0. Must be written with a value of 0x0.'),
                                   Field('BEVExceptionBasePA', Bits(7, 1), 'BEV exception base physical address. This field contains    the upper bits of the physical address that the local    core will use as the exception base in the boot environment    (C0P0 StatusBEV = 1).and reflects the state of the    SI_ExceptionBasePA[31:29] pins at reset.${p}    The size of the overlay region defined by    SI_ExceptionBaseMask[27:20] is remapped to a    location in physical address space pointed to by the    SI_ExceptionBasePA[31:29] pins. This allows the    overlay region to be placed into one of the 512 MB segments    in physical memory. These pins are used in both    the legacy and EVA configurations. There is one set of    SI_ExceptionBasePA pins per core.${p}    Note that the bits of this register correspond to upper    address bits 35:29. However, in the proAptiv.*core only    the lower three bits (31:29) are used, which correspond    to bits 3:1 of this field. The upper four bits are reserved    for future cores which implement a 36-bit address. This    bit should always be driven with a value of 0x0.'),
                                   Field('PRESENT', Bits(0), 'Reads as 0x1. Writes are ignored')]},
 'Cx_TCID_FIELDS': {'': [Field('Reserved', Bits(31, 2), 'Reads as 0x0. Must be written with a value of 0x0.'),
                         Field('TCID_PRIORITY', Bits(1, 0), 'TCID priority. This 2-bit value contains the     thread context priority level', [Value('0: Lowest', 0), Value('1: Low', 1), Value('2: High', 2), Value('3: Highest', 3)])]},
 'EntryLoTemplate': {'': [Field('Reserved', Bits(31, 30), 'Reserved.  Should be ignored on writes; returns zero on reads.'),
                          Field('0', Bits(29, 26), 'These 4 bits are normally part of the PFN, however, since the 34k supports only 32 bits of physical address, the PFN is only 20 bits wide; therefore, bits 29:26 of this register must be written with zeros.'),
                          Field('PFN', Bits(25, 6), 'Page Frame Number: Contributes to the definition of the highorder bits of the physical address.  The PFN field corresponds to bits 31..12 of the physical address.'),
                          Field('C', Bits(5, 3), 'Coherence attribute of the page.', [Value('Cacheable, noncoherent, write-through, no write allocate', 0), Value('Reserved', 1, '', True), Value('Uncached', 2), Value('Cacheable, noncoherent, write-back, write allocate', 3), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Uncached Accelerated', 7)]),
                          Field('D', Bits(2), 'Dirty or write-enable bit: Indicates that the page has been written, and/or is writable.  If this bit is a one, then stores to the page are permitted.  If this bit is a zero, then stores to the page cause a TLB Modified exception.'),
                          Field('V', Bits(1), 'Valid bit: Indicates that the TLB entry, and thus the virtual page mapping are valid.  If this bit is a one, then accesses to the page are permitted.  If this bit is a zero, then accesses to the page cause a TLB Invalid exception.'),
                          Field('G', Bits(0), 'Global bit: On a TLB write, the logical AND of the G bits in both the EntryLo0 and EntryLo1 registers become the G bit in the TLB entry.  If the TLB entry G bit is a one, then the ASID comparisons are ignored during TLB matches.  On a read from a TLB entry, the G bits of both EntryLo0 and EntryLo1 reflect the state of the TLB G bit.')],
                     'M5150.*': [Field('RI', Bits(31), 'Read Inhibit.  If this bit is set in a TLB entry, any attempt (other than a MIPS16 PC-relative load) to read data on the virtual page causes either a TLB Invalid or a TLBRI exception, even if the V (Valid) bit is set.  The RI bit is writable only if the RIE bit of the PageGrain register is set.\\n\\nIf the RIE bit of the PageGrain register is not set, the RI bit of Entry 0 and Entry 1 are set to zero on any write to the register, regardless of the value written.'),
                                 Field('XI', Bits(30), 'Execute Inhibit.  If this bit is set in a TLB entry, any attempt to fetch an instruction or to load MIPS16 PC-relative data from the virtual page causes a TLB Invalid or a TLBXI exception, even if the V (Valid) bit is set.  The XI bit is writable only if the XIE bit of the PageGrain register is set.\\n\\nIf the XIE bit of the PageGrain register not set, the XI bit of TLB Entry 0 - 1 is set to zero on any write to the register, regardless of the value written.'),
                                 Field('PFN', Bits(25, 6), "The 'Physical Frame Number' represents the high-order bits of the physical address.  The 20 bits of PFN, together with 12 bits of in-page address, make up a 32-bit physical address.  The MIPS32 Architecture permits the PFN to be as large as 24 bits.  The proAptiv.*core supports a 32-bit physical address bus."),
                                 Field('C', Bits(5, 3), 'Coherence attribute of the page.', [Value('Cacheable, noncoherent, write-through, no write allocate', 0), Value('Cacheable, noncoherent, write-through,  write allocate', 1), Value('Uncached', 2), Value('Cacheable, noncoherent, write-back, write allocate', 3), Value('Cacheable, noncoherent, write-back, write allocate', 4), Value('Cacheable, noncoherent, write-back, write allocate', 5), Value('Cacheable, noncoherent, write-back, write allocate', 6), Value('Uncached Accelerated', 7)]),
                                 Field('D', Bits(2), "The 'dirty' flag.  Indicates that the page has been written, and/or is writable.  If this bit is a one, stores to the page are permitted.  If this bit is a zero, stores to the page cause a TLB Modified exception.\\n\\nSoftware can use this bit to track pages that have been written to.  When a page is first mapped, this bit should be cleared.  It is set on the first write that causes an exception."),
                                 Field('V', Bits(1), "The 'valid' flag.  Indicates that the TLB entry, and thus the virtual page mapping, are valid.  If this bit is a set, accesses to the page are permitted.  If this bit is a zero, accesses to the page cause a TLB Invalid exception.\\n\\nThis bit can be used to make just one of a pair of pages valid."),
                                 Field('G', Bits(0), 'The global bit.  On a TLB write, the logical AND of the G bits in both the Entry 0 and Entry 1 registers become the G bit in the TLB entry.  If the TLB entry G bit is a one, then the ASID comparisons are ignored during TLB matches.  On a read from a TLB entry, the G bits of both Entry 0 and Entry 1 reflect the state of the TLB G bit.')],
                     'proAptiv.*,P5600.*,interAptiv.*': [Field('Reserved', Bits(31, 30), 'Must be written as zero; returns zero on read.', [], None, 'interAptiv.*'),
                                                         Field('RI', Bits(31), 'Read Inhibit.  If this bit is set in a TLB entry, any attempt (other than a MIPS16 PC-relative load) to read data on the virtual page causes either a TLB Invalid or a TLBRI exception, even if the V (Valid) bit is set.  The RI bit is writable only if the RIE bit of the PageGrain register is set.${p}If the RIE bit of the PageGrain register is not set, the RI bit of Entry 0 and Entry 1 are set to zero on any write to the register, regardless of the value written.', [], None, 'proAptiv.*,P5600.*'),
                                                         Field('XI', Bits(30), 'Execute Inhibit.  If this bit is set in a TLB entry, any attempt to fetch an instruction or to load MIPS16 PC-relative data from the virtual page causes a TLB Invalid or a TLBXI exception, even if the V (Valid) bit is set.  The XI bit is writable only if the XIE bit of the PageGrain register is set.${p}If the XIE bit of the PageGrain register not set, the XI bit of TLB Entry 0 - 1 is set to zero on any write to the register, regardless of the value written.', [], None, 'proAptiv.*,P5600.*'),
                                                         Field('U', Bits(29, 26), 'The upper 4 bits of the PFN are not used in this architecture but can be written by software.'),
                                                         Field('PFN', Bits(25, 6), "The 'Physical Frame Number' represents the high-order bits of the physical address.  The 20 bits of PFN, together with 12 bits of in-page address, make up a 32-bit physical address.  Although the MIPS32 Architecture permits the PFN to be as large as 24 bits, the core supports only a 32-bit physical address bus."),
                                                         Field('C', Bits(5, 3), 'Coherence attribute of the page.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Uncached', 2), Value('Cacheable, noncoherent, write-back, write allocate', 3), Value('Cacheable, write-back, write-allocate, coherent, read misses request Exclusive', 4), Value('Cacheable, write-back, write-allocate, coherent, read misses request Shared', 5), Value('Reserved', 6, '', True), Value('Uncached Accelerated', 7)], None, 'ProAptiv.*,P5600.*'),
                                                         Field('C', Bits(5, 3), 'Coherence attribute of the page.', [Value('Reserved if multi-core, else Cacheable, noncoherent, write-through, no write allocate if not', 0), Value('Reserved', 1, '', True), Value('Uncached', 2), Value('Cacheable, noncoherent, write-back, write allocate', 3), Value('Cacheable, write-back, write-allocate, coherent, read misses request Exclusive if multi-core, else Reserved if not', 4), Value('Cacheable, write-back, write-allocate, coherent, read misses request Shared if multi-core, else Reserved if not', 5), Value('Reserved', 6, '', True), Value('Uncached Accelerated', 7)], None, 'InterAptiv.*'),
                                                         Field('D', Bits(2), "The 'dirty' bit.  Indicates that the page has been written, and/or is writable.  If this bit is a one, stores to the page are permitted.  If this bit is a zero, stores to the page cause a TLB Modified exception.${p}Software can use this bit to track pages that have been written to.  When a page is first mapped, this bit should be cleared.  It is set on the first write that causes an exception."),
                                                         Field('V', Bits(1), "The 'valid' bit.  Indicates that the TLB entry, and thus the virtual page mapping, are valid.  If this bit is a set, accesses to the page are permitted.  If this bit is a zero, accesses to the page cause a TLB Invalid exception.${p}This bit can be used to make just one of a pair of pages valid."),
                                                         Field('G', Bits(0), "The 'global' bit.  On a TLB write, the logical AND of the G bits in both the EntryLo0 and EntryLo1 registers become the G bit in the TLB entry.  If the TLB entry G bit is a one, then the ASID comparisons are ignored during TLB matches.  On a read from a TLB entry, the G bits of both EntryLo0 and EntryLo1 reflect the state of the TLB G bit.")]},
 'EntryLoTemplate64': {'': [Field('Reserved', Bits(63, 0), 'Reserved.  Should be ignored on writes; returns zero on reads.')],
                       'I6[45]00.*,P6600.*': [Field('RI', Bits(63), 'Read-Inhibit and Execute-Inhibit page protection bits appear in different bit locations     for the DMFC0/DMTC0 and MFC0/MTC0 instruction pairs to provide compatibility     between the 32-bit and 64-bit architectures. Read Inhibit. If this bit is set in a TLB     entry, an attempt to read data on the virtual page causes a TLBRI exception.'),
                                              Field('XI', Bits(62), 'Execute Inhibit. If this bit is set in a TLB entry, an attempt to fetch an instruction from     the virtual page causes a TLBXI exception.'),
                                              Field('PFNX', Bits(54, 30), 'Page Frame Number Extension. If the processor is enabled to support large physical     addresses (Config3LPA = 1 and PageGrainELPA = 1), this field is concatenated with     the PFN field to form the full page frame number corresponding to the physical     address.  The PFNX field corresponds to bits [47:36] of the physical address becomes 0 when     MTCO is used.', [], None, 'I6[45]00.*'),
                                              Field('PFNX', Bits(33, 30), 'Page Frame Number Extension. If the processor is enabled to support large physical     addresses (Config3LPA = 1 and PageGrainELPA = 1), this field is concatenated with     the PFN field to form the full page frame number corresponding to the physical     address.  The PFNX field corresponds to bits [47:36] of the physical address becomes 0 when     MTCO is used.', [], None, 'P6600.*'),
                                              Field('PFN', Bits(29, 6), 'Page Frame Number. This field contains least-significant bits of the physical page     number corresponding to the virtual page. If the processor is enabled to support large     physical addresses, the PFNX field described above is concatenated with the PFN field     to form the full page frame number. If the processor is not enabled to support large     physical addresses, the entire page frame number is represented by this field. See the     description of the PFNX field above for more information.     The PFN field corresponds to bits [35:12] of the physical address.'),
                                              Field('C', Bits(5, 3), 'Cacheability and Coherency Attribute of the page.'),
                                              Field('D', Bits(2), "'Dirty', indicating that the page is writable. If this bit is a one, stores to the page are permitted.     If this bit is a zero, stores to the page cause a TLB Modified exception. Kernel     software may use this bit to implement paging algorithms that require knowing which     pages have been written. If this bit is always zero when a page is initially mapped, the     TLB Modified exception that results on any store to the page can be used to update     kernel data structures that indicate that the page was actually written."),
                                              Field('V', Bits(1), 'Valid bit, indicating that the TLB entry, and thus the virtual page mapping are valid. If     this bit is a one, accesses to the page are permitted. If this bit is a zero, accesses to the     page cause a TLB Invalid exception.'),
                                              Field('G', Bits(0), 'Global bit. On a TLB write, the logical AND of the G bits from both EntryLo0 and     EntryLo1 becomes the G bit in the TLB entry. If the TLB entry G bit is a one, ASID     comparisons are ignored during TLB matches. On a read from a TLB entry, the G bits     of both EntryLo0 and EntryLo1 reflect the state of the TLB G bit.')]},
 'Perf_control_even': {'': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                            Field('0', Bits(30, 12), 'Reserved.'),
                            Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch instructions completed', 2), Value("'jr $31' (return) instructions", 3), Value("'jr' (not 'jr $31') instructions", 4), Value('ITLB accesses', 5), Value('DTLB accesses', 6), Value('Joint TLB instruction accesses (same as ITLB misses)', 7), Value('Joint TLB data accesses (same as DTLB misses)', 8), Value('Instruction cache accesses', 9), Value('Data cache load/stores', 10), Value('Load/stores which miss in D-cache', 11), Value('Reserved', 12, '', True), Value('Store Misses', 13), Value('Integer instructions completed', 14), Value('Loads completed (including FP loads)', 15), Value("'j'/'jal' instructions completed", 16), Value('No-ops completed', 17), Value('Stall cycles', 18), Value('Store conditional (sc) instructions completed', 19), Value("'prefetch' instructions completed", 20), Value('L2 cache writebacks', 21), Value('L2 cache misses', 22), Value('Exceptions taken', 23), Value('Cache fixup', 24), Value('IFU stall cycles', 25), Value('DSP Instructions Completed', 26), Value('Reserved', 27, '', True), Value('Available for customer PM event', 28), Value('Available for customer ISPRAM event', 29), Value('Available for CorExtend event', 30), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Uncached loads', 33), Value('Reserved', 34, '', True), Value('CP2 Arithmetic Instns Completed', 35), Value('Reserved', 36, '', True), Value('I$ Miss stall cycles', 37), Value('SYNC stalls', 38), Value('D$ miss cycles', 39), Value('Uncached stall cycles', 40), Value('MDU stall cycles', 41), Value('CP2 stall cycles', 42), Value('ISPRAM stall cycles', 43), Value('CACHE instruction stall cycles', 44), Value('Load to Use stall cycles', 45), Value('Other interlock stall cycles', 46), Value('Reserved', 47, '', True), Value('IFU refetches an address because Fill Buffer was full on a miss', 48), Value('EJTAG instruction triggers', 49), Value('FSB (Fill-Store Buffer) < 1/4 full', 50), Value('FSB (Fill-Store Buffer) > 1/2 full', 51), Value('LDQ (Load Data Queue) < 1/4 full', 52), Value('LDQ (Load Data Queue) > 1/2 full', 53), Value('WBB (Write Back Buffer) < 1/4 full', 54), Value('WBB (Write Back Buffer) > 1/2 full', 55), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('Reserved', 68, '', True), Value('Reserved', 69, '', True), Value('Reserved', 70, '', True), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Reserved', 73, '', True), Value('Reserved', 74, '', True), Value('Reserved', 75, '', True), Value('Reserved', 76, '', True), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                            Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                            Field('U', Bits(3), 'Count events in user mode.'),
                            Field('S', Bits(2), 'Count events in supervisor mode.'),
                            Field('K', Bits(1), 'Count events in kernel mode.'),
                            Field('EXL', Bits(0), 'Count events in exception-mode.')],
                       '1004K.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                   Field('0', Bits(30), 'Reserved.'),
                                   Field('TCID', Bits(29, 22), 'Which TCs events should we count?.'),
                                   Field('MT_EN', Bits(21, 20), 'Select just-this-VPE or just-this-TC counting.', [Value('Count events from all TCs & VPEs', 0), Value('Count events from all TCs of the VPE specified in VPEID', 1), Value('Count events from the TC specified in TCID', 2), Value('Reserved', 3, '', True)]),
                                   Field('VPEID', Bits(19, 16), 'Which VPEs events should we count?'),
                                   Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                   Field('0', Bits(14, 12), 'Reserved.'),
                                   Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch instructions completed', 2), Value("'jr $31' (return) instructions", 3), Value('jr (not $31) instructions', 4), Value('ITLB accesses', 5), Value('DTLB accesses', 6), Value('JJTLB instruction accesses', 7), Value('JTLB data accesses', 8), Value('Instruction Cache accesses', 9), Value('Data cache accesses', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Store Misses', 13), Value('Integer instructions completed', 14), Value('Loads completed', 15), Value("'j'/'jal' instructions completed", 16), Value('No-ops completed', 17), Value('Stall cycles', 18), Value('Store conditional (sc) instructions completed', 19), Value("'prefetch' instructions to cached addresses", 20), Value('L2 cache writebacks', 21), Value('L2 cache misses', 22), Value('Exceptions taken', 23), Value('Cache fixup', 24), Value('IFU stall cycles', 25), Value('DSP instructions completed', 26), Value('Reserved', 27, '', True), Value('Available for customer PM event', 28), Value('Available for customer ISPRAM event', 29), Value('Available for CorExtend event', 30), Value('Available for external yield manager event', 31), Value('ITC loads', 32), Value('Uncached loads', 33), Value('Fork instructions completed', 34), Value('CP2 register-to-register instructions completed', 35), Value('Intervention stall main pipe', 36), Value('I$ Miss stall cycles', 37), Value('Reserved', 38, '', True), Value('D$ miss cycles', 39), Value('Uncached stall cycles', 40), Value('MDU stall cycles', 41), Value('CP2 stall cycles', 42), Value('ISPRAM stall cycles', 43), Value('CACHE instruction stall cycles', 44), Value('Load to Use stall cycles', 45), Value('Other interlock stall cycles', 46), Value('Relax bubbles', 47), Value('IFU FB full refetches', 48), Value('EJTAG Instruction triggers', 49), Value('FSB (Fill-Store Buffer) < 1/4 full', 50), Value('FSB (Fill-Store Buffer) > 1/2 full', 51), Value('LDQ (Load Data Queue) < 1/4 full', 52), Value('LDQ (Load Data Queue) > 1/2 full', 53), Value('WBB (Write Back Buffer) < 1/4 full', 54), Value('WBB (Write Back Buffer) > 1/2 full', 55), Value('Coherent Event: Intervention Hits', 56), Value('Coherent Event: All Invalidates', 57), Value('Coherent Event: Evictions', 58), Value('Coherent Event: ST_Inval', 59), Value('Coh: ST_Store_to_S', 60), Value('Latency Event: Request Latency to Self Intervention', 61), Value('Latency Event: Request Latency to Read Response', 62), Value('Reserved', 63, '', True), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('Reserved', 68, '', True), Value('Reserved', 69, '', True), Value('Reserved', 70, '', True), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Reserved', 73, '', True), Value('Reserved', 74, '', True), Value('Reserved', 75, '', True), Value('Reserved', 76, '', True), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                   Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                   Field('U', Bits(3), 'Count events in user mode.'),
                                   Field('S', Bits(2), 'Count events in supervisor mode.'),
                                   Field('K', Bits(1), 'Count events in kernel mode.'),
                                   Field('EXL', Bits(0), 'Count events in exception-mode.')],
                       '1074K.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                   Field('0', Bits(30, 16), 'Reserved.'),
                                   Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                   Field('0', Bits(14, 12), 'Reserved.'),
                                   Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value("'jr $31' (return) instructions that are predicted", 2), Value('Cycles where no instruction is fetched because no next addr candid', 3), Value('ITLB accesses', 4), Value('Reserved', 5, '', True), Value('I-Cache accesses', 6), Value('Cycles where no instruction is fetched because it missed I-Cache', 7), Value('Cycles where no instruction is fetched - waiting for I-fetch', 8), Value('Replays within the IFU that happen because I-buffer full', 9), Value('Store misses transitioning to I-M or S-M', 10), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Cycles when no instructoins can be added to ALU issue pool; pool full', 13), Value('Cycles where no instructoins can be added to ALU issue pool, run out of ALU CBs', 14), Value('Cycles where no instructoins can be added to issue pool, because all FIFO entires used', 15), Value('Cycles with no ALU-pipe issue: no instructions available', 16), Value('Cycles with no ALU-pipe issue: have instructoins, but operands not ready', 17), Value('Cycles with no ALU-pipe issue: operands ready but resource unavailable', 18), Value('ALU-pipe bubble issued', 19), Value('Cycles when one instruction is issued', 20), Value('Out-of-order ALU issue; instructions issued not oldest in pool', 21), Value('Graduated JAR/JALR.HB', 22), Value('Cacheable loads', 23), Value('D-Cache writebacks', 24), Value('D-side JTLB accesses', 25), Value('Load/store instruction redirects', 26), Value('Reserved', 27, '', True), Value('L2 cache writebacks', 28), Value('L2 cache misses', 29), Value('Cycles Fill Store Buffer(FSB) are full and cause a pipe stall', 30), Value('Cycles Load Data Queue (LDQ) are full and cause a pipe stall', 31), Value('Cycles Writeback Buffer(WBB) are full and cause a pipe stall', 32), Value('Count of requests that will receive data from the CM', 33), Value('Invalidate intervention hits', 34), Value('Redirects after optimistic issue of instructoins dependent on load', 35), Value('jr (not $31) instructions graduated', 36), Value('Branch instructions graduated', 37), Value('Branch-likely instructions graduated', 38), Value('Conditional branches graduated', 39), Value('Integer instructions graduated (includes all no-ops, ssnop, ehb', 40), Value('Loads (including FP) graduated', 41), Value("'j'/'jal' graduated", 42), Value('No-ops graduated', 43), Value('DSP instructions graduated', 44), Value('DSP branch instructions graduated', 45), Value('Uncached loads graduated', 46), Value('Writebacks due to evictions', 47), Value('Count of all invalidates (M,E,S)-I', 48), Value('EJTAG instruction triggers', 49), Value('CP1 branches mispredicted', 50), Value('Store conditional (sc) instructions graduated', 51), Value("'prefetch' instructions graduated", 52), Value('Cycles where no instructions graduated', 53), Value('Cycles where one instruction graduated', 54), Value('GFifo blocked cycles', 55), Value('GFifo blocked due to TLB or Cacheop', 56), Value('Slot 0 mispredicted branch instruction graduation cycles without the delayslot', 57), Value('Exceptions taken', 58), Value('Implementation-specific CorExtend event', 59), Value('State transition from S->M (coherent and non-coh)', 60), Value('Request latency to self-intervention', 61), Value('Implementation-specific event from ISPRAM block', 62), Value('L2 single-bit errors which were corrected', 63), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('All OCP requests accepted', 68), Value('OCP read requests accepted', 69), Value('OCP write requests accepted', 70), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('OCP Intervention write data stalled (valid but not accepted)', 73), Value('Cycles Fill Store Buffer(FSB) < 1/4 full', 74), Value('Cycles Load Data Queue (LDQ) < 1/4 full', 75), Value('Cycles Writeback Buffer(WBB) < 1/4 full', 76), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                   Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                   Field('U', Bits(3), 'Count events in user mode.'),
                                   Field('S', Bits(2), 'Count events in supervisor mode.'),
                                   Field('K', Bits(1), 'Count events in kernel mode.'),
                                   Field('EXL', Bits(0), 'Count events in exception-mode.')],
                       '34K.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                 Field('0', Bits(30), 'Reserved.'),
                                 Field('TCID', Bits(29, 22), 'Which TCs events should we count?.'),
                                 Field('MT_EN', Bits(21, 20), 'Select just-this-VPE or just-this-TC counting.', [Value('Count events from all TCs & VPEs', 0), Value('Count events from all TCs of the VPE specified in VPEID', 1), Value('Count events from the TC specified in TCID', 2), Value('Reserved', 3, '', True)]),
                                 Field('VPEID', Bits(19, 16), 'Which VPEs events should we count?'),
                                 Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                 Field('0', Bits(14, 12), 'Reserved.'),
                                 Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch instructions completed', 2), Value("'jr $31' (return) instructions", 3), Value('jr (not $31) instructions', 4), Value('ITLB accesses', 5), Value('DTLB accesses', 6), Value('JTLB instruction accesses', 7), Value('JTLB data accesses', 8), Value('Instruction Cache accesses', 9), Value('Data cache accesses', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Store misses', 13), Value('Integer instructions completed', 14), Value('Loads completed', 15), Value("'j'/'jal' instructions completed", 16), Value('No-ops completed', 17), Value('Stall cycles', 18), Value('Store conditional (sc) instructions completed', 19), Value("'prefetch' instructions completed", 20), Value('L2 cache writebacks', 21), Value('L2 cache misses', 22), Value('Exceptions taken', 23), Value('Cache fixup', 24), Value('IFU stall cycles', 25), Value('DSP instructions completed', 26), Value('Reserved', 27, '', True), Value('Available for customer PM event', 28), Value('Available for customer ISPRAM event', 29), Value('Available for CorExtend event', 30), Value('Available for external yield manager event', 31), Value('ITC loads', 32), Value('Uncached loads', 33), Value('Fork instructions completed', 34), Value('CP2 register-to-register instructions completed', 35), Value('Reserved', 36, '', True), Value('I-Cache Miss stall cycles', 37), Value('Reserved', 38, '', True), Value('D-miss cycles', 39), Value('Uncached stall cycles', 40), Value('MDU stall cycles', 41), Value('CP2 stall cycles', 42), Value('ISPRAM stall cycles', 43), Value('CACHE instruction stall cycles', 44), Value('Load to Use stall cycles', 45), Value('Other interlock stall cycles', 46), Value('Relax bubbles', 47), Value('IFU FB full refetches', 48), Value('EJTAG Instruction triggers', 49), Value('FSB (Fill-Store Buffer) < 1/4 full', 50), Value('FSB (Fill-Store Buffer) > 1/2 full', 51), Value('LDQ (Load Data Queue) < 1/4 full', 52), Value('LDQ (Load Data Queue) > 1/2 full', 53), Value('WBB (Write Back Buffer) < 1/4 full', 54), Value('WBB (Write Back Buffer) > 1/2 full', 55), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('Reserved', 68, '', True), Value('Reserved', 69, '', True), Value('Reserved', 70, '', True), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Reserved', 73, '', True), Value('Reserved', 74, '', True), Value('Reserved', 75, '', True), Value('Reserved', 76, '', True), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                 Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                 Field('U', Bits(3), 'Count events in user mode.'),
                                 Field('S', Bits(2), 'Count events in supervisor mode.'),
                                 Field('K', Bits(1), 'Count events in kernel mode.'),
                                 Field('EXL', Bits(0), 'Count events in exception-mode.')],
                       '74K.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                 Field('0', Bits(30, 16), 'Reserved.'),
                                 Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                 Field('0', Bits(14, 12), 'Reserved.'),
                                 Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value("'jr $31' (return) instructions that are predicted", 2), Value('Cycles where no instruction is fetched because no next addr candidate, or after a wait', 3), Value('ITLB accesses', 4), Value('Reserved', 5, '', True), Value('I-Cache accesses', 6), Value('Cycles where no instruction is fetched because it missed I-Cache', 7), Value('Cycles where no instruction is fetched - waiting for I-fetch', 8), Value('Times the instruction fetch pipeline is flushed and replayed because the IFU buffers are full and unable to accept any instructions', 9), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Cycles where no instructions are brought into the IDU because the ALU instruction candidate pool is full', 13), Value('Cycles where no instructions can be added to the issue pool, all ALU completion buffers (CBs) used', 14), Value('Cycles where no instructions can be added to the issue pool, all the FIFO entries used', 15), Value('Cycles with no ALU-pipe issue: no instructions available', 16), Value('Cycles with no ALU-pipe issue: have instructoins, but operands not ready', 17), Value('Cycles with no ALU-pipe issue: operands ready but resource unavailable', 18), Value('ALU-pipe bubble issued', 19), Value('Cycles when one instruction is issued', 20), Value('Out-of-order ALU issue; instructions issued not oldest in pool', 21), Value('Graduated JAR/JALR.HB', 22), Value('Cacheable loads', 23), Value('D-Cache writebacks', 24), Value('D-side JTLB accesses', 25), Value('Load/store instruction redirects', 26), Value('Reserved', 27, '', True), Value('L2 cache writebacks', 28), Value('L2 cache misses', 29), Value('Cycles Fill Store Buffer(FSB) are full and cause a pipe stall', 30), Value('Cycles Load Data Queue (LDQ) are full and cause a pipe stall', 31), Value('Cycles Writeback Buffer(WBB) are full and cause a pipe stall', 32), Value('Reserved', 33, '', True), Value('Reserved', 34, '', True), Value('Redirects after optimistic issue of instructoins dependent on load', 35), Value('jr (not $31) instructions graduated', 36), Value('Integer Branch instructions graduated', 37), Value('Branch-likely instructions graduated', 38), Value('Conditional branches graduated', 39), Value('Integer instructions graduated', 40), Value('Loads (including FP) graduated', 41), Value("'j'/'jal' graduated", 42), Value('No-ops graduated - included (sll, nop, ssnop, ehb)', 43), Value('DSP instructions graduated', 44), Value('DSP branch instructions graduated', 45), Value('Uncached loads graduated', 46), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('EJTAG instruction triggers', 49), Value('CP1 branches mispredicted', 50), Value('Store conditional (sc) instructions graduated', 51), Value("'prefetch' instructions graduated at the top of LSGB", 52), Value('Cycles where no instructions graduated', 53), Value('Cycles where one instruction graduated', 54), Value('GFifo blocked cycles', 55), Value('GFifo blocked due to TLB or Cacheop', 56), Value('Slot 0 mispredicted branch instruction graduation cycles without the delayslot', 57), Value('Exceptions taken', 58), Value('Implementation-specific CorExtend event', 59), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Implementation-specific event from ISPRAM block', 62), Value('L2 single-bit errors which were corrected', 63), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('All OCP requests accepted', 68), Value('OCP read requests accepted', 69), Value('OCP write requests accepted', 70), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Reserved', 73, '', True), Value('Cycles Fill Store Buffer(FSB) < 1/4 full', 74), Value('Cycles Load Data Queue (LDQ) < 1/4 full', 75), Value('Cycles Writeback Buffer(WBB) < 1/4 full', 76), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                 Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                 Field('U', Bits(3), 'Count events in user mode.'),
                                 Field('S', Bits(2), 'Count events in supervisor mode.'),
                                 Field('K', Bits(1), 'Count events in kernel mode.'),
                                 Field('EXL', Bits(0), 'Count events in exception-mode.')],
                       'I6[45]00.*': [Field('M', Bits(31), "This field is set to 1 as another pair of Performance Counter Control and Counter registers     is implemented at an MTC0 or MFC0 select field value of 'n+2' and 'n+3'."),
                                      Field('W', Bits(30), 'Specifies the width of the corresponding Counter register. This field is set to 0 as the     width of the corresponding Counter register is 32 bits'),
                                      Field('Impl', Bits(29, 25), 'Implementation dependent. These bits are implementation dependent and not defined by the     architecture. These bits are not used by this implementation.'),
                                      Field('EC', Bits(24, 23), 'VZ'),
                                      Field('PCTD', Bits(15), 'Performance Counter Trace Disable.'),
                                      Field('Event', Bits(12, 5), 'Selects the event to be counted by the corresponding Counter Register. The list of     events is implementation dependent, but typical events include cycles, instructions,     memory reference instructions, branch instructions, cache and TLB misses, etc.     Implementations that support multiple performance counters allow ratios of events,     e.g., cache miss ratios if cache miss and memory references are selected as the events     in two counters', [Value('Number of clock cycles', 0), Value('Number of graduated instructions', 1), Value('Number of cycles in which one instruction graduated', 2), Value('Number of cycles in which two instructions graduated', 3), Value('Number of cycles in which no instructions graduated', 4), Value('Number of ALU instructions graduated', 5), Value('Number of LSU instructions graduated', 6), Value('Number of CTI instructions graduated', 7), Value('Number of MDU instructions graduated', 8), Value('Number of FPU instructions graduated', 9), Value('Number of MSA instructions graduated', 10), Value('Number of Load instructions graduated', 11), Value('Number of Store instructions graduated', 12), Value('Number of cycle in which no instructions got issued', 13), Value('Number of cycles in which one instruction got issued', 14), Value('Number of cycles in which two instructions got issued', 15), Value('Number of times the Issue unit got stalled', 16), Value('Number of times the Decoder unit got stalled', 17), Value('Number of times the Dependency Mapper Unit got stalled', 18), Value('Cycles in which instruction buffer is empty', 19), Value('Replays initiated by the scoreboard', 20), Value('Number of conditional branches graduated', 21), Value('mispredicted conditional branches graduated', 22), Value('Returns (JR $31) graduated', 23), Value('Mispredicted Returns (JR $31) graduated', 24), Value('JR graduated', 25), Value('Mispredicted JR graduated', 26), Value('Taken conditional branches graduated ', 27), Value('Not taken conditional branches graduated', 28), Value('Total redirects', 29), Value('Total number of exceptions', 30), Value('Number of cycles an Icache miss is solely responsible for stalling the pipe', 31), Value('Number of cycles graduation was blocked because of a load waiting to complete', 32), Value('Number of cycles graduation was blocked because of sync waiting to complete', 33), Value('DTLB Lookups', 64), Value('DTLB Misses (new)', 65), Value('DTLB Misses (merged with existing)', 66), Value('Bonded Load', 67), Value('Bonded Store', 68), Value('Total number of cache lookups', 69), Value('Number of Load-type instructions', 70), Value('Number of Store-type instructions', 71), Value('Misses cache lookup', 72), Value('Loads miss cache lookup', 73), Value('Stores miss cache lookup', 74), Value('Number of cycles SDB graduation was blocked due to SMB full', 75), Value('All VPs currently stalled (for any reason)', 128), Value('VP accessed the uTLB', 129), Value('VP stalled waiting for MMU response to uTLB', 130), Value('VP access to uTLB caused a uTLB Miss', 131), Value('VP accessed the I$', 132), Value('VP access to the I$ resulted in cache miss', 133), Value('VP stalled waiting for IBuffer credit', 134), Value('VP stalled waiting for PCBuffer credit', 135), Value('VP stalled (for any reason)', 136)]),
                                      Field('IE', Bits(4), 'Interrupt Enable. Enables the interrupt request when the corresponding counter overflows     (the most-significant bit of the counter is one. This is bit 31 for a 32-bit wide     counter or bit 63 of a 64-bit wide counter, denoted by the W bit in this register).     Note that this bit simply enables the interrupt request. The actual interrupt is still     gated by the normal interrupt masks and enable in the Status register.', [Value('Performance counter interrupt disabled', 0), Value('Performance counter interrupt enabled', 1)]),
                                      Field('U', Bits(3), 'Enables event counting in User Mode.', [Value('Disable counting', 0), Value('Enable counting', 1)]),
                                      Field('S', Bits(2), 'Enables event counting in Supervisor Mode.', [Value('Disable counting', 0), Value('Enable counting', 1)]),
                                      Field('K', Bits(1), 'Enables event counting in Kernel Mode. This bit enables event counting only when     the EXL and ERL bits in the Status register are zero.', [Value('Disable counting', 0), Value('Enable counting', 1)]),
                                      Field('EXL', Bits(0), 'Enables event counting when the EXL bit in the Status register is one and the ERL bit     in the Status register is zero.', [Value('Disable counting', 0), Value('Enable counting', 1)])],
                       'InterAptiv.*': [Field('M', Bits(31), 'If this bit is one, another pair of Performance Control and Counter registers is implemented at a MTC0 or MFC0 select field value of +2 and +3'),
                                        Field('0', Bits(30), 'Must be written as zero; returns zero on read.'),
                                        Field('TCID', Bits(29, 22), 'Specifies which TC events should be counted for if per-TC counting is enabled.'),
                                        Field('MT_EN', Bits(21, 20), 'Specify just-this-VPE or just-this-TC counting.', [Value('Count events from all TCs and VPEs', 0), Value('Count events from all TCs of the VPE specified in VPEID', 1), Value('Count events from the TC specified in TCID', 2), Value('Reserved', 3, '', True)]),
                                        Field('VPEID', Bits(19, 16), 'Specifies which VPE events should be counted if per-VPE counting is enabled.'),
                                        Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                        Field('0', Bits(14, 12), 'Must be written as zero; returns zero on read.'),
                                        Field('Event', Bits(11, 5), 'Counter event enabled for this counter.', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch instructions completed', 2), Value("'jr $31' (return) instructions", 3), Value('jr (not $31) instructions', 4), Value('ITLB accesses', 5), Value('DTLB accesses', 6), Value('JJTLB instruction accesses', 7), Value('JTLB data accesses', 8), Value('Instruction Cache accesses', 9), Value('Data cache accesses', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Store Misses', 13), Value('Integer instructions completed', 14), Value('Loads completed', 15), Value("'j'/'jal' instructions completed", 16), Value('No-ops completed', 17), Value('Stall cycles', 18), Value('Store conditional (sc) instructions completed', 19), Value("'prefetch' instructions completed", 20), Value('L2 cache writebacks', 21), Value('L2 cache misses', 22), Value('Exceptions taken', 23), Value('Cache fixup', 24), Value('IFU stall cycles', 25), Value('DSP instructions completed', 26), Value('Reserved', 27, '', True), Value('Available for customer PM event', 28), Value('Available for customer ISPRAM event', 29), Value('Available for CorExtend event', 30), Value('Available for external yield manager event', 31), Value('ITC loads', 32), Value('Uncached loads', 33), Value('FORK instructions completed', 34), Value('CP2 Arithmetic instructions completed', 35), Value('Intervention stall main pipe', 36), Value('I$ Miss stall cycles', 37), Value('SYNC stall cycles', 38), Value('D$ miss cycles', 39), Value('Uncached stall cycles', 40), Value('MDU stall cycles', 41), Value('CP2 stall cycles', 42), Value('ISPRAM stall cycles', 43), Value('CACHE instruction stall cycles', 44), Value('Load to Use stall cycles', 45), Value('Other interlock stall cycles', 46), Value('Relax bubbles', 47), Value('IFU FB full refetches', 48), Value('EJTAG Instruction triggers', 49), Value('FSB (Fill-Store Buffer) < 1/4 full', 50), Value('FSB (Fill-Store Buffer) > 1/2 full', 51), Value('LDQ (Load Data Queue) < 1/4 full', 52), Value('LDQ (Load Data Queue) > 1/2 full', 53), Value('WBB (Write Back Buffer) < 1/4 full', 54), Value('WBB (Write Back Buffer) > 1/2 full', 55), Value('Coherent Event: Intervention Hits', 56), Value('Coherent Event: All Invalidates', 57), Value('Coherent Event: Evictions', 58), Value('Coherent Event: ST_Inval', 59), Value('Coherent Event: ST_Store_to_S', 60), Value('Latency Event: Request Latency to Self Intervention', 61), Value('Latency Event: Request Latency to Read Response', 62), Value('Reserved', 63, '', True), Value('SI_PCEvent[0] - System specific event 0', 64), Value('SI_PCEvent[0] - System specific event 2', 65), Value('SI_PCEvent[0] - System specific event 4', 66), Value('SI_PCEvent[0] - System specific event 6', 67), Value('Reserved', 68, '', True), Value('Reserved', 69, '', True), Value('Reserved', 70, '', True), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Reserved', 73, '', True), Value('Reserved', 74, '', True), Value('Reserved', 75, '', True), Value('Reserved', 76, '', True), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                        Field('IE', Bits(4), 'Counter Interrupt Enable. This bit masks bit 31 of the associated count register from the interrupt exception request output.'),
                                        Field('U', Bits(3), 'Count in User Mode. When this bit is set, the specified event is counted in User Mode.'),
                                        Field('S', Bits(2), 'Count in Supervisor Mode. When this bit is set, the specified event is counted in Supervisor Mode.'),
                                        Field('K', Bits(1), 'Count in Kernel Mode. When this bit is set, count the event in Kernel Mode when EXL and ERL both are 0.'),
                                        Field('EXL', Bits(0), 'Count when EXL. When this bit is set, count the event when EXL = 1 and ERL = 0.')],
                       'M14KE,M14KEf,M14K,microAptivC.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                                           Field('0', Bits(30, 12), 'Reserved.'),
                                                           Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch instructions completed', 2), Value("'jr $31' (return) instructions", 3), Value("'jr' (not 'jr $31') instructions", 4), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Integer instructions completed', 14), Value('Loads completed (including FP loads)', 15), Value("'j'/'jal' instructions completed", 16), Value('No-ops complete', 17), Value('Stalls - cycles where main pipeline (RF stage) does not advance', 18), Value('Store conditional (sc) instructions completed', 19), Value("'prefetch' instructions to cached address completed", 20), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Exceptions taken', 23), Value('Reserved', 24, '', True), Value('Reserved', 25, '', True), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Reserved', 28, '', True), Value('Reserved', 29, '', True), Value('Available for CorExtend event', 30), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Reserved', 33, '', True), Value('Reserved', 34, '', True), Value('Reserved', 35, '', True), Value('Reserved', 36, '', True), Value('Reserved', 37, '', True), Value('Reserved', 38, '', True), Value('Reserved', 39, '', True), Value('Uncached access block cycles', 40), Value('MDU stall cycles', 41), Value('CP2 stall cycles', 42), Value('Reserved', 43, '', True), Value('Reserved', 44, '', True), Value('Load to Use stall cycles', 45), Value('Other interlock stall cycles', 46), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('EJTAG instruction triggers', 49), Value('Reserved', 50, '', True), Value('Reserved', 51, '', True), Value('Reserved', 52, '', True), Value('Reserved', 53, '', True), Value('Reserved', 54, '', True), Value('Reserved', 55, '', True), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True)]),
                                                           Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                                           Field('U', Bits(3), 'Count events in user mode.'),
                                                           Field('0', Bits(2), 'Reserved.'),
                                                           Field('K', Bits(1), 'Count events in kernel mode.'),
                                                           Field('EXL', Bits(0), 'Count events in exception-mode.')],
                       'M14KEc,M14Kc,microAptivP.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                                      Field('0', Bits(30, 12), 'Reserved.'),
                                                      Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch instructions completed', 2), Value("'jr $31' (return) instructions", 3), Value("'jr' (not 'jr $31') instructions", 4), Value('ITLB accesses', 5), Value('DTLB accesses', 6), Value('JTLB instruction accesses', 7), Value('JTLB data misses', 8), Value('Instruction Cache accesses', 9), Value('Data cache accesses', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Integer instructions completed', 14), Value('Loads completed', 15), Value("'j'/'jal' instructions completed", 16), Value('No-ops completed', 17), Value('Stalls cycles', 18), Value('Store conditional (sc) instructions completed', 19), Value("'prefetch' instructions to cached address completed", 20), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Exceptions taken', 23), Value('Cache fixup', 24), Value('IFU stall cycles', 25), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Reserved', 28, '', True), Value('Available for customer ISPRAM event', 29), Value('Available for CorExtend event', 30), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Uncached loads', 33), Value('Reserved', 34, '', True), Value('CP2 register-to-register instructions completed', 35), Value('Reserved', 36, '', True), Value('I-Cache Miss stall cycles', 37), Value('Reserved', 38, '', True), Value('D-cache miss cycles', 39), Value('Uncached access block cycles', 40), Value('MDU stall cycles', 41), Value('CP2 stall cycles', 42), Value('ISPRAM stall cycles', 43), Value('CACHE instruction stall cycles', 44), Value('Load to Use stall cycles', 45), Value('Other interlock stalls cycles', 46), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('EJTAG instruction triggers', 49), Value('Reserved', 50, '', True), Value('Reserved', 51, '', True), Value('LDQ (Load Data Queue) < 1/4 full', 52), Value('LDQ (Load Data Queue) > 1/2 full', 53), Value('WBB (Write Back Buffer) < 1/4 full', 54), Value('WBB (Write Back Buffer) > 1/2 full', 55), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True)]),
                                                      Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                                      Field('U', Bits(3), 'Count events in user mode.'),
                                                      Field('0', Bits(2), 'Reserved.'),
                                                      Field('K', Bits(1), 'Count events in kernel mode.'),
                                                      Field('EXL', Bits(0), 'Count events in exception-mode.')],
                       'M5100': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                 Field('0', Bits(30, 25), 'Reserved.'),
                                 Field('EC', Bits(24, 23), 'Event Class.', [Value('Root events counted.', 0), Value('Root intervention events counted.', 1), Value('Guest events counted.', 2), Value('Guest events plus Root intervention events counted.', 3)]),
                                 Field('0', Bits(22, 15), 'Reserved.'),
                                 Field('Event', Bits(14, 5), 'Extended Event specifiers for both standard and VZ ASE.', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch instructions completed', 2), Value("'jr $31' (return) instructions", 3), Value("'jr' (not 'jr $31') instructions", 4), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Integer instructions completed', 14), Value('Loads completed (including FP loads)', 15), Value("'j'/'jal' instructions completed", 16), Value('No-ops complete', 17), Value('Stalls - cycles where main pipeline (RF stage) does not advance', 18), Value('Store conditional (sc) instructions completed', 19), Value("'prefetch' instructions to cached address completed", 20), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Exceptions taken', 23), Value('Reserved', 24, '', True), Value('Reserved', 25, '', True), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Reserved', 28, '', True), Value('Reserved', 29, '', True), Value('Available for CorExtend event', 30), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Reserved', 33, '', True), Value('Reserved', 34, '', True), Value('Reserved', 35, '', True), Value('Reserved', 36, '', True), Value('Reserved', 37, '', True), Value('Reserved', 38, '', True), Value('Reserved', 39, '', True), Value('Uncached stall cycles', 40), Value('MDU stall cycles', 41), Value('CP2 stall cycles', 42), Value('Reserved', 43, '', True), Value('Reserved', 44, '', True), Value('Load to Use stall cycles', 45), Value('Other interlock stall cycles', 46), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('EJTAG instruction triggers', 49), Value('Reserved', 50, '', True), Value('Reserved', 51, '', True), Value('Reserved', 52, '', True), Value('Reserved', 53, '', True), Value('Reserved', 54, '', True), Value('Reserved', 55, '', True), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True), Value('Root exceptions taken in guest mode', 128), Value('GSFC exceptions', 129), Value('GPSI exceptions', 130), Value('Hypercall exceptions', 131), Value('Root TLB exceptions caused by I-side guest translation requests', 132), Value('Root writes that set Guest.Cause.TI to 1', 133), Value('Reserved', 134, '', True), Value('Interrupts that cause guest exit in EIC mode', 135)]),
                                 Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                 Field('U', Bits(3), 'Count events in user mode.'),
                                 Field('0', Bits(2), 'Reserved.'),
                                 Field('K', Bits(1), 'Count events in kernel mode.'),
                                 Field('EXL', Bits(0), 'Count events in exception-mode.')],
                       'M5150': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                 Field('0', Bits(30, 25), 'Reserved.'),
                                 Field('EC', Bits(24, 23), 'Event Class.', [Value('Root events counted.', 0), Value('Root intervention events counted.', 1), Value('Guest events counted.', 2), Value('Guest events plus Root intervention events counted.', 3)]),
                                 Field('0', Bits(22, 15), 'Reserved.'),
                                 Field('Event', Bits(14, 5), 'Extended Event specifiers for both standard and VZ ASE.', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch instructions completed', 2), Value("'jr $31' (return) instructions", 3), Value("'jr' (not 'jr $31') instructions", 4), Value('ITLB accesses', 5), Value('DTLB accesses', 6), Value('JTLB instruction accesses', 7), Value('JTLB data misses', 8), Value('Instruction Cache accesses', 9), Value('Data cache accesses', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Integer instructions completed', 14), Value('Loads completed', 15), Value("'j'/'jal' instructions completed", 16), Value('No-ops completed', 17), Value('Stalls cycles', 18), Value('Store conditional (sc) instructions completed', 19), Value("'prefetch' instructions to cached address completed", 20), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Exceptions taken', 23), Value('Cache fixup', 24), Value('IFU stall cycles', 25), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Reserved', 28, '', True), Value('Available for customer ISPRAM event', 29), Value('Available for CorExtend event', 30), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Uncached loads', 33), Value('Reserved', 34, '', True), Value('CP2 register-to-register instructions completed', 35), Value('Reserved', 36, '', True), Value('I-Cache Miss stall cycles', 37), Value('Reserved', 38, '', True), Value('D-cache miss cycles', 39), Value('Uncached access block cycles', 40), Value('MDU stall cycles', 41), Value('CP2 stall cycles', 42), Value('ISPRAM stall cycles', 43), Value('CACHE instruction stall cycles', 44), Value('Load to Use stall cycles', 45), Value('Other interlock stalls cycles', 46), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('EJTAG instruction triggers', 49), Value('Reserved', 50, '', True), Value('Reserved', 51, '', True), Value('LDQ (Load Data Queue) < 1/4 full', 52), Value('LDQ (Load Data Queue) > 1/2 full', 53), Value('WBB (Write Back Buffer) < 1/4 full', 54), Value('WBB (Write Back Buffer) > 1/2 full', 55), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('User defined-0', 63), Value('Root exceptions taken in guest mode', 128), Value('GSFC exceptions', 129), Value('GPSI exceptions', 130), Value('Hypercall exceptions', 131), Value('Root TLB exceptions caused by I-side guest translation requests', 132), Value('Root writes that set Guest.Cause.TI to 1', 133), Value('Reserved', 134, '', True), Value('Interrupts that cause guest exit in EIC mode', 135)]),
                                 Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                 Field('U', Bits(3), 'Count events in user mode.'),
                                 Field('0', Bits(2), 'Reserved.'),
                                 Field('K', Bits(1), 'Count events in kernel mode.'),
                                 Field('EXL', Bits(0), 'Count events in exception-mode.')],
                       'P5600.*': [Field('M', Bits(31), 'Set to 1 if there is another PerfCtl register after this one. This field is set for PerfCtl0-2 and cleared on PerfCtl3.'),
                                   Field('Reserved', Bits(30, 25), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                   Field('EC', Bits(24, 23), 'Event Class. Root only. Reserved, read-only 0 in all other contexts. The     P5600 may detect the existence of this feature by writing a non-zero     value to the field and reading. If value read is 0, then EC is not supported.     ${nl}Root events are those that occur when GuestCtl0GM=0.     Root intervention events are those that occur when GuestCtl0GM=1 and     !(Root.StatusEXL=0 and Root.StatusERL=0 and Root.DebugDM=0)     Guest events are those that occur when GuestCtl0GM=1 and Root.StatusEXL=     0 and Root.StatusERL=0 and Root.DebugDM=0     ${nl}For the case of root intervention mode, PerfCtlU/S/K/EXL are ignored as     Root.StatusEXL=1 and root must be in kernel mode.     ${nl}An implementation must qualify existing performance counter events     with the value of EC. For example, if an event is Instructions Graduated     and EC=0, then only instructions graduated in root mode are counted.', [Value('Root events counted. [default] Active in Root context.', 0), Value('Root intervention events counted. Active in Root context.', 1), Value('Guest events counted. Active in Guest context.', 2), Value('Guest plus Root events counted. Active in Guest context.', 3)]),
                                   Field('Reserved', Bits(22, 16), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                   Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                   Field('Reserved', Bits(14, 13), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                   Field('Event', Bits(12, 5), 'Determines which event to count', [Value('Cycles', 0), Value('Instructions graduated', 1), Value("'jr $31' (return) instructions whose target is predicted", 2), Value('Cycles where no instruction is fetched because no next addr candidate, or after a wait', 3), Value('ITLB accesses', 4), Value('Reserved', 5, '', True), Value('Instruction Cache accesses.', 6), Value('Cycles where no instruction is fetched because it missed I-Cache', 7), Value('Uncached Instruction Fetch stall cycles', 8), Value('IFU fetch stalls due to lack of credits on the IBUF interface', 9), Value('Store misses transitioning to I-M or S-M (multi-core only)', 10, 'Reserved in single-core.'), Value('Cycles IFU-IDU gate is closed due to: Mispredicted branch', 11), Value('Cycles IFU-IDU gate is closed due to: (1) MTC0/MFC0 sequence in pipe, (2) EHB, or (3) DD_DR_DS is blocked', 12), Value('Cycles where no instruction is inserted in DDQ0 because it is full', 13), Value('Cycles where no instructions can be issued because there are no completion buffer IDs', 14), Value('Reserved', 15, '', True), Value('Reserved', 16, '', True), Value('Reserved', 17, '', True), Value('Cycles when three instructions are issued', 18), Value('Reserved', 19, '', True), Value('Cycles when one instruction is issued', 20), Value('jr (not $31) instructions mispredicted at graduation', 21), Value('Graduated JAR/JALR.HB', 22), Value('Counts the number of speculative loads. Pairs of loads or stores that are fused count as one', 23), Value('Data cache misses at graduation', 24), Value('D-side JTLB translation fails', 25), Value('Load/store instruction redirects', 26), Value('LSGB graduation blocked cycles', 27), Value('L2 cache writebacks', 28), Value('L2 cache misses', 29), Value('Cycles Fill Store Buffer(FSB) are full and cause a pipe stall', 30), Value('Cycles Load Data Queue (LDQ) are full and cause a pipe stall', 31), Value('Cycles Writeback Buffer(WBB) are full and cause a pipe stall', 32), Value('Counts requests that will receive data from the CM (multi-core only)', 33, 'Reserved in single-core.'), Value('Invalidate intervention hits (multi-core only)', 34, 'Reserved in single-core.'), Value('Replays following optimistic issue of instruction dependent on load which missed.', 35), Value('jr (not $31) instructions graduated', 36), Value('Integer Branch instructions graduated', 37), Value('Branch-likely instructions graduated', 38), Value('Conditional branches graduated', 39), Value('Integer instructions graduated', 40), Value('Loads graduated', 41, 'Fused load/store counted as 2'), Value("'j'/'jal' graduated", 42), Value('No-ops graduated - included (sll, nop, ssnop, ehb)', 43), Value('Reserved', 44, '', True), Value('Reserved', 45, '', True), Value('Uncached loads graduated', 46), Value('Multi-core only: Writebacks due to evictions', 47, 'Reserved in single-core'), Value('Multi-core only: Count of all invalidates (M,E,S)-I', 48, 'Reserved in single-core'), Value('EJTAG instruction triggers', 49), Value('CP1 branches mispredicted', 50), Value("'sc' instructions graduated", 51), Value("'prefetch' instructions graduated at the top of LSGB", 52), Value('Cycles where no instructions graduated', 53), Value('Cycles where one instruction graduated', 54), Value('GFifo blocked cycles', 55), Value('GFifo blocked due to TLB or Cacheop', 56), Value('Mispredicted branch instruction graduation cycles without the delay slot', 57), Value('Exceptions taken', 58), Value('Reserved', 59, '', True), Value('Multi-core only: State transition from S-M (coherent and non-coherent).', 60, 'Reserved in single-core'), Value('Multi-core only: Request latency to self-intervention.', 61, 'Reserved in single-core'), Value('Reserved', 62, '', True), Value('L2 single-bit errors detected', 63), Value('SI_Event[0]', 64, 'The system integrator may connect the SI_PCEvent[0] pin to an event to be counted.'), Value('SI_Event[2]', 65, 'The system integrator may connect the SI_PCEvent[2] pin to an event to be counted.'), Value('SI_Event[4]', 66, 'The system integrator may connect the SI_PCEvent[4] pin to an event to be counted.'), Value('SI_Event[7]', 67, 'The system integrator may connect the SI_PCEvent[7] pin to an event to be counted.'), Value('All OCP requests accepted', 68), Value('OCP read requests accepted', 69), Value('OCP write requests accepted', 70), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Multi-core only: OCP Intervention write data stalled (valid but not accepted)', 73, 'Reserved in single-core'), Value('Cycles Fill Store Buffer(FSB) < 1/4 full', 74), Value('Cycles Load Data Queue (LDQ) < 1/4 full', 75), Value('Cycles Writeback Buffer(WBB) < 1/4 full', 76), Value('Times that the L1BTB caused a redirect without IFU predecode-based prediction', 77), Value('Times that the L1BTB caused a redirect with IFU predecode-based prediction', 78), Value('Writes to the RPS portion of the L1BTB with no L1BTB hit (cold miss).', 79), Value('L1 Branch Target Buffer masked hits due to lack of credit for DS', 80), Value('NFW or L1 Branch Target Buffer mispredicts for instruction cache way-hit prediction', 81), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Times a WBB entry is newly allocated for an UCA store and there is one UCA store already active in the WBB', 84), Value('Times an uncached instruction arrives at BIU while there is an actively gathering UCA buffer', 85), Value('Reserved', 86, '', True), Value('Stall cycles due to the lack of load/store queue (LSQ) ID', 87), Value('Reserved', 88, '', True), Value('Cycles when no FP instructions are dispatched', 89), Value('Cycles when one FP instruction is dispatched', 90), Value('Cycles when two FP instructions are dispatched', 91), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Cycles when three instructions are issued', 94), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Instructions issued on AGU port from DDQ1', 97), Value('Instructions issued on MDU/ALU2 port from DDQ1', 98), Value('DTLB accesses (speculative)', 99), Value('Data side hits in the VTLB/FTLB. This includes FTLB and VTLB hits and unmapped region accesses', 100), Value('Data side hits in the VTLB/FTLB in an unmapped region', 101), Value('Instruction side hits in the VTLB.', 102), Value('Data side hits in the VTLB.', 103), Value('TLBWR writes to the VTLB.', 104), Value('DTLB hits to the half of EntryLo that caused a fill (speculative)', 105), Value('Pairs of fused stores at graduation', 106), Value('Reserved', 107, '', True), Value('Times a load is not issued because it is tagged by the over-eager predictor', 108), Value('Speculative count of incorrectly fused loads and stores', 109), Value('Misaligned loads that graduated', 110), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Cycles where one FP/MSA opcode is issued.', 113), Value('Cycles where two FP/MSA opcodes are issued.', 114), Value('Reserved', 115, '', True), Value('Cycles where one FP/MSA opcode is retired.', 116), Value('Cycles where two FP/MSA opcodes are simultaneously retired.', 117), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True), Value('Root exceptions taken in guest mode.', 128), Value('GSFC exceptions..', 129), Value('GPSI exceptions.', 130), Value('Hypercall exceptions.', 131), Value('Root TLB exceptions caused by instruction-side guest translation requests.', 132), Value('Root writes that set the Guest.Cause.TI bit to 1.', 133), Value('Guest accesses to the Watch registers that cause GPSI when virtually shared.', 134), Value('Interrupts that cause a guest exit in EIC mode.', 135), Value('Data side hardware page table walks aborted due to an exception or branch mispredict related to an older instruction.', 136), Value('Instruction or data side hardware page table walks aborted because a related table walk load has missed in the main TLB.', 137), Value('An instruction or data side hardware page table walk has been initiated.', 138)]),
                                   Field('IE', Bits(4), 'Set to cause an interrupt when the counter overflows into bit 31. This c     an either be used to implement an extended count or (by presetting the counter appropriately) to notify software after a certain number of events have occurred.'),
                                   Field('U', Bits(3), 'Count events in User mode. When this bit is set, events can be counted in User mode.'),
                                   Field('S', Bits(2), 'Count events in Supervisor mode. When this bit is set, events can be counted in Supervisor mode.'),
                                   Field('K', Bits(1), 'Count events in Kernel mode. When this bit is set, events can be counted in Kernel mode.'),
                                   Field('EXL', Bits(0), 'Count events in Exception mode. When this bit is set, events can be counted in Exception mode (when StatusEXL is set).')],
                       'P6600.*': [Field('M', Bits(31), 'Set to 1 if there is another PerfCtl register after this one.'),
                                   Field('W', Bits(30), 'Specifies the width of the corresponding Counter register', [Value('32 Bits', 0), Value('64 Bits', 1)]),
                                   Field('EC', Bits(24, 23), 'Event Class. Root only. Reserved, read-only 0 in all other contexts. The     P6600 may detect the existence of this feature by writing a non-zero     value to the field and reading. If value read is 0, then EC is not supported.     ${nl}Root events are those that occur when GuestCtl0GM=0.     Root intervention events are those that occur when GuestCtl0GM=1 and     !(Root.StatusEXL=0 and Root.StatusERL=0 and Root.DebugDM=0)     Guest events are those that occur when GuestCtl0GM=1 and Root.StatusEXL=     0 and Root.StatusERL=0 and Root.DebugDM=0     ${nl}For the case of root intervention mode, PerfCtlU/S/K/EXL are ignored as     Root.StatusEXL=1 and root must be in kernel mode.     ${nl}An implementation must qualify existing performance counter events     with the value of EC. For example, if an event is Instructions Graduated     and EC=0, then only instructions graduated in root mode are counted.', [Value('Root events counted. [default] Active in Root context.', 0), Value('Root intervention events counted. Active in Root context.', 1), Value('Guest events counted. Active in Guest context.', 2), Value('Guest plus Root events counted. Active in Guest context.', 3)]),
                                   Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                   Field('Event', Bits(12, 5), 'Determines which event to count', [Value('Cycles', 0), Value('Instructions Graduated', 1), Value("'jr $31' (return) instructions whose target is predicted", 2), Value('Cycles where no instruction is fetched because no next addr candidate', 3), Value('ITLB Accesses', 4), Value('Reserved', 5, '', True), Value('Instruction Cache Accesses.', 6), Value('Cycles where no instruction is fetched because it missed I-Cache', 7), Value('Uncached Instruction Fetch stall cycles', 8), Value('IFU fetch stalls due to lack of credits on the IBUF interface', 9), Value('Store misses transitioning to I-M or S-M (multi-core only)', 10, 'Reserved in single-core.'), Value('Cycles IFU-IDU gate is closed due to: Mispredicted branch', 11), Value('Cycles IFU-IDU gate is closed due to: (1) MTC0/MFC0 sequence in pipe, (2) EHB, or (3) DD_DR_DS is blocked', 12), Value('Cycles where no instruction is inserted in DDQ0 because it is full', 13), Value('Cycles where no instructions can be issued because there are no completion buffer IDs', 14), Value('Reserved', 15, '', True), Value('Reserved', 16, '', True), Value('Reserved', 17, '', True), Value('Cycles when three instructions are issued', 18), Value('Reserved', 19, '', True), Value('Cycles when one instruction is issued', 20), Value('jr (not $31) instructions mispredicted at graduation', 21), Value('Graduated JAR/JALR.HB', 22), Value('Counts the number of speculative loads. Pairs of loads or stores that are fused count as one', 23), Value('Data cache misses at graduation', 24), Value('D-side JTLB translation fails', 25), Value('Load/store instruction redirects', 26), Value('LSGB graduation blocked cycles', 27), Value('L2 cache writebacks', 28), Value('L2 cache misses', 29), Value('Cycles Fill Store Buffer(FSB) are full and cause a pipe stall', 30), Value('Cycles Load Data Queue (LDQ) are full and cause a pipe stall', 31), Value('Cycles Writeback Buffer(WBB) are full and cause a pipe stall', 32), Value('Counts requests that will receive data from the CM. (multi-core only)', 33, 'Reserved in single-core.'), Value('Invalidate Intervention Hits (multi-core only)', 34, 'Reserved in single-core.'), Value('Replays following optimistic issue of instruction dependent on load which missed.', 35), Value('jr (not $31) instructions graduated', 36), Value('Integer Branch instructions graduated', 37), Value('Branch-likely instructions graduated', 38), Value('Conditional branches graduated', 39), Value('Integer instructions graduated', 40), Value('Loads graduated', 41, 'Fused load/store counted as 2'), Value("'j'/'jal' graduated", 42), Value('No-ops graduated - included (sll, nop, ssnop, ehb)', 43), Value('Reserved', 44, '', True), Value('Reserved', 45, '', True), Value('Uncached loads graduated', 46), Value('Writebacks due to evictions (multi-core only)', 47, 'Reserved in single-core'), Value('Count of all invalidates (M,E,S)-I (multi-core only)', 48, 'Reserved in single-core'), Value('EJTAG instruction triggers', 49), Value('CP1 branches mispredicted', 50), Value("'sc' instructions graduated", 51), Value("'prefetch' instructions graduated at the top of LSGB", 52), Value('Cycles where no instructions graduated', 53), Value('Cycles where one instruction graduated', 54), Value('GFifo blocked cycles', 55), Value('GFifo blocked due to TLB or Cacheop', 56), Value('Mispredicted branch instruction graduation cycles without the delay slot', 57), Value('Exceptions taken', 58), Value('Load/store graduation buffer (LSGB) is full indicated.', 59), Value('State transition from S-M (coherent and non-coherent)  (multi-core only).', 60, 'Reserved in single-core'), Value('Request latency to self-intervention.  (multi-core only)', 61, 'Reserved in single-core'), Value('Prediction buffer full causing IFU stall.', 62), Value('L2 single-bit errors detected', 63), Value('SI_Event[0]', 64, 'The system integrator may connect the SI_PCEvent[0] pin to an event to be counted.'), Value('SI_Event[2]', 65, 'The system integrator may connect the SI_PCEvent[2] pin to an event to be counted.'), Value('SI_Event[4]', 66, 'The system integrator may connect the SI_PCEvent[4] pin to an event to be counted.'), Value('SI_Event[7]', 67, 'The system integrator may connect the SI_PCEvent[7] pin to an event to be counted.'), Value('All OCP requests accepted', 68), Value('OCP read requests accepted', 69), Value('OCP write requests accepted', 70), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('OCP Intervention write data stalled (valid but not accepted) (multi-core only)', 73, 'Reserved in single-core'), Value('Cycles Fill Store Buffer(FSB) < 1/4 full', 74), Value('Cycles Load Data Queue (LDQ) < 1/4 full', 75), Value('Cycles Writeback Buffer(WBB) < 1/4 full', 76), Value('Times that the L1BTB caused a redirect without IFU predecode-based prediction', 77), Value('Times that the L1BTB caused a redirect with IFU predecode-based prediction', 78), Value('Writes to the RPS portion of the L1BTB with no L1BTB hit (cold miss).', 79), Value('L1 Branch Target Buffer masked hits due to lack of credit for DS', 80), Value('NFW or L1 Branch Target Buffer mispredicts for instruction cache way-hit prediction', 81), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Times a WBB entry is newly allocated for an UCA store and there is one UCA store already active in the WBB', 84), Value('Times an uncached instruction arrives at BIU while there is an actively gathering UCA buffer', 85), Value('Reserved', 86, '', True), Value('Stall cycles due to the lack of load/store queue (LSQ) ID', 87), Value('Reserved', 88, '', True), Value('Cycles when no FP instructions are dispatched', 89), Value('Cycles when one FP instruction is dispatched', 90), Value('Cycles when two FP instructions are dispatched', 91), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Cycles when three instructions are issued', 94), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Instructions issued on AGU port from DDQ1', 97), Value('Instructions issued on MDU/ALU2 port from DDQ1', 98), Value('DTLB accesses (speculative)', 99), Value('Data side hits in the VTLB/FTLB. This includes FTLB and VTLB hits and unmapped region accesses', 100), Value('Data side hits in the VTLB/FTLB in an unmapped region', 101), Value('Instruction side hits in the VTLB.', 102), Value('Data side hits in the VTLB.', 103), Value('TLBWR writes to the VTLB.', 104), Value('DTLB hits to the half of EntryLo that caused a fill (speculative)', 105), Value('Pairs of fused stores at graduation', 106), Value('Reserved', 107, '', True), Value('Times a load is not issued because it is tagged by the over-eager predictor', 108), Value('Speculative count of incorrectly bonded loads and stores.', 109), Value('Misaligned loads that graduated', 110), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Cycles where one FP/MSA opcode is issued.', 113), Value('Cycles where two FP/MSA opcodes are issued.', 114), Value('Data-side unmapped XKPhys accesses.', 115), Value('Cycles where one FP/MSA opcode is retired.', 116), Value('Cycles where two FP/MSA opcodes are simultaneously retired.', 117), Value('Cycles where FPU/MSA shelf is full.', 118), Value('Load and stores graduated with VA[13:12] != PA[13:12]. Misaligned stores counted as two.', 119), Value('Number of noRFO stores graduated.', 120), Value('Refetches for integer misaligned instructions.', 121), Value('Doubleword bonded speculative loads.', 122), Value('Quadword bonded speculative loads.', 123), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Hardware table walker (HTW) abort due to HTW access denied to XKSeg (XK = 0).', 126), Value('Reserved', 127, '', True), Value('Root exceptions taken in guest mode.', 128), Value('GSFC exceptions..', 129), Value('GPSI exceptions.', 130), Value('Hypercall exceptions.', 131), Value('Root TLB exceptions caused by instruction-side guest translation requests.', 132), Value('Root writes that set the Guest.Cause.TI bit to 1.', 133), Value('Guest accesses to the Watch registers that cause GPSI when virtually shared.', 134), Value('Interrupts that cause a guest exit in EIC mode.', 135), Value('Data side hardware page table walks aborted due to an exception or branch mispredict related to an older instruction.', 136), Value('Instruction or data side hardware page table walks aborted because a related table walk load has missed in the main TLB.', 137), Value('An instruction or data side hardware page table walk has been initiated.', 138), Value('Dependent instructions replayed in ALU2/MDU due to load miss.', 139), Value('Dependent instructions replayed in ALU1 pipe due to load miss.', 140)]),
                                   Field('IE', Bits(4), 'Set to cause an interrupt when the counter overflows into bit 31. This c     an either be used to implement an extended count or (by presetting the counter appropriately) to notify software after a certain number of events have occurred.'),
                                   Field('U', Bits(3), 'Count events in User mode. When this bit is set, events can be counted in User mode.'),
                                   Field('S', Bits(2), 'Count events in Supervisor mode. When this bit is set, events can be counted in Supervisor mode.'),
                                   Field('K', Bits(1), 'Count events in Kernel mode. When this bit is set, events can be counted in Kernel mode.'),
                                   Field('EXL', Bits(0), 'Count events in Exception mode. When this bit is set, events can be counted in Exception mode (when StatusEXL is set).')],
                       'ProAptiv.*': [Field('M', Bits(31), 'Set to 1 if there is another PerfCtl register after this one. This field is set for PerfCtl0-2 and cleared on PerfCtl3.'),
                                      Field('Reserved', Bits(30, 16), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                      Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                      Field('Reserved', Bits(14, 12), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                      Field('Event', Bits(11, 5), 'Determines which event to count', [Value('Cycles', 0), Value('Instructions graduated', 1), Value("'jr $31' (return) instructions whose target is predicted", 2), Value('Cycles where no instruction is fetched because no next addr candidate, or after a wait', 3), Value('ITLB accesses', 4), Value('Reserved', 5, '', True), Value('Instruction Cache accesses.', 6), Value('Cycles where no instruction is fetched because it missed I-Cache', 7), Value('Uncached Instruction Fetch stall cycles', 8), Value('IFU fetch stalls due to lack of credits on the IBUF interface', 9), Value('Store misses transitioning to I-M or S-M (multi-core only)', 10, 'Reserved in single-core.'), Value('Cycles IFU-IDU gate is closed due to mispredicted branch', 11), Value('Cycles IFU-IDU gate is closed due to: MTC0/MFC0 sequence in pipe, EHB, DD_DR_DS is blocked', 12), Value('Cycles where no instruction is inserted in DDQ0 because it is full', 13), Value('Cycles where no instructions can be issued because there are no completion buffer ID?', 14), Value('Cycles where no instructions can be added to the issue pool, because we have used all the FIFO entries in the CLDQ', 15), Value('Reserved', 16, '', True), Value('Reserved', 17, '', True), Value('Cycles when three instructions are issued', 18), Value('Reserved', 19, '', True), Value('Cycles when one instruction is issued', 20), Value('jr (not $31) instructions mispredicted at graduation', 21), Value('Graduated JAR/JALR.HB', 22), Value('Counts the number of speculative loads. Pairs of loads or stores that are fused count as one', 23), Value('Data cache misses at graduation', 24), Value('D-side JTLB translation fails', 25), Value('Load/store instruction redirects', 26), Value('LSGB graduation blocked cycles', 27), Value('L2 cache writebacks', 28), Value('L2 cache misses', 29), Value('Cycles Fill Store Buffer(FSB) are full and cause a pipe stall', 30), Value('Cycles Load Data Queue (LDQ) are full and cause a pipe stall', 31), Value('Cycles Writeback Buffer(WBB) are full and cause a pipe stall', 32), Value('Counts requests that will receive data from the CM (multi-core only)', 33, 'Reserved in single-core.'), Value('Invalidate intervention hits (multi-core only)', 34, 'Reserved in single-core.'), Value('Replays following optimistic issue of instruction dependent on load which missed.', 35), Value('jr (not $31) instructions graduated', 36), Value('Integer Branch instructions graduated', 37), Value('Branch-likely instructions graduated', 38), Value('Conditional branches graduated', 39), Value('Integer instructions graduated', 40), Value('Loads graduated. Fused load/store counted as 2', 41), Value("'j'/'jal' graduated", 42), Value('No-ops graduated - included (sll, nop, ssnop, ehb)', 43), Value('DSP instructions graduated', 44), Value('DSP branch instructions graduated', 45), Value('Uncached loads graduated', 46), Value('Writebacks due to evictions (multi-core only)', 47, 'Reserved in single-core.'), Value('Count of all invalidates (M,E,S)-I (multi-core only)', 48, 'Reserved in single-core.'), Value('EJTAG instruction triggers', 49), Value('CP1 branches mispredicted', 50), Value("'sc' instructions graduated", 51), Value("'prefetch' instructions graduated at the top of LSGB", 52), Value('Cycles where no instructions graduated', 53), Value('Cycles where one instruction graduated', 54), Value('GFifo blocked cycles', 55), Value('GFifo blocked due to TLB or Cacheop', 56), Value('Mispredicted branch instruction graduation cycles without the delay slot', 57), Value('Exceptions taken', 58), Value('Implementation-specific CorExtend event', 59), Value('State transition from S-M (coherent and non-coh) (multi-core only)', 60, 'Reserved in single-core.'), Value('Request latency to self-intervention (multi-core only)', 61, 'Reserved in single-core.'), Value('Implementation-specific event from ISPRAM block', 62), Value('L2 single-bit errors detected', 63), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('All OCP requests accepted', 68), Value('OCP read requests accepted', 69), Value('OCP write requests accepted', 70), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('OCP Intervention write data stalled (valid but not accepted) (multi-core only)', 73, 'Reserved in single-core.'), Value('Cycles Fill Store Buffer(FSB) < 1/4 full', 74), Value('Cycles Load Data Queue (LDQ) < 1/4 full', 75), Value('Cycles Writeback Buffer(WBB) < 1/4 full', 76), Value('Times that the L1BTB caused a redirect without IFU predecode-based prediction', 77), Value('Times that the L1BTB caused a redirect with IFU predecode-based prediction', 78), Value('Writes to the RPS portion of the L1BTB with no L1BTB hit (cold miss).', 79), Value('L1 Branch Target Buffer masked hits due to lack of credit for DS', 80), Value('NFW or L1 Branch Target Buffer mispredicts for instruction cache way-hit prediction', 81), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Times a WBB entry is newly allocated for an UCA store and there is one UCA store already active in the WBB', 84), Value('Times an uncached instruction arrives at BIU while there is an actively gathering UCA buffer', 85), Value('Reserved', 86, '', True), Value('Stall cycles due to the lack of load/store queue (LSQ) ID', 87), Value('Stall cycles due to the lack of DSP ID', 88), Value('Cycles when no FP instructions are dispatched', 89), Value('Cycles when one FP instruction is dispatched', 90), Value('Cycles when two FP instructions are dispatched', 91), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Cycles when three instructions are issued', 94), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Instructions issued on AGU port from DDQ1', 97), Value('Instructions issued on MDU/ALU2 port from DDQ1', 98), Value('DTLB accesses (speculative)', 99), Value('Data side hits in the VTLB/FTLB. This includes FTLB and VTLB hits and unmapped region accesses', 100), Value('Data side hits in the VTLB/FTLB in an unmapped region', 101), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('DTLB hits to the half of EntryLo that caused a fill (speculative)', 105), Value('Pairs of fused stores at graduation', 106), Value('Reserved', 107, '', True), Value('Times a load is not issued because it is tagged by the over-eager predictor', 108), Value('Speculative count of incorrectly fused loads and stores', 109), Value('Misaligned loads that graduated', 110), Value('Reserved', 111, '', True), Value('Cycles that the arithmetic channel is full and signalling busy to the integer core', 112), Value('Arithmetic instructions issued', 113), Value('Add/multiply class instructions (add, sub, cvt, ceil, floor, round, trunc, mul)', 114), Value('Arithmetic iteration class instructions (div, recip, sqrt, rsqrt)', 115), Value('Arithmetic miscellaneous class instructions (abs, neg, alnv, pll, move, bra)', 116), Value('The retire stage is stalled if there is an older arithmetic to-from instruction in the other channel with the same FD', 117), Value('Arithmetic channel kill received stalls.', 118), Value('Arithmetic channel result valid stalls', 119), Value('Arithmetic channel instruction issue stalls', 120), Value('Arithmetic channel retire stall cycles', 121), Value('Arithmetic channel indeterminate dependency or format mismatch stalls', 122), Value('Arithmetic channel APU stalls', 123), Value('Arithmetic channel arithmetic data stalls', 124), Value('Arithmetic channel to data stalls', 125), Value('Arithmetic channel stalls due to a pipecleaner instruction', 126), Value('All arithmetic channel issue stall cycles', 127)]),
                                      Field('IE', Bits(4), 'Set to cause an interrupt when the counter overflows into bit 31. This can either be used to implement an extended count or (by presetting the counter appropriately) to notify software after a certain number of events have occurred.'),
                                      Field('U', Bits(3), 'Count events in User mode. When this bit is set, events can be counted in User mode.'),
                                      Field('S', Bits(2), 'Count events in Supervisor mode. When this bit is set, events can be counted in Supervisor mode.'),
                                      Field('K', Bits(1), 'Count events in Kernel mode. When this bit is set, events can be counted in Kernel mode.'),
                                      Field('EXL', Bits(0), 'Count events in Exception mode. When this bit is set, events can be counted in Exception mode (when StatusEXL is set).')]},
 'Perf_control_odd': {'': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                           Field('0', Bits(30, 12), 'Reserved.'),
                           Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch mispredictions', 2), Value("'jr $31' mispredictions", 3), Value("'jr $31' not predicted", 4), Value('ITLB misses', 5), Value('DTLB misses', 6), Value('JTLB instruction misses', 7), Value('JTLB data misses', 8), Value('Instruction cache misses', 9), Value('Data cache writebacks', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Load Misses', 13), Value('FPU instructions completed', 14), Value('Stores completed', 15), Value('MIPS16 instructions completed', 16), Value('Integer multiply/divide completed', 17), Value('Replay traps (other than uTLB)', 18), Value("'sc' instructions failed", 19), Value("'prefetch' instructions completed with cache hit", 20), Value('L2 cache accesses', 21), Value('Single-bit errors corrected in L2', 22), Value('Reserved', 23, '', True), Value('Reserved', 24, '', True), Value('ALU stall cycles', 25), Value('ALU-DSP Saturations Done', 26), Value('MDU-DSP Saturations Done', 27), Value('Available for customer CP2 event', 28), Value('Available for customer DSPRAM event', 29), Value('Reserved', 30, '', True), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Uncached Stores', 33), Value('Reserved', 34, '', True), Value('CP2 To/From Instructions completed', 35), Value('Reserved', 36, '', True), Value('D$ miss stall cycles', 37), Value('FSB Index Conflict Stalls', 38), Value('L2 miss cycles', 39), Value('Reserved', 40, '', True), Value('FPU stall cycles', 41), Value('CorExtend stall cycles', 42), Value('DSPRAM stall cycles', 43), Value('Reserved', 44, '', True), Value('ALU to AGEN stalls cycles', 45), Value('Branch mispredict stall cycles', 46), Value('Reserved', 47, '', True), Value('Fill Buffer entry allocated', 48), Value('EJTAG data triggers', 49), Value('FSB (Fill-Store Buffer) 1/4-1/2 full', 50), Value('FSB (Fill-Store Buffer) full pipeline stalls', 51), Value('LDQ (Load Data Queue) 1/4-1/2 full', 52), Value('LDQ (Load Data Queue) full pipeline stalls', 53), Value('WBB (Write Back Buffer) 1/4-1/2 full', 54), Value('WBB (Write Back Buffer) full pipeline stall cycles', 55), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('Reserved', 68, '', True), Value('Reserved', 69, '', True), Value('Reserved', 70, '', True), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Reserved', 73, '', True), Value('Reserved', 74, '', True), Value('Reserved', 75, '', True), Value('Reserved', 76, '', True), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                           Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                           Field('U', Bits(3), 'Count events in user mode.'),
                           Field('S', Bits(2), 'Count events in supervisor mode.'),
                           Field('K', Bits(1), 'Count events in kernel mode.'),
                           Field('EXL', Bits(0), 'Count events in exception-mode.')],
                      '1004K.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                  Field('0', Bits(30), 'Reserved.'),
                                  Field('TCID', Bits(29, 22), 'Which TCs events should we count?.'),
                                  Field('MT_EN', Bits(21, 20), 'Select just-this-VPE or just-this-TC counting.', [Value('Count events from all TCs & VPEs', 0), Value('Count events from all TCs of the VPE specified in VPEID', 1), Value('Count events from the TC specified in TCID', 2), Value('Reserved', 3, '', True)]),
                                  Field('VPEID', Bits(19, 16), 'Which VPEs events should we count?'),
                                  Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                  Field('0', Bits(14, 12), 'Reserved.'),
                                  Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch mispredictions', 2), Value("'jr $31' predicted but guessed wrong", 3), Value("'jr $31' not predicted", 4), Value('ITLB misses', 5), Value('DTLB misses', 6), Value('JTLB instruction misses', 7), Value('JTLB data misses', 8), Value('Instruction cache misses', 9), Value('Data cache writebacks', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Load Misses', 13), Value('FPU instructions completed', 14), Value('Stores completed', 15), Value('MIPS16 instructions completed', 16), Value('Integer multiply/divide unit instructions completed', 17), Value('Replay traps (other than uTLB)', 18), Value("'sc' instructions failed", 19), Value("'prefetch' instructions completed with cache hit", 20), Value('L2 cache accesses', 21), Value('L2 cache single bit errors corrected', 22), Value('Single Threaded Mode', 23), Value('Refetches', 24), Value('ALU stall cycles', 25), Value('ALU-DSP Saturations Done', 26), Value('MDU-DSP Saturations Done', 27), Value('Available for customer CP2 event', 28), Value('Available for customer DSPRAM event', 29), Value('Reserved', 30, '', True), Value('Custom ITC event', 31), Value('ITC Stores issued: Invisible retries counted too, as for loads', 32), Value('Uncached Stores', 33), Value('YIELD instructions completed', 34), Value('CP2 To/From Instns completed', 35), Value('Intervention response stalled on miss', 36), Value('D$ miss stall cycles', 37), Value('Reserved', 38, '', True), Value('L2 miss cycles', 39), Value('ITC stall cycles', 40), Value('FPU stall cycles', 41), Value('CorExtend stall cycles', 42), Value('DSPRAM stall cycles', 43), Value('Long stall cycles', 44), Value('ALU to AGEN stalls cycles', 45), Value('Branch mispredict stall cycles', 46), Value('Reserved', 47, '', True), Value('Fill Buffer entry allocated', 48), Value('EJTAG data triggers', 49), Value('FSB (Fill-Store Buffer) 1/4-1/2 full', 50), Value('FSB (Fill-Store Buffer) full pipeline stalls', 51), Value('LDQ (Load Data Queue) 1/4-1/2 full', 52), Value('LDQ (Load Data Queue) full pipeline stalls', 53), Value('WBB (Write Back Buffer) 1/4-1/2 full', 54), Value('Cycles when whole CPU stopped because all write buffers are full', 55), Value('Coherent Event: All Interventions', 56), Value('Coherent Event: Invalidate Hits', 57), Value('Coherent Event: Writebacks', 58), Value('Coherent Event: ST_Exclusive', 59), Value('Coherent Event: ST_Downgrade', 60), Value('Latency Event: Request Count for SI Latency', 61), Value('Latency Event: Request Count for RR Latency', 62), Value('Reserved', 63, '', True), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('Reserved', 68, '', True), Value('Reserved', 69, '', True), Value('Reserved', 70, '', True), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Reserved', 73, '', True), Value('Reserved', 74, '', True), Value('Reserved', 75, '', True), Value('Reserved', 76, '', True), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                  Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                  Field('U', Bits(3), 'Count events in user mode.'),
                                  Field('S', Bits(2), 'Count events in supervisor mode.'),
                                  Field('K', Bits(1), 'Count events in kernel mode.'),
                                  Field('EXL', Bits(0), 'Count events in exception-mode.')],
                      '1074K.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                  Field('0', Bits(30, 16), 'Reserved.'),
                                  Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                  Field('0', Bits(14, 12), 'Reserved.'),
                                  Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions graduated', 1), Value("'jr $31' predicted but guessed wrong", 2), Value("'jr $31' (return) instructions fetched and not predicted using RPS", 3), Value('ITLB misses, which result in a JTLB access', 4), Value('JTLB instruction access fails (will lead to an exception)', 5), Value('I-Cache misses: Includes misses resulting from fetch-ahead, speculation', 6), Value('Reserved', 7, '', True), Value('PDTrace back stalls', 8), Value('Valid fetch slots killed in the IFU due to brnch/jumps', 9), Value('Load misses transitioning to I-S or I-E', 10), Value('Reserved', 11, '', True), Value('Intervention hits', 12), Value('Cycles when no instr: can be added to AGEN issue pool; pool full', 13), Value('Cycles when no instr: can be added to AGEN issue pool; no AGEN CBs', 14), Value('Cycles when no instr: can be added to issue pool; in order FIFO full', 15), Value('Cycles with no AGEN-pipe issue: no instructions available', 16), Value('Cycles with no AGEN-pipe issue: we have instructions: but operands not ready', 17), Value('Cycles with no AGEN-pipe issue: we have load(s) with operands ready, but ...', 18), Value('AGEN-pipe bubble issued', 19), Value('Cycles when two instructions are issued (one ALU, one AGEN)', 20), Value('Out-of-order AGEN issue', 21), Value('D-Cache line refill (not LD/ST misses)', 22), Value('All D-cache accesses (loads, stores, prefetch, cacheop etc)', 23), Value('D-Cache misses', 24), Value('D-side JTLB translation fails', 25), Value('D-cache auxiliary virtual tag bogus misses...', 26), Value('Reserved', 27, '', True), Value('L2 cache accesses', 28), Value('L2 cache misses', 29), Value('FSB (Fill-Store Buffer) > 1/2 full', 30), Value('LDQ (Load Data Queue) > 1/2 full', 31), Value('WBB (Write Back Buffer) > 1/2 full', 32), Value('Request latency to first DW of data from the CM', 33), Value('All invalidate interventions', 34), Value('Floating Point Load instructions graduated', 35), Value("'jr $31' graduated after mispredict", 36), Value('CP1/CP2 conditional branch instructions graduated', 37), Value('Mispredicted branch-likely instructions graduated', 38), Value('Mispredicted branches graduated', 39), Value('FPU instructions graduated (but not counting FPU load/store)', 40), Value('Stores graduated, including FP: Only successful sc instructoins counted', 41), Value('MIPS16 instructions graduated', 42), Value('Integer multiply/divides graduated', 43), Value('ALU-DSP graduated, result was saturated', 44), Value('MDU-DSP graduated, result was saturated', 45), Value('Uncached stores graduated', 46), Value('Writebacks due to any reason', 47), Value('Count of transitions from (I,S)-E', 48), Value('EJTAG data triggers', 49), Value('Reserved', 50, '', True), Value('Store conditional (sc) instructions failed', 51), Value("'prefetch' instructions which did nothing; hit in the cache", 52), Value('Load misses graduated', 53), Value('Cycles where two instructions graduated', 54), Value('Floating point stores graduated', 55), Value('Cycles 0 instructions graduated from', 56), Value('Cycles waiting for delayslot to graduate on a mispredicted branch', 57), Value('Replays initiated from graduation', 58), Value('Reserved', 59, '', True), Value('State transitions from (M,E)-S', 60), Value('Count of requests that will receive self-intervention', 61), Value('Implementation-specific DSPRAM event', 62), Value('All interventions', 63), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('All OCP cacheable requests accepted', 68), Value('OCP cacheable read requests accepted', 69), Value('OCP cacheable write requests accepted', 70), Value('OCP write data sent', 71), Value('OCP read data received', 72), Value('Reserved', 73, '', True), Value('Cycles Fill Store Buffer(FSB) 1/4 to 1/2 full', 74), Value('Cycles Load Data Queue (LDQ) 1/4 to 1/2 full', 75), Value('Cycles Writeback Buffer(WBB) 1/4 to 1/2 full', 76), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                  Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                  Field('U', Bits(3), 'Count events in user mode.'),
                                  Field('S', Bits(2), 'Count events in supervisor mode.'),
                                  Field('K', Bits(1), 'Count events in kernel mode.'),
                                  Field('EXL', Bits(0), 'Count events in exception-mode.')],
                      '34K.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                Field('0', Bits(30), 'Reserved.'),
                                Field('TCID', Bits(29, 22), 'Which TCs events should we count?.'),
                                Field('MT_EN', Bits(21, 20), 'Select just-this-VPE or just-this-TC counting.', [Value('Count events from all TCs & VPEs', 0), Value('Count events from all TCs of the VPE specified in VPEID', 1), Value('Count events from the TC specified in TCID', 2), Value('Reserved', 3, '', True)]),
                                Field('VPEID', Bits(19, 16), 'Which VPEs events should we count?'),
                                Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                Field('0', Bits(14, 12), 'Reserved.'),
                                Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch mispredictions', 2), Value("'jr $31' mispredictions", 3), Value("'jr $31' not predicted", 4), Value('ITLB misses', 5), Value('DTLB misses', 6), Value('JTLB instruction misses', 7), Value('JTLB data misses', 8), Value('Instruction cache misses', 9), Value('Data cache writebacks', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Load Misses', 13), Value('FPU instructions completed', 14), Value('Stores completed', 15), Value('MIPS16 instructions completed', 16), Value('Integer multiply/divide completed', 17), Value('Replay traps (other than uTLB)', 18), Value("'sc' instructions failed", 19), Value("'prefetch' instructions completed with cache hit", 20), Value('L2 cache accesses', 21), Value('Single-bit errors corrected in L2', 22), Value('Single Threaded Mode', 23), Value('Refetches', 24), Value('ALU stall cycles', 25), Value('ALU-DSP Saturations Done', 26), Value('MDU-DSP Saturations Done', 27), Value('Available for customer CP2 event', 28), Value('Available for customer DSPRAM event', 29), Value('Reserved', 30, '', True), Value('Custom ITC event', 31), Value('ITC Stores', 32), Value('Uncached Stores', 33), Value('YIELD instructions completed', 34), Value('CP2 To/From Instructions completed', 35), Value('Reserved', 36, '', True), Value('D-Cache miss stall cycles', 37), Value('FSB Index Conflict Stalls', 38), Value('L2 miss cycles', 39), Value('ITC stall cycles', 40), Value('FPU stall cycles', 41), Value('CorExtend stall cycles', 42), Value('DSPRAM stall cycles', 43), Value('Long stall cycles', 44), Value('ALU to AGEN stalls cycles', 45), Value('Branch mispredict stall cycles', 46), Value('Reserved', 47, '', True), Value('Fill Buffer entry allocated', 48), Value('EJTAG data triggers', 49), Value('FSB (Fill-Store Buffer) 1/4-1/2 full', 50), Value('FSB (Fill-Store Buffer) full pipeline stalls', 51), Value('LDQ (Load Data Queue) 1/4-1/2 full', 52), Value('LDQ (Load Data Queue) full pipeline stalls', 53), Value('WBB (Write Back Buffer) 1/4-1/2 full', 54), Value('WBB (Write Back Buffer) full pipeline stall cycles', 55), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('Reserved', 68, '', True), Value('Reserved', 69, '', True), Value('Reserved', 70, '', True), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Reserved', 73, '', True), Value('Reserved', 74, '', True), Value('Reserved', 75, '', True), Value('Reserved', 76, '', True), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                Field('U', Bits(3), 'Count events in user mode.'),
                                Field('S', Bits(2), 'Count events in supervisor mode.'),
                                Field('K', Bits(1), 'Count events in kernel mode.'),
                                Field('EXL', Bits(0), 'Count events in exception-mode.')],
                      '74K.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                Field('0', Bits(30, 16), 'Reserved.'),
                                Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                Field('0', Bits(14, 12), 'Reserved.'),
                                Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions graduated', 1), Value("'jr $31' predicted but guessed wrong", 2), Value("'jr $31' (return) instructions fetched and not predicted using RPS", 3), Value('ITLB misses, when the I-side requests a JTLB access', 4), Value('JTLB instruction access fails (will lead to an exception)', 5), Value('I-Cache misses: Includes misses resulting from fetch-ahead, speculation', 6), Value('Reserved', 7, '', True), Value('PDTrace back stalls', 8), Value('Valid fetch slots killed due to taken branches/jumps or stalling instructions', 9), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Cycles where no instructions are brought into the IDU because the AGEN instruction candidate pool is full', 13), Value("Cycles where no instructions can be added to the issue pool because we have run out of AGEN completion buffers (CB's)", 14), Value('Cycles where no instructions can be added to the issue pool, because we have filled the in order FIFO used for coprocessor 1 instructions (IOIQ)', 15), Value('Cycles with no AGEN-pipe issue: no instructions available', 16), Value('Cycles with no AGEN-pipe issue: we have instructions: but operands not ready', 17), Value('Cycles with no AGEN-pipe issue: we have instructions, but some resource is unavailable', 18), Value('AGEN-pipe bubble issued', 19), Value('Cycles when two instructions are issued (one ALU, one AGEN)', 20), Value('Out-of-order AGEN issue', 21), Value('D-Cache line refill (not LD/ST misses)', 22), Value('All D-cache accesses (loads, stores, prefetch, cacheop etc)', 23), Value('D-Cache misses', 24), Value('D-side JTLB translation fails', 25), Value('D-cache auxiliary virtual tag bogus misses...', 26), Value('Reserved', 27, '', True), Value('L2 cache accesses', 28), Value('L2 cache misses', 29), Value('Cycles Fill Store Buffer(FSB) > 1/2 full', 30), Value('Cycles Load Data Queue(LDQ) > 1/2 full', 31), Value('Cycles Writeback Buffer(WBB) > 1/2 full', 32), Value('Reserved', 33, '', True), Value('Reserved', 34, '', True), Value('Floating Point Load instructions graduated', 35), Value("'jr $31' graduated after mispredict", 36), Value('Floating Point Branch instructions graduated', 37), Value('Mispredicted branch-likely instructions graduated', 38), Value('Mispredicted Conditional branches graduated', 39), Value('FPU instructions graduated (but not counting FPU load/store)', 40), Value('Stores graduated, including FP: Only successful sc instructoins counted', 41), Value('MIPS16 instructions graduated', 42), Value('Integer multiply/divides graduated', 43), Value('ALU-DSP graduated, result was saturated', 44), Value('MDU-DSP graduated, result was saturated', 45), Value('Uncached stores graduated', 46), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('Reserved', 49, '', True), Value('CP2 branches mispredicted', 50), Value('Store conditional (sc) instructions failed', 51), Value("'prefetch' instructions which did nothing; hit in the cache", 52), Value('Load misses graduated', 53), Value('Cycles where two instructions graduated', 54), Value('Floating point stores graduated', 55), Value('Cycles 0 instructions graduated cycles from the time a pipekill happened due to replay until the first new instruction graduates', 56), Value('Cycles waiting for delayslot to graduate on a mispredicted branch', 57), Value('Replays initiated from graduation', 58), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved for CP2 event', 61), Value('Reserved', 62, '', True), Value('Implementation-specific DSPRAM event. The integrator of this core may connect the pin SP_prf_c13_e62_xx to the event to be counted', 63), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('All OCP cacheable requests accepted', 68), Value('OCP cacheable read requests accepted', 69), Value('OCP cacheable write requests accepted', 70), Value('OCP write data sent', 71), Value('OCP read data received', 72), Value('Reserved', 73, '', True), Value('Cycles Fill Store Buffer(FSB) 1/4 to 1/2 full', 74), Value('Cycles Load Data Queue (LDQ) 1/4 to 1/2 full', 75), Value('Cycles Writeback Buffer(WBB) 1/4 to 1/2 full', 76), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                Field('U', Bits(3), 'Count events in user mode.'),
                                Field('S', Bits(2), 'Count events in supervisor mode.'),
                                Field('K', Bits(1), 'Count events in kernel mode.'),
                                Field('EXL', Bits(0), 'Count events in exception-mode.')],
                      'I6[45]00.*': [Field('M', Bits(31), "This field is set to 1 as another pair of Performance Counter Control and Counter registers     is implemented at an MTC0 or MFC0 select field value of 'n+2' and 'n+3'."),
                                     Field('W', Bits(30), 'Specifies the width of the corresponding Counter register. This field is set to 0 as the     width of the corresponding Counter register is 32 bits'),
                                     Field('Impl', Bits(29, 25), 'Implementation dependent. These bits are implementation dependent and not defined by the     architecture. These bits are not used by this implementation.'),
                                     Field('EC', Bits(24, 23), 'VZ'),
                                     Field('PCTD', Bits(15), 'Performance Counter Trace Disable.'),
                                     Field('Event', Bits(12, 5), 'Selects the event to be counted by the corresponding Counter Register. The list of     events is implementation dependent, but typical events include cycles, instructions,     memory reference instructions, branch instructions, cache and TLB misses, etc.     Implementations that support multiple performance counters allow ratios of events,     e.g., cache miss ratios if cache miss and memory references are selected as the events     in two counters', [Value('Number of clock cycles', 0), Value('Number of graduated instructions', 1), Value('Number of cycles in which one instruction graduated', 2), Value('Number of cycles in which two instructions graduated', 3), Value('Number of cycles in which no instructions graduated', 4), Value('Number of ALU instructions graduated', 5), Value('Number of LSU instructions graduated', 6), Value('Number of CTI instructions graduated', 7), Value('Number of MDU instructions graduated', 8), Value('Number of FPU instructions graduated', 9), Value('Number of MSA instructions graduated', 10), Value('Number of Load instructions graduated', 11), Value('Number of Store instructions graduated', 12), Value('Number of cycle in which no instructions got issued', 13), Value('Number of cycles in which one instruction got issued', 14), Value('Number of cycles in which two instructions got issued', 15), Value('Number of times the Issue unit got stalled', 16), Value('Number of times the Decoder unit got stalled', 17), Value('Number of times the Dependency Mapper Unit got stalled', 18), Value('Cycles in which instruction buffer is empty', 19), Value('Replays initiated by the scoreboard', 20), Value('Number of conditional branches graduated', 21), Value('mispredicted conditional branches graduated', 22), Value('Returns (JR $31) graduated', 23), Value('Mispredicted Returns (JR $31) graduated', 24), Value('JR graduated', 25), Value('Mispredicted JR graduated', 26), Value('Taken conditional branches graduated ', 27), Value('Not taken conditional branches graduated', 28), Value('Total redirects', 29), Value('Total number of exceptions', 30), Value('Number of cycles an Icache miss is solely responsible for stalling the pipe', 31), Value('Number of cycles graduation was blocked because of a load waiting to complete', 32), Value('Number of cycles graduation was blocked because of sync waiting to complete', 33), Value('DTLB Lookups', 64), Value('DTLB Misses (new)', 65), Value('DTLB Misses (merged with existing)', 66), Value('Bonded Load', 67), Value('Bonded Store', 68), Value('Total number of cache lookups', 69), Value('Number of Load-type instructions', 70), Value('Number of Store-type instructions', 71), Value('Misses cache lookup', 72), Value('Loads miss cache lookup', 73), Value('Stores miss cache lookup', 74), Value('Number of cycles SDB graduation was blocked due to SMB full', 75), Value('All VPs currently stalled (for any reason)', 128), Value('VP accessed the uTLB', 129), Value('VP stalled waiting for MMU response to uTLB', 130), Value('VP access to uTLB caused a uTLB Miss', 131), Value('VP accessed the I$', 132), Value('VP access to the I$ resulted in cache miss', 133), Value('VP stalled waiting for IBuffer credit', 134), Value('VP stalled waiting for PCBuffer credit', 135), Value('VP stalled (for any reason)', 136)]),
                                     Field('IE', Bits(4), 'Interrupt Enable. Enables the interrupt request when the corresponding counter overflows     (the most-significant bit of the counter is one. This is bit 31 for a 32-bit wide     counter or bit 63 of a 64-bit wide counter, denoted by the W bit in this register).     Note that this bit simply enables the interrupt request. The actual interrupt is still     gated by the normal interrupt masks and enable in the Status register.', [Value('Performance counter interrupt disabled', 0), Value('Performance counter interrupt enabled', 1)]),
                                     Field('U', Bits(3), 'Enables event counting in User Mode.', [Value('Disable counting', 0), Value('Enable counting', 1)]),
                                     Field('S', Bits(2), 'Enables event counting in Supervisor Mode.', [Value('Disable counting', 0), Value('Enable counting', 1)]),
                                     Field('K', Bits(1), 'Enables event counting in Kernel Mode. This bit enables event counting only when     the EXL and ERL bits in the Status register are zero.', [Value('Disable counting', 0), Value('Enable counting', 1)]),
                                     Field('EXL', Bits(0), 'Enables event counting when the EXL bit in the Status register is one and the ERL bit     in the Status register is zero.', [Value('Disable counting', 0), Value('Enable counting', 1)])],
                      'InterAptiv.*': [Field('M', Bits(31), 'If this bit is one, another pair of Performance Control and Counter registers is implemented at a MTC0 or MFC0 select field value of +2 and +3'),
                                       Field('0', Bits(30), 'Must be written as zero; returns zero on read.'),
                                       Field('TCID', Bits(29, 22), 'Specifies which TC events should be counted for if per-TC counting is enabled.'),
                                       Field('MT_EN', Bits(21, 20), 'Specify just-this-VPE or just-this-TC counting.', [Value('Count events from all TCs and VPEs', 0), Value('Count events from all TCs of the VPE specified in VPEID', 1), Value('Count events from the TC specified in TCID', 2), Value('Reserved', 3, '', True)]),
                                       Field('VPEID', Bits(19, 16), 'Specifies which VPE events should be counted if per-VPE counting is enabled.'),
                                       Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                       Field('0', Bits(14, 12), 'Must be written as zero; returns zero on read.'),
                                       Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Branch mispredictions', 2), Value("'jr $31' predicted but guessed wrong", 3), Value("'jr $31' not predicted", 4), Value('ITLB misses', 5), Value('DTLB misses', 6), Value('JTLB instruction misses', 7), Value('JTLB data misses', 8), Value('Instruction cache misses', 9), Value('Data cache writebacks', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Load Misses', 13), Value('FPU instructions completed', 14), Value('Stores completed', 15), Value('MIPS16 instructions completed', 16), Value('Integer multiply/divide unit instructions completed', 17), Value('Replay traps (other than uTLB)', 18), Value("'sc' instructions failed", 19), Value("'prefetch' instructions completed with cache hit", 20), Value('L2 cache accesses', 21), Value('L2 cache single bit errors corrected', 22), Value('Single Threaded Mode', 23), Value('Refetches', 24), Value('ALU stall cycles', 25), Value('ALU-DSP Saturations Done', 26), Value('MDU-DSP Saturations Done', 27), Value('Available for customer CP2 event', 28), Value('Available for customer DSPRAM event', 29), Value('Reserved', 30, '', True), Value('Custom ITC event', 31), Value('ITC Stores', 32), Value('Uncached Stores', 33), Value('YIELD instructions completed', 34), Value('CP2 To/From instructions completed', 35), Value('Intervention response stalled on miss', 36), Value('D$ miss stall cycles', 37), Value('FSB stall cycles', 38), Value('L2 miss cycles', 39), Value('ITC stall cycles', 40), Value('FPU stall cycles', 41), Value('CorExtend stall cycles', 42), Value('DSPRAM stall cycles', 43), Value('Long stall cycles', 44), Value('ALU to AGEN stalls cycles', 45), Value('Branch mispredict stall cycles', 46), Value('Corrected ECC errors in the L1 Data Cache or DSPRAM', 47), Value('Fill Buffer entry allocated', 48), Value('EJTAG data triggers', 49), Value('FSB (Fill-Store Buffer) 1/4-1/2 full', 50), Value('FSB (Fill-Store Buffer) full pipeline stalls', 51), Value('LDQ (Load Data Queue) 1/4-1/2 full', 52), Value('LDQ (Load Data Queue) full pipeline stalls', 53), Value('WBB (Write Back Buffer) 1/4-1/2 full', 54), Value('WBB (Write Back Buffer) full pipeline stall cycles', 55), Value('Coherent Event: All Interventions', 56), Value('Coherent Event: Invalidate Hits', 57), Value('Coherent Event: Writebacks', 58), Value('Coherent Event: ST_Exclusive', 59), Value('Coherent Event: ST_Downgrade', 60), Value('Latency Event: Request Count for SI Latency', 61), Value('Latency Event: Request Count for Read Response Latency', 62), Value('Reserved', 63, '', True), Value('SI_PCEvent[0] - System specific event 1', 64), Value('SI_PCEvent[0] - System specific event 3', 65), Value('SI_PCEvent[0] - System specific event 5', 66), Value('SI_PCEvent[0] - System specific event 7', 67), Value('Reserved', 68, '', True), Value('Reserved', 69, '', True), Value('Reserved', 70, '', True), Value('Reserved', 71, '', True), Value('Reserved', 72, '', True), Value('Reserved', 73, '', True), Value('Reserved', 74, '', True), Value('Reserved', 75, '', True), Value('Reserved', 76, '', True), Value('Reserved', 77, '', True), Value('Reserved', 78, '', True), Value('Reserved', 79, '', True), Value('Reserved', 80, '', True), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Reserved', 84, '', True), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Reserved', 87, '', True), Value('Reserved', 88, '', True), Value('Reserved', 89, '', True), Value('Reserved', 90, '', True), Value('Reserved', 91, '', True), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Reserved', 94, '', True), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Reserved', 97, '', True), Value('Reserved', 98, '', True), Value('Reserved', 99, '', True), Value('Reserved', 100, '', True), Value('Reserved', 101, '', True), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('Reserved', 105, '', True), Value('Reserved', 106, '', True), Value('Reserved', 107, '', True), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Reserved', 110, '', True), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True)]),
                                       Field('IE', Bits(4), 'Counter Interrupt Enable. This bit masks bit 31 of the associated count register from the interrupt exception request output.'),
                                       Field('U', Bits(3), 'Count in User Mode. When this bit is set, the specified event is counted in User Mode.'),
                                       Field('S', Bits(2), 'Count in Supervisor Mode. When this bit is set, the specified event is counted in Supervisor Mode.'),
                                       Field('K', Bits(1), 'Count in Kernel Mode. When this bit is set, count the event in Kernel Mode when EXL and ERL both are 0.'),
                                       Field('EXL', Bits(0), 'Count when EXL. When this bit is set, count the event when EXL = 1 and ERL = 0.')],
                      'M14KE,M14KEf,M14K,microAptivC.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                                          Field('0', Bits(30, 12), 'Reserved.'),
                                                          Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Stores completed (including FP)', 15), Value('MicroMIPS instructions completed', 16), Value('Integer multiply/divide unit instructions completed', 17), Value('Reserved', 18, '', True), Value("'sc' instructoins completed but store failed because link bit cleared", 19), Value('Reserved', 20, '', True), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Reserved', 23, '', True), Value('Reserved', 24, '', True), Value('ALU Stall cycles', 25), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Available for customer CP2 event', 28), Value('Reserved', 29, '', True), Value('Reserved', 30, '', True), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Reserved', 33, '', True), Value('Reserved', 34, '', True), Value('CP2 To/From Instr completed', 35), Value('Reserved', 36, '', True), Value('Reserved', 37, '', True), Value('Reserved', 38, '', True), Value('Reserved', 39, '', True), Value('Reserved', 40, '', True), Value('Reserved', 41, '', True), Value('CorExtend stall cycles', 42), Value('Reserved', 43, '', True), Value('Reserved', 44, '', True), Value('Reserved', 45, '', True), Value('Reserved', 46, '', True), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('EJTAG data triggers', 49), Value('Reserved', 50, '', True), Value('Reserved', 51, '', True), Value('Reserved', 52, '', True), Value('Reserved', 53, '', True), Value('Reserved', 54, '', True), Value('Reserved', 55, '', True), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True)]),
                                                          Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                                          Field('U', Bits(3), 'Count events in user mode.'),
                                                          Field('0', Bits(2), 'Reserved.'),
                                                          Field('K', Bits(1), 'Count events in kernel mode.'),
                                                          Field('EXL', Bits(0), 'Count events in exception-mode.')],
                      'M14KEc,M14Kc,microAptivP.*': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                                     Field('0', Bits(30, 12), 'Reserved.'),
                                                     Field('Event', Bits(11, 5), 'Which event should we count?', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('ITLB misses', 5), Value('DTLB misses', 6), Value('JTLB instruction misses', 7), Value('JTLB data misses', 8), Value('Instruction cache misses', 9), Value('Data cache writebacks', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Stores completed', 15), Value('MicroMIPS instructions completed', 16), Value('Integer multiply/divide unit instructions completed', 17), Value('Reserved', 18, '', True), Value("'sc' instructions failed", 19), Value("'prefetch' instructions completed with cache hit", 20), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Reserved', 23, '', True), Value('Reserved', 24, '', True), Value('ALU Stall cycles', 25), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Available for customer CP2 event', 28), Value('Available for customer DSPRAM event', 29), Value('Reserved', 30, '', True), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Uncached Stores', 33), Value('Reserved', 34, '', True), Value('CP2 to/from instructions completed', 35), Value('Reserved', 36, '', True), Value('D-Cache miss stall cycles', 37), Value('Reserved', 38, '', True), Value('Reserved', 39, '', True), Value('Reserved', 40, '', True), Value('Reserved', 41, '', True), Value('CorExtend stall cycles', 42), Value('DSPRAM stall cycles', 43), Value('Reserved', 44, '', True), Value('Reserved', 45, '', True), Value('Reserved', 46, '', True), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('EJTAG data triggers', 49), Value('Reserved', 50, '', True), Value('Reserved', 51, '', True), Value('LDQ (Load Data Queue) 1/4-1/2 full', 52), Value('LDQ (Load Data Queue) full pipeline stalls', 53), Value('WBB (Write Back Buffer) 1/4-1/2 full', 54), Value('WBB (Write Back Buffer) full pipline stall cycles', 55), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True)]),
                                                     Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                                     Field('U', Bits(3), 'Count events in user mode.'),
                                                     Field('0', Bits(2), 'Reserved.'),
                                                     Field('K', Bits(1), 'Count events in kernel mode.'),
                                                     Field('EXL', Bits(0), 'Count events in exception-mode.')],
                      'M5100': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                Field('0', Bits(30, 25), 'Reserved.'),
                                Field('EC', Bits(24, 23), 'Event Class.', [Value('Root events counted.', 0), Value('Root intervention events counted.', 1), Value('Guest events counted.', 2), Value('Guest events plus Root intervention events counted.', 3)]),
                                Field('0', Bits(22, 15), 'Reserved.'),
                                Field('Event', Bits(14, 5), 'Extended Event specifiers for both standard and VZ ASE.', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Stores completed (including FP)', 15), Value('MicroMIPS instructions completed', 16), Value('Integer multiply/divide unit instructions completed', 17), Value('Reserved', 18, '', True), Value("'sc' instructoins completed but store failed because link bit cleared", 19), Value('Reserved', 20, '', True), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Reserved', 23, '', True), Value('Reserved', 24, '', True), Value('ALU Stall cycles', 25), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Available for customer CP2 event', 28), Value('Reserved', 29, '', True), Value('Reserved', 30, '', True), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Reserved', 33, '', True), Value('Reserved', 34, '', True), Value('CP2 To/From Instructions completed', 35), Value('Reserved', 36, '', True), Value('Reserved', 37, '', True), Value('Reserved', 38, '', True), Value('Reserved', 39, '', True), Value('Reserved', 40, '', True), Value('Reserved', 41, '', True), Value('CorExtend stall cycles', 42), Value('Reserved', 43, '', True), Value('Reserved', 44, '', True), Value('Reserved', 45, '', True), Value('Reserved', 46, '', True), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('EJTAG data triggers', 49), Value('Reserved', 50, '', True), Value('Reserved', 51, '', True), Value('Reserved', 52, '', True), Value('Reserved', 53, '', True), Value('Reserved', 54, '', True), Value('Reserved', 55, '', True), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True), Value('Guest exits (guest mode to root mode transitions)', 128), Value('GHFC exceptions', 129), Value('GRIR exceptions', 130), Value('Guest related root TLB exceptions taken with GuestCtl0.GExcCode=GVA', 131), Value('Root TLB exceptions caused by D-side guest translation requests', 132), Value('Root writes that set Guest.PerfCnt that cause Guest.Cause.PCI to be set to 1', 133), Value('Guest accesses to PerfCtr/Ctl registers that cause GPSI when virtually shared', 134), Value('Interrupts that cause guest exit in non-EIC mode', 135)]),
                                Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                Field('U', Bits(3), 'Count events in user mode.'),
                                Field('0', Bits(2), 'Reserved.'),
                                Field('K', Bits(1), 'Count events in kernel mode.'),
                                Field('EXL', Bits(0), 'Count events in exception-mode.')],
                      'M5150': [Field('M', Bits(31), '1 unless this is the last PerfCtl register.'),
                                Field('0', Bits(30, 25), 'Reserved.'),
                                Field('EC', Bits(24, 23), 'Event Class.', [Value('Root events counted.', 0), Value('Root intervention events counted.', 1), Value('Guest events counted.', 2), Value('Guest events plus Root intervention events counted.', 3)]),
                                Field('0', Bits(22, 15), 'Reserved.'),
                                Field('Event', Bits(14, 5), 'Extended Event specifiers for both standard and VZ ASE.', [Value('Cycles', 0), Value('Instructions completed', 1), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('ITLB misses', 5), Value('DTLB misses', 6), Value('JTLB instruction misses', 7), Value('JTLB data misses', 8), Value('Instruction cache misses', 9), Value('Data cache writebacks', 10), Value('Data cache misses', 11), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Stores completed', 15), Value('MicroMIPS instructions completed', 16), Value('Integer multiply/divide unit instructions completed', 17), Value('Reserved', 18, '', True), Value("'sc' instructions failed", 19), Value("'prefetch' instructions completed with cache hit", 20), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Reserved', 23, '', True), Value('Reserved', 24, '', True), Value('ALU Stall cycles', 25), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Available for customer CP2 event', 28), Value('Available for customer DSPRAM event', 29), Value('Reserved', 30, '', True), Value('Reserved', 31, '', True), Value('Reserved', 32, '', True), Value('Uncached Stores', 33), Value('Reserved', 34, '', True), Value('CP2 to/from instructions completed', 35), Value('Reserved', 36, '', True), Value('D-Cache miss stall cycles', 37), Value('Reserved', 38, '', True), Value('Reserved', 39, '', True), Value('Reserved', 40, '', True), Value('Reserved', 41, '', True), Value('CorExtend stall cycles', 42), Value('DSPRAM stall cycles', 43), Value('Reserved', 44, '', True), Value('Reserved', 45, '', True), Value('Reserved', 46, '', True), Value('Reserved', 47, '', True), Value('Reserved', 48, '', True), Value('EJTAG data triggers', 49), Value('Reserved', 50, '', True), Value('Reserved', 51, '', True), Value('LDQ (Load Data Queue) 1/4-1/2 full', 52), Value('LDQ (Load Data Queue) full pipeline stalls', 53), Value('WBB (Write Back Buffer) 1/4-1/2 full', 54), Value('WBB (Write Back Buffer) full pipline stall cycles', 55), Value('Reserved', 56, '', True), Value('Reserved', 57, '', True), Value('Reserved', 58, '', True), Value('Reserved', 59, '', True), Value('Reserved', 60, '', True), Value('Reserved', 61, '', True), Value('Reserved', 62, '', True), Value('Reserved', 63, '', True), Value('Guest exits (guest mode to root mode transitions)', 128), Value('GHFC exceptions', 129), Value('GRIR exceptions', 130), Value('Guest related root TLB exceptions taken with GuestCtl0.GExcCode=GVA', 131), Value('Root TLB exceptions caused by D-side guest translation requests', 132), Value('Root writes that set Guest.PerfCnt that cause Guest.Cause.PCI to be set to 1', 133), Value('Guest accesses to PerfCtr/Ctl registers that cause GPSI when virtually shared', 134), Value('Interrupts that cause guest exit in non-EIC mode', 135)]),
                                Field('IE', Bits(4), 'Generate an interrupt from top bit of counter.'),
                                Field('U', Bits(3), 'Count events in user mode.'),
                                Field('0', Bits(2), 'Reserved.'),
                                Field('K', Bits(1), 'Count events in kernel mode.'),
                                Field('EXL', Bits(0), 'Count events in exception-mode.')],
                      'P5600.*': [Field('M', Bits(31), 'Set to 1 if there is another PerfCtl register after this one. This field is set for PerfCtl0-2 and cleared on PerfCtl3.'),
                                  Field('Reserved', Bits(30, 25), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                  Field('EC', Bits(24, 23), 'Event Class. Root only. Reserved, read-only 0 in all other contexts. The     P5600 may detect the existence of this feature by writing a non-zero     value to the field and reading. If value read is 0, then EC is not supported.     ${nl}Root events are those that occur when GuestCtl0GM=0.     Root intervention events are those that occur when GuestCtl0GM=1 and     !(Root.StatusEXL=0 and Root.StatusERL=0 and Root.DebugDM=0)     Guest events are those that occur when GuestCtl0GM=1 and Root.StatusEXL=     0 and Root.StatusERL=0 and Root.DebugDM=0     ${nl}For the case of root intervention mode, PerfCtlU/S/K/EXL are ignored as     Root.StatusEXL=1 and root must be in kernel mode.     ${nl}An implementation must qualify existing performance counter events     with the value of EC. For example, if an event is Instructions Graduated     and EC=0, then only instructions graduated in root mode are counted.', [Value('Root events counted. [default] Active in Root context.', 0), Value('Root intervention events counted. Active in Root context.', 1), Value('Guest events counted. Active in Guest context.', 2), Value('Guest plus Root events counted. Active in Guest context.', 3)]),
                                  Field('Reserved', Bits(22, 16), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                  Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                  Field('Reserved', Bits(14, 13), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                  Field('Event', Bits(12, 5), 'Determines which event to count', [Value('Cycles', 0), Value('Instructions graduated', 1), Value("'jr $31' predicted but guessed wrong", 2), Value("'jr $31' (return) instructions fetched and not predicted using RPS", 3), Value('ITLB misses, which result in an MMU access. ITLB misses seen at the ID stage', 4), Value('JTLB instruction access misses (will lead to an exception)', 5), Value('I-Cache misses: Includes misses resulting from fetch-ahead and speculation', 6), Value('Reserved', 7, '', True), Value('PDTrace back stalls', 8), Value('Valid fetch slots killed due to taken branches/jumps or stalling instructions', 9), Value('Load misses transitioning to I-S or I-E (multi-core only)', 10, 'Reserved in single-core.'), Value('Cycles IFU-IDU gate is open but no instructions fetched by IFU', 11), Value('Intervention hits (multi-core only)', 12, 'Reserved in single-core.'), Value('Cycles where no instruction is inserted in DDQ1 because it is full', 13), Value('Reserved', 14, '', True), Value('Cycles where no instructions can be added to the issue pool; full in order FIFO used for coprocessor 1 instructions (IOIQ)', 15), Value('Reserved', 16, '', True), Value('Reserved', 17, '', True), Value('Cycles when four instructions are issued', 18), Value('Reserved', 19, '', True), Value('Cycles when two instructions are issued', 20), Value("'jr $31' instructions graduated", 21), Value('D-Cache line refill (not LD/ST misses)', 22), Value('Speculative data cache accesses. Pairs of loads or stores that are fused count as one', 23), Value('D-Cache misses. This count is per instruction at graduation and includes load, store, prefetch, synci and address based cacheops.', 24), Value('Reserved', 25, '', True), Value('Reserved', 26, '', True), Value('LSGB graduation that does not result in a request going out on the bus', 27), Value('L2 cache accesses', 28), Value('L2 cache miss cycles', 29), Value('Cycles Fill Store Buffer(FSB) > 1/2 full', 30), Value('Cycles Load Data Queue(LDQ) > 1/2 full', 31), Value('Cycles Writeback Buffer(WBB) > 1/2 full', 32), Value('Request latency to first data word of data from the Coherence Manager (multi-core only)', 33, 'Reserved in single-core.'), Value('All invalidate interventions (multi-core only)', 34, 'Reserved in single-core.'), Value('Floating Point Load instructions graduated', 35), Value("'jr $31' mispredicted at graduation", 36), Value('Floating Point Branch instructions graduated', 37), Value('Mispredicted Branch likely instructions graduated', 38), Value('Mispredicted Conditional branches graduated', 39), Value('FPU instructions graduated (but not counting FPU load/store)', 40), Value('Stores graduated. Bonded load/store counted as 2', 41), Value('Reserved', 42, '', True), Value('Integer multiply/divides graduated', 43), Value('Reserved', 44, '', True), Value('Reserved', 45, '', True), Value('Uncached stores graduated', 46), Value('Writebacks due to any reason (multi-core only)', 47, 'Reserved in single-core.'), Value('Transitions from (I,S)-E (multi-core only)', 48, 'Reserved in single-core.'), Value('EJTAG data triggers', 49), Value('Reserved', 50, '', True), Value('Store conditional (sc) instructions failed', 51), Value("'prefetch' instructions which did nothing because they hit the cache", 52), Value('Load misses graduated', 53), Value('Cycles where two instructions graduated', 54), Value('Floating point stores graduated', 55), Value('Cycles no instructions graduated from the time pipe flushed due to replay until the first new instruction graduates', 56), Value('Cycles waiting for delay slot to graduate on a mispredicted branch', 57), Value('Replays initiated from graduation', 58), Value('Reserved', 59, '', True), Value('State transitions from (M,E)-S (multi-core only)', 60, 'Reserved in single-core.'), Value('Count of requests that will receive self-intervention (multi-core only)', 61, 'Reserved in single-core.'), Value('Reserved', 62, '', True), Value('All interventions (multi-core only)', 63, 'Reserved in single-core.'), Value('SI_Event[1]', 64, 'The system integrator may connect the SI_PCEvent[1] pin to an event to be counted.'), Value('SI_Event[3]', 65, 'The system integrator may connect the SI_PCEvent[3] pin to an event to be counted.'), Value('SI_Event[5]', 66, 'The system integrator may connect the SI_PCEvent[5] pin to an event to be counted.'), Value('SI_Event[8]', 67, 'The system integrator may connect the SI_PCEvent[8] pin to an event to be counted.'), Value('All OCP cacheable requests accepted', 68), Value('OCP cacheable read requests accepted', 69), Value('OCP cacheable write requests accepted', 70), Value('OCP write data sent', 71), Value('OCP read data received', 72), Value('OCP Intervention write data valid (accepted or not) (multi-core only)', 73, 'Reserved in single-core.'), Value('Cycles Fill Store Buffer(FSB) 1/4 to 1/2 full', 74), Value('Cycles Load Data Queue (LDQ) 1/4 to 1/2 full', 75), Value('Cycles Writeback Buffer(WBB) 1/4 to 1/2 full', 76), Value('Counts the number of times that the L1 Branch Target Buffer (L1BTB) caused a redirect without IFU predecode- based prediction causing a redirect or replay. Measues the number of true hits for the branch portion of the L1BTB.', 77), Value('Counts the number of times that the L1 Branch Target Buffer (L1BTB) caused a redirect with IFU predecodebased prediction causing a redirect or replay. Measues the number of mispredicts for the branch portion of the L1BTB.', 78), Value('Counts the number of writes to the branch portion of the L1 Branch Target Buffer (L1BTB) with no L1BTB hit (cold miss).', 79), Value('L1 Branch Target Buffer masked hits due to lack of credit for target', 80), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Times a WBB entry is newly allocated for an UCA store and there are two UCA stores already active in the WBB', 84), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Stall cycles due to the lack of IID', 87), Value('Reserved', 88, '', True), Value('Cycles when no integer instructions are dispatched', 89), Value('Cycles when one integer instruction is dispatched', 90), Value('Cycles when two integer instructions are dispatched', 91), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Cycles when four instructions are issued', 94), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Instructions issued on BSU port from DDQ1', 97), Value('Instructions issued on ALU1 port from DDQ0', 98), Value('DTLB misses (speculative)', 99), Value('Instruction side hits in the VTLB/FTLB. This includes FTLB and VTLB hits and unmapped region accesses', 100), Value('Instruction side hits in the VTLB/FTLB in an unmapped region', 101), Value('Instruction side hits in the FTLB.', 102), Value('Data side hits in the FTLB.', 103), Value('TLBWR writes to the FTLB.', 104), Value('DTLB hits to the half of EntryLo that did not cause a fill (speculative)', 105), Value('Pairs of bonded loads at graduation', 106), Value('Speculative count of over-eager loads that hit a store without the data being available', 107), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Misaligned stores that graduated', 110), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Reserved', 113, '', True), Value('Reserved', 114, '', True), Value('Reserved', 115, '', True), Value('Reserved', 116, '', True), Value('Reserved', 117, '', True), Value('Reserved', 118, '', True), Value('Reserved', 119, '', True), Value('Reserved', 120, '', True), Value('Reserved', 121, '', True), Value('Reserved', 122, '', True), Value('Reserved', 123, '', True), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Reserved', 126, '', True), Value('Reserved', 127, '', True), Value('Guest exits (guest mode to root mode transitions)', 128), Value('GHFC exceptions', 129), Value('GRIR exceptions', 130), Value('Guest related root TLB exceptions taken with GuestCtl0.GExcCode=GVA', 131), Value('Root TLB exceptions caused by D-side guest translation requests', 132), Value('Root writes that set Guest.PerfCnt that cause Guest.Cause.PCI to be set to 1', 133), Value('Guest accesses to PerfCtr/Ctl registers that cause GPSI when virtually shared', 134), Value('Interrupts that cause guest exit in non-EIC mode', 135), Value('Instruction side hardware page table walks aborted due to an exception or branch mispredict related to an older instruction.', 136), Value('Instruction or data side hardware page table walks aborted because a related table walk load has caused an exception, including a TLB refill.', 137), Value('Reserved', 138, '', True)]),
                                  Field('IE', Bits(4), 'Set to cause an interrupt when the counter overflows into bit 31. This can either be used to implement an extended count or (by presetting the counter appropriately) to notify software after a certain number of events have occurred.'),
                                  Field('U', Bits(3), 'Count events in User mode. When this bit is set, events can be counted in User mode.'),
                                  Field('S', Bits(2), 'Count events in Supervisor mode. When this bit is set, events can be counted in Supervisor mode.'),
                                  Field('K', Bits(1), 'Count events in Kernel mode. When this bit is set, events can be counted in Kernel mode.'),
                                  Field('EXL', Bits(0), 'Count events in Exception mode. When this bit is set, events can be counted in Exception mode (when StatusEXL is set).')],
                      'P6600.*': [Field('M', Bits(31), 'Set to 1 if there is another PerfCtl register after this one.'),
                                  Field('W', Bits(30), 'Specifies the width of the corresponding Counter register', [Value('32 Bits', 0), Value('64 Bits', 1)]),
                                  Field('EC', Bits(24, 23), 'Event Class. Root only. Reserved, read-only 0 in all other contexts. The      P6600 may detect the existence of this feature by writing a non-zero      value to the field and reading. If value read is 0, then EC is not supported.      ${nl}Root events are those that occur when GuestCtl0GM=0.      Root intervention events are those that occur when GuestCtl0GM=1 and      !(Root.StatusEXL=0 and Root.StatusERL=0 and Root.DebugDM=0)      Guest events are those that occur when GuestCtl0GM=1 and Root.StatusEXL=      0 and Root.StatusERL=0 and Root.DebugDM=0      ${nl}For the case of root intervention mode, PerfCtlU/S/K/EXL are ignored as      Root.StatusEXL=1 and root must be in kernel mode.      ${nl}An implementation must qualify existing performance counter events      with the value of EC. For example, if an event is Instructions Graduated      and EC=0, then only instructions graduated in root mode are counted.', [Value('Root events counted. [default] Active in Root context.', 0), Value('Root intervention events counted. Active in Root context.', 1), Value('Guest events counted. Active in Guest context.', 2), Value('Guest plus Root events counted. Active in Guest context.', 3)]),
                                  Field('Event', Bits(12, 5), 'Determines which event to count', [Value('Cycles', 0), Value('Instructions graduated', 1), Value("'jr $31' predicted but guessed wrong", 2), Value("'jr $31' (return) instructions fetched and not predicted using RPS", 3), Value('ITLB misses, which result in an MMU access. ITLB misses seen at the ID stage', 4), Value('JTLB instruction access misses (will lead to an exception)', 5), Value('I-Cache misses: Includes misses resulting from fetch-ahead and speculation', 6), Value('Fetches restricted due to MAAR', 7), Value('Reserved', 8, '', True), Value('Valid fetch slots killed due to taken branches/jumps or stalling instructions', 9), Value('Load misses transitioning to I-S or I-E (multi-core only)', 10, 'Reserved in single-core'), Value('Cycles IFU-IDU gate is open but no instructions fetched by IFU', 11), Value('Intervention hits (multi-core only)', 12, 'Reserved in single-core.'), Value('Cycles where no instruction is inserted in DDQ1 because it is full', 13), Value('Reserved', 14, '', True), Value('Cycles where no instructions can be added to the issue pool; full in order FIFO used for coprocessor 1 instructions (IOIQ)', 15), Value('Reserved', 16, '', True), Value('Reserved', 17, '', True), Value('Cycles when four instructions are issued', 18), Value('Reserved', 19, '', True), Value('Cycles when two instructions are issued', 20), Value("'jr $31' instructions graduated", 21), Value('D-Cache line refill (not LD/ST misses)', 22), Value('Speculative data cache accesses. Pairs of loads or stores that are fused count as one', 23), Value('D-Cache misses. This count is per instruction at graduation and includes load, store, prefetch, synci and address based cacheops.', 24), Value('Reserved', 25, '', True), Value('Reserved', 26, '', True), Value('LSGB graduation that does not result in a request going out on the bus', 27), Value('L2 cache accesses', 28), Value('L2 cache miss cycles', 29), Value('Cycles Fill Store Buffer(FSB) > 1/2 full', 30), Value('Cycles Load Data Queue(LDQ) > 1/2 full', 31), Value('Cycles Writeback Buffer(WBB) > 1/2 full', 32), Value('Request latency to first data word of data from the Coherence Manager (multi-core only)', 33, 'Reserved in single-core.'), Value('Invalidate interventions (multi-core only)', 34, 'Reserved in single-core.'), Value('Floating Point Load instructions graduated', 35), Value("'jr $31' mispredicted at graduation", 36), Value('Floating Point Branch instructions graduated', 37), Value('Mispredicted Branch likely instructions graduated', 38), Value('Mispredicted Conditional branches graduated', 39), Value('FPU instructions graduated (but not counting FPU load/store)', 40), Value('Stores graduated. Bonded load/store counted as 2', 41), Value('Reserved', 42, '', True), Value('Integer multiply/divides graduated', 43), Value('Reserved', 44, '', True), Value('Reserved', 45, '', True), Value('Uncached stores graduated', 46), Value('Writebacks due to any reason (multi-core only)', 47, 'Reserved in single-core.'), Value('Transitions from (I,S)-E (multi-core only)', 48, 'Reserved in single-core.'), Value('EJTAG data triggers', 49), Value('Reserved', 50, '', True), Value("'sc' instructions failed", 51), Value("'prefetch' instructions which did nothing because they hit the cache", 52), Value('Cacheable load misses in TI. Includes floating point and fast path loads.', 53), Value('Cycles where two instructions graduated', 54), Value('Floating point stores graduated', 55), Value('Cycles no instructions graduated from the time pipe flushed due to replay until the first new instruction graduates', 56), Value('Cycles waiting for delay slot to graduate on a mispredicted branch', 57), Value('Replays initiated from graduation', 58), Value('Indicates the load/store graduation buffer (LSGB) is half full.', 59), Value('State transitions from (M,E)-S (multi-core only)', 60, 'Reserved in single-core.'), Value('Requests that will receive self-intervention (multi-core only)', 61, 'Reserved in single-core.'), Value('Reserved', 62, '', True), Value('All Interventions (multi-core only)', 63, 'Reserved in single-core.'), Value('SI_Event[1]', 64, 'The system integrator may connect the SI_PCEvent[1] pin to an event to be counted.'), Value('SI_Event[3]', 65, 'The system integrator may connect the SI_PCEvent[3] pin to an event to be counted.'), Value('SI_Event[5]', 66, 'The system integrator may connect the SI_PCEvent[5] pin to an event to be counted.'), Value('SI_Event[8]', 67, 'The system integrator may connect the SI_PCEvent[8] pin to an event to be counted.'), Value('All OCP cacheable requests accepted', 68), Value('OCP cacheable read requests accepted', 69), Value('OCP cacheable write requests accepted', 70), Value('OCP write data sent', 71), Value('OCP read data received', 72), Value('OCP Intervention write data valid (accepted or not) (multi-core only)', 73, 'Reserved in single-core.'), Value('Cycles Fill Store Buffer(FSB) 1/4 to 1/2 full', 74), Value('Cycles Load Data Queue (LDQ) 1/4 to 1/2 full', 75), Value('Cycles Writeback Buffer(WBB) 1/4 to 1/2 full', 76), Value('Times that the L1 Branch Target Buffer (L1BTB) caused a redirect without IFU predecode-based prediction causing a redirect or replay. Measues the number of true hits for the branch portion of the L1BTB.', 77), Value('Times that the L1 Branch Target Buffer (L1BTB) caused a redirect with IFU predecode-based prediction causing a redirect or replay. Measues the number of mispredicts for the branch portion of the L1BTB.', 78), Value('Writes to the branch portion of the L1 Branch Target Buffer (L1BTB) with no L1BTB hit (cold miss).', 79), Value('L1 Branch Target Buffer masked hits due to lack of credit for target', 80), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('WBB entry is newly allocated for an UCA store and there are two UCA stores already active in the WBB', 84), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Stall cycles due to the lack of IID', 87), Value('Reserved', 88, '', True), Value('Cycles when no integer instructions are dispatched', 89), Value('Cycles when one integer instruction is dispatched', 90), Value('Cycles when two integer instructions are dispatched', 91), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Cycles when four instructions are issued', 94), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Instructions issued on BSU port from DDQ1', 97), Value('Instructions issued on ALU1 port from DDQ0', 98), Value('DTLB misses (speculative)', 99), Value('Instruction side hits in the VTLB/FTLB. This includes FTLB and VTLB hits and unmapped region accesses', 100), Value('Instruction side hits in the VTLB/FTLB in an unmapped region', 101), Value('Instruction side hits in the FTLB.', 102), Value('Data side hits in the FTLB.', 103), Value('TLBWR writes to the FTLB.', 104), Value('DTLB hits to the half of EntryLo that did not cause a fill (speculative)', 105), Value('Pairs of bonded loads at graduation', 106), Value('Speculative count of over-eager loads that hit a store without the data being available', 107), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Misaligned stores that graduated', 110), Value('Reserved', 111, '', True), Value('Reserved', 112, '', True), Value('Cycles where FPU/MSA sent F2I strobes.', 113), Value('Cycles where FPU/MSA received I2F strobes.', 114), Value('Instruction-side unmapped XKPhys accesses.', 115), Value('Cycles where FPU/MSA received I2F load strobes.', 116), Value('Cycles where FPU/MSA received I2F bonded load strobes.', 117), Value('Cycles where FPU/MSA slowly returning credits.', 118), Value('Reserved', 119, '', True), Value('Times noRFO detected.', 120), Value('Refetches for MSA misaligned instructions.', 121), Value('Doubleword bonded speculative stores.', 122), Value('Quadword bonded speculative stores.', 123), Value('Reserved', 124, '', True), Value('Reserved', 125, '', True), Value('Hardware table walker (HTW) abort due to HTW access denied to XSSeg (XS = 0).', 126), Value('Reserved', 127, '', True), Value('Guest exits (guest mode to root mode transitions)', 128), Value('GHFC exceptions', 129), Value('GRIR exceptions', 130), Value('Guest related root TLB exceptions taken with GuestCtl0.GExcCode=GVA', 131), Value('Root TLB exceptions caused by D-side guest translation requests', 132), Value('Root writes that set Guest.PerfCnt that cause Guest.Cause.PCI to be set to 1', 133), Value('Guest accesses to PerfCtr/Ctl registers that cause GPSI when virtually shared', 134), Value('Interrupts that cause guest exit in non-EIC mode', 135), Value('Instruction side hardware page table walks aborted due to an exception or branch mispredict related to an older instruction.', 136), Value('Instruction or data side hardware page table walks aborted because a related table walk load has caused an exception, including a TLB refill.', 137), Value('Reserved', 138, '', True), Value('Dependent instructions replayed in CTI pipe due to load miss.', 139), Value('Dependent instructions replayed in AGEN pipe due to load miss.', 140)]),
                                  Field('IE', Bits(4), 'Set to cause an interrupt when the counter overflows into bit 31. This can either be used to implement an extended count or (by presetting the counter appropriately) to notify software after a certain number of events have occurred.'),
                                  Field('U', Bits(3), 'Count events in User mode. When this bit is set, events can be counted in User mode.'),
                                  Field('S', Bits(2), 'Count events in Supervisor mode. When this bit is set, events can be counted in Supervisor mode.'),
                                  Field('K', Bits(1), 'Count events in Kernel mode. When this bit is set, events can be counted in Kernel mode.'),
                                  Field('EXL', Bits(0), 'Count events in Exception mode. When this bit is set, events can be counted in Exception mode (when StatusEXL is set).')],
                      'ProAptiv.*': [Field('M', Bits(31), 'Set to 1 if there is another PerfCtl register after this one. This field is set for PerfCtl0-2 and cleared on PerfCtl3.'),
                                     Field('Reserved', Bits(30, 16), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                     Field('PCTD', Bits(15), 'Performance Counter Trace Disable. Setting this bit will prevent the tracing of data from this performance counter when performance count trace mode in PDtrace is enabled.'),
                                     Field('Reserved', Bits(14, 12), 'Reserved. Must be written as zeros; returns zeros on reads.'),
                                     Field('Event', Bits(11, 5), 'Determines which event to count', [Value('Cycles', 0), Value('Instructions graduated', 1), Value("'jr $31' predicted but guessed wrong", 2), Value("'jr $31' (return) instructions fetched and not predicted using RPS", 3), Value('ITLB misses, which result in an MMU access. ITLB misses seen at the ID stage', 4), Value('JTLB instruction access fails (will lead to an exception)', 5), Value('I-Cache misses: Includes misses resulting from fetch-ahead and speculation', 6), Value('Reserved', 7, '', True), Value('PDTrace back stalls', 8), Value('Valid fetch slots killed due to taken branches/jumps or stalling instructions', 9), Value('Load misses transitioning to I-S or I-E (multi-core only)', 10, 'Reserved in single-core.'), Value('Cycles IFU-IDU gate is open but no instructions fetched by IFU', 11), Value('Intervention hits (multi-core only)', 12, 'Reserved in single-core.'), Value('Cycles where no instruction is inserted in DDQ1 because it is full', 13), Value('Reserved', 14, '', True), Value('Cycles where no instructions can be added to the issue pool, full in order FIFO used for coprocessor 1 instructions (IOIQ)', 15), Value('Reserved', 16, '', True), Value('Reserved', 17, '', True), Value('Cycles when four instructions are issued', 18), Value('Reserved', 19, '', True), Value('Cycles when two instructions are issued', 20), Value("'jr $31' instructions graduated", 21), Value('D-Cache line refill (not LD/ST misses)', 22), Value('Speculative data cache accesses. Pairs of loads or stores that are fused count as one', 23), Value('D-Cache misses', 24), Value('Reserved', 25, '', True), Value('Reserved', 26, '', True), Value('LSGB graduation that does not result in a request going out on the bus', 27), Value('L2 cache accesses', 28), Value('L2 cache misses', 29), Value('Cycles Fill Store Buffer(FSB) > 1/2 full', 30), Value('Cycles Load Data Queue(LDQ) > 1/2 full', 31), Value('Cycles Writeback Buffer(WBB) > 1/2 full', 32), Value('Request latency to first data word of data from the Coherence Manager (multi-core only)', 33, 'Reserved in single-core.'), Value('All invalidate interventions (multi-core only)', 34, 'Reserved in single-core.'), Value('Floating Point Load instructions graduated', 35), Value("'jr $31' mispredicted at graduation", 36), Value('Floating Point Branch instructions graduated', 37), Value('Mispredicted Branch likely instructions graduated', 38), Value('Mispredicted Conditional branches graduated', 39), Value('FPU instructions graduated (but not counting FPU load/store)', 40), Value('Stores graduated. Fused load/store counted as 2', 41), Value('MIPS16e instructions graduated', 42), Value('Integer multiply/divides graduated', 43), Value('ALU-DSP graduated, result was saturated', 44), Value('MDU-DSP graduated, result was saturated', 45), Value('Uncached stores graduated', 46), Value('Writebacks due to any reason (multi-core only)', 47, 'Reserved in single-core.'), Value('Count of transitions from (I,S)-E (multi-core only)', 48, 'Reserved in single-core.'), Value('EJTAG data triggers', 49), Value('Reserved', 50, '', True), Value('Store conditional (sc) instructions failed', 51), Value("'prefetch' instructions which did nothing; hit in the cache", 52), Value('Load misses graduated', 53), Value('Cycles where two instructions graduated', 54), Value('Floating point stores graduated', 55), Value('Cycles no instructions graduated from the time a pipe kill happened due to replay until the first new instruction graduates', 56), Value('Cycles waiting for delay slot to graduate on a mispredicted branch', 57), Value('Replays initiated from graduation', 58), Value('Reserved', 59, '', True), Value('State transitions from (M,E)-S (multi-core only)', 60, 'Reserved in single-core.'), Value('Count of requests that will receive self-intervention (multi-core only)', 61, 'Reserved in single-core.'), Value('Implementation-specific DSPRAM event', 62), Value('All interventions (multi-core only)', 63, 'Reserved in single-core.'), Value('Implementation-specific system event', 64), Value('Implementation-specific system event', 65), Value('Implementation-specific system event', 66), Value('Implementation-specific system event', 67), Value('All OCP cacheable requests accepted', 68), Value('OCP cacheable read requests accepted', 69), Value('OCP cacheable write requests accepted', 70), Value('OCP write data sent', 71), Value('OCP read data received', 72), Value('OCP Intervention write data valid (accepted or not) (multi-core only)', 73, 'Reserved in single-core.'), Value('Cycles Fill Store Buffer(FSB) 1/4 to 1/2 full', 74), Value('Cycles Load Data Queue (LDQ) 1/4 to 1/2 full', 75), Value('Cycles Writeback Buffer(WBB) 1/4 to 1/2 full', 76), Value('Times that the L1BTB caused a redirect without IFU predecode-based prediction', 77), Value('Times that the L1BTB caused a redirect with IFU predecode-based prediction', 78), Value('Writes to the RPS portion of the L1BTB with no L1BTB hit (cold miss).', 79), Value('L1 Branch Target Buffer masked hits due to lack of credit for target', 80), Value('Reserved', 81, '', True), Value('Reserved', 82, '', True), Value('Reserved', 83, '', True), Value('Times a WBB entry is newly allocated for an UCA store and there are two UCA stores already active in the WBB', 84), Value('Reserved', 85, '', True), Value('Reserved', 86, '', True), Value('Stall cycles due to the lack of IID', 87), Value('Reserved', 88, '', True), Value('Cycles when no integer instructions are dispatched', 89), Value('Cycles when one integer instruction is dispatched', 90), Value('Cycles when two integer instructions are dispatched', 91), Value('Reserved', 92, '', True), Value('Reserved', 93, '', True), Value('Cycles when four instructions are issued', 94), Value('Reserved', 95, '', True), Value('Reserved', 96, '', True), Value('Instructions issued on BSU port from DDQ1', 97), Value('Instructions issued on ALU1 port from DDQ0', 98), Value('DTLB misses (speculative)', 99), Value('Instruction side hits in the VTLB/FTLB. This includes FTLB and VTLB hits and unmapped region accesses', 100), Value('Instruction side hits in the VTLB/FTLB in an unmapped region', 101), Value('Reserved', 102, '', True), Value('Reserved', 103, '', True), Value('Reserved', 104, '', True), Value('DTLB hits to the half of EntryLo that did not cause a fill (speculative)', 105), Value('Pairs of fused loads at graduation', 106), Value('Speculative count of over-eager loads that hit a store without the data being available', 107), Value('Reserved', 108, '', True), Value('Reserved', 109, '', True), Value('Misaligned stores that graduated', 110), Value('Reserved', 111, '', True), Value('Cycles the to-from channel is full and signalling busy to the integer core', 112), Value('To-from instructions issued', 113), Value('Arithmetic multiply-add instructions (madd, msub, nmadd, nmsub)', 114), Value('Arithmetic compare class instructions (C.cond)', 115), Value('Data stall retires due to an scheduled load queue preempt write', 116), Value('Data channel conflict stalls', 117), Value('Data channel kill received stalls. Same as arithmetic condition', 118), Value('Data channel due to no room in the Scheduled Load Queue', 119), Value('Data channel instruction issue stalls', 120), Value('Data channel retire stall cycles', 121), Value('Data channel indeterminate dependency or format mismatch stalls', 122), Value('Reserved', 123, '', True), Value('Data channel arithmetic data stalls', 124), Value('Data channel to data stalls', 125), Value('Number data channel stalls due to a pipecleaner instruction', 126), Value('All data channel issue stall cycles', 127)]),
                                     Field('IE', Bits(4), 'Set to cause an interrupt when the counter overflows into bit 31. This can either be used to implement an extended count or (by presetting the counter appropriately) to notify software after a certain number of events have occurred.'),
                                     Field('U', Bits(3), 'Count events in User mode. When this bit is set, events can be counted in User mode.'),
                                     Field('S', Bits(2), 'Count events in Supervisor mode. When this bit is set, events can be counted in Supervisor mode.'),
                                     Field('K', Bits(1), 'Count events in Kernel mode. When this bit is set, events can be counted in Kernel mode.'),
                                     Field('EXL', Bits(0), 'Count events in Exception mode. When this bit is set, events can be counted in Exception mode (when StatusEXL is set).')]},
 'STAT_CONF_REG_FIELDS': {'': [Field('Reserved', Bits(31, 24)),
                               Field('PWRUP_EVENT', Bits(23), 'The SI_PowerUp pin had been activated and caused the sequencer to cycle into power up state. The event also caused the sequencer to place a PwrUp command into the CMD field. Writing a 0 into the PWRUP_EVENT field will clear this bit.'),
                               Field('SEQ_STATE', Bits(22, 19), '', [Value('D0 - PwrDwn', 0), Value('U0 - VddOK', 1), Value('U1 - UpDelay', 2), Value('U2 - UClkOff', 3), Value('U3 - Reset', 4), Value('U4 - ResetDly', 5), Value('U5 - nonCoherent execution', 6), Value('U6 - Coherent execution', 7), Value('D1 - Isolate', 8), Value('D3 - ClrBus', 9), Value('D2 - DClkOff', 10)]),
                               Field('Reserved', Bits(18)),
                               Field('CLKGAT_IMPL', Bits(17), 'If set, this domain is implemented with clock tree root gating. If cleared, the CPC will still execute power-down/clock-off sequences if commanded; however, no physical clock gating is performed.'),
                               Field('PWRDN_IMPL', Bits(16), 'If set, this domain is implemented as power-gated. If cleared, the CPC will still execute power-down sequences if commanded; however, no physical power switching is performed.'),
                               Field('EJTAG_PROBE', Bits(15), 'An EJTAG probe connection event has been seen. The domain powers up if required and observes a reset sequence. Thereafter the core transitions into clock-off mode. After a probe has been seen once, the power domain will not assume power-off mode until this bit is written to zero or the CPC experiences a cold reset.'),
                               Field('Reserved', Bits(14, 10)),
                               Field('PWUP_POLICY', Bits(9, 8), 'Each CPC domain sequencer is hardwired through the SI_ColdPwrUp signal to either power up, remain power-gated, go into clock-off mode, or become operational.', [Value('This CPU remains powered down after a system cold start.', 0), Value('Go into Clock-Off mode. Disables domain clock after power-up sequence.', 1), Value('Power up this domain after system cold start.', 2), Value('Reserved', 3, '', True)]),
                               Field('Reserved', Bits(7, 5)),
                               Field('IO_TRFFC_EN', Bits(4), 'Enable CM for stand alone IOCU traffic. Setting this bit changes the low power state of the CM power domain from PwrDwn to ClkOff. The CM_IOPwrUp signal can be used by an external device to enable the CM to perform IOCU data transfers without CPU activities.'),
                               Field('CMD', Bits(3, 0), 'Reflects most recent placed sequencer command. See definition in CPC_CMD_REG. The sequencer will overwrite the field after a Reset command, or SI_PwrUp signal caused power up of the domain. The command reads then as PwrUp.')]},
 'WatchHiFields': {'': [Field('M', Bits(31), 'Reads 1 when there are more watchpoint registers.'),
                        Field('G', Bits(30), 'When set, ignore ASID when matching.'),
                        Field('0', Bits(29, 24), 'Reserved.  Write as zero. Ignored on reads.'),
                        Field('ASID', Bits(23, 16), 'Watch for access with this ASID.'),
                        Field('0', Bits(15, 12), 'Reserved.  Write as zero. Ignored on reads.'),
                        Field('Mask', Bits(11, 3), 'Set bit to ignore corresponding VAddr bit.'),
                        Field('I', Bits(2), 'Watchpoint matched on an I-fetch.'),
                        Field('R', Bits(1), "Watchpoint matched on a load ('read')."),
                        Field('W', Bits(0), "Watchpoint matched on a store ('write').")],
                   'I6[45]00.*,P6600.*': [Field('M', Bits(31), 'Reads 1 when there are more watchpoint registers.'),
                                          Field('G', Bits(30), 'If the set, any address that matches that specified in the    corresponding WatchLo register causes a watch exception. If this bit is zero,    the ASID field of the WatchHi register must match the ASID field of the    EntryHi register to cause a watch exception.'),
                                          Field('WM', Bits(29, 28), 'VVirtualization support. This bit is used for root management of the Watch    functionality. This field is reserved and read as 0 for Guest WatchHi, or if    such functionality is unimplemented. Software can determine existence of this    feature by writing then reading this field.'),
                                          Field('ASID', Bits(23, 16), u'ASID matches addresses from a particular address space (the    ASID is like that in TLB entries) \u2014 except that you can set G    (global) to match the address in any address space.${p}    The match a particular address, the G bit is cleared and the    ASID value is used to ensure that the match is to the correct    address space. If the If the G bit is set, the address is always    matched, regardless of the ASID value.'),
                                          Field('Mask', Bits(11, 3), 'Watch mask. This field marks the corresponding VAddr address    bits to be ignored when deciding whether this is a match.'),
                                          Field('I', Bits(2), u"Watchpoint matched on an I-fetch.${p}      Write a 1 to any of these bits in order to clear it (and therefore prevent the    exception from immediately happening again). This behavior is unusual    among CP0 registers, but it is quite convenient: to clear a watchpoint of all the    exception causes you\u2019ve seen, just read the value of WatchHi0-3 and write it    back again. This bit may behave as an 'R0' field in which case this feature is    not supported on this target."),
                                          Field('R', Bits(1), u"Watchpoint matched on a load ('read').${p}      Write a 1 to any of these bits in order to clear it (and therefore prevent the    exception from immediately happening again). This behavior is unusual    among CP0 registers, but it is quite convenient: to clear a watchpoint of all the    exception causes you\u2019ve seen, just read the value of WatchHi0-3 and write it    back again. This bit may behave as an 'R0' field in which case this feature is    not supported on this target."),
                                          Field('W', Bits(0), u"Watchpoint matched on a store ('write').${p}      Write a 1 to any of these bits in order to clear it (and therefore prevent the    exception from immediately happening again). This behavior is unusual    among CP0 registers, but it is quite convenient: to clear a watchpoint of all the    exception causes you\u2019ve seen, just read the value of WatchHi0-3 and write it    back again. This bit may behave as an 'R0' field in which case this feature is    not supported on this target.")],
                   'P5600.*,M5150': [Field('M', Bits(31), 'Reads 1 when there are more watchpoint registers.'),
                                     Field('G', Bits(30), 'When set, ignore ASID when matching.'),
                                     Field('WM', Bits(29), 'Virtualization support. This bit is used for root management of Watch functionality.'),
                                     Field('0', Bits(28, 24), 'Reserved.  Write as zero. Ignored on reads.'),
                                     Field('ASID', Bits(23, 16), 'Watch for access with this ASID.'),
                                     Field('0', Bits(15, 12), 'Reserved.  Write as zero. Ignored on reads.'),
                                     Field('Mask', Bits(11, 3), 'Set bit to ignore corresponding VAddr bit.'),
                                     Field('I', Bits(2), 'Watchpoint matched on an I-fetch.'),
                                     Field('R', Bits(1), "Watchpoint matched on a load ('read')."),
                                     Field('W', Bits(0), "Watchpoint matched on a store ('write').")]},
 'WatchLoFields32': {'': [Field('VAddr', Bits(31, 3), 'Virtual address to watch for, with a resolution of a doubleword.'),
                          Field('I', Bits(2), 'Watch for I-fetches (write 1 to clear)'),
                          Field('R', Bits(1), "Watch for loads ('reads') (write 1 to clear)"),
                          Field('W', Bits(0), "Watch for stores ('writes') (write 1 to clear)")]},
 'WatchLoFields64': {'': [Field('VAddr', Bits(63, 3), 'Virtual address to watch for, with a resolution of a doubleword.'),
                          Field('I', Bits(2), "If this bit is one, watch exceptions are enabled for instruction fetches that match the     address and are actually issued by the processor (speculative instructions never cause     Watch exceptions).${p}     This bit may be 'R0', in which case this feature is not supported on this target."),
                          Field('R', Bits(1), "If this bit is one, watch exceptions are enabled for loads that match the      address. The PCrelative reference is considered to be a data, rather than an instruction reference.      That is, the watchpoint is triggered only if this bit is a 1.${p}     This bit may be 'R0', in which case this feature is not supported on this target."),
                          Field('W', Bits(0), "If this bit is one, watch exceptions are enabled for stores that match the      address.${p}     This bit may be 'R0', in which case this feature is not supported on this target.")]}}
arches={'32': [Register('ra', '', '', {}, 'Return address for subroutine.'),
        Register('s8', '', '', {}, "Frame pointer; compilers sometimes generate code which access subroutine variables with this register as an index.\\n\\nRegister is sometimes referenced as's8'."),
        Register('sp', '', '', {}, 'Stack pointer; compilers sometimes generate code which access subroutine variables by a constant offset from sp.\\n\\nThe stack grows from high addresses to low addresses.'),
        Register('gp', '', '', {}, 'Global pointer; some runtime systems maintain this to give easy access to (some) static or extern variables.'),
        Register('k1', '', '', {}, 'Reserved for use by interrupt/trap handler; may change under your feet.'),
        Register('k0', '', '', {}, 'Reserved for use by interrupt/trap handler; may change under your feet.'),
        Register('s7', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.'),
        Register('s6', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.'),
        Register('s5', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.'),
        Register('s4', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.'),
        Register('s3', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.'),
        Register('s2', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.'),
        Register('s1', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.'),
        Register('s0', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.'),
        Register('t9', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('t8', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('t7', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('t6', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('t5', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('t4', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('t3', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('t2', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('t1', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('t0', '', '', {}, 'Temporary, subroutines can use without saving.'),
        Register('a3', '', '', {}, 'Argument, First few parameters for a subroutine.'),
        Register('a2', '', '', {}, 'Argument, First few parameters for a subroutine.'),
        Register('a1', '', '', {}, 'Argument, First few parameters for a subroutine.'),
        Register('a0', '', '', {}, 'Argument, First few parameters for a subroutine.'),
        Register('v1', '', '', {}, 'Value returned by subroutine.'),
        Register('v0', '', '', {}, 'Value returned by subroutine.'),
        Register('UserLocal', 'cp0.4.2', '', {}, 'The UserLocal register is a read-write register that is not interpreted by the hardware and conditionally readable via the RDHWR instruction.', [], 32, Op('==', Reg('Config3::ULRI'), 1)),
        Register('LLAddr', 'cp0.17.0', '', {'': [Field('PAddr', Bits(31, 0), 'This field encodes the physical address read by the most recent Load Linked instruction.')], 'P5600.*': [Field('PAddr', Bits(31, 1), 'This field encodes the physical address read by the most recent Load Linked instruction.      The number of additional bits supported is a function of the physical address size.      Any high-order bits greater than bit 31 of this register are accessed with MTHC0 and MFHC0 instructions.'), Field('LLB', Bits(0), 'LLB is set when the LL instruction is executed. The SC instructions and other hardware events may clear LLB. This field allows the LLbit to be software accessible. LLB can be cleared by software but cannot be set.')]}, 'The LLAddr register contains relevant bits of the physical address read by the most recent Load Linked instruction.  This register is implementation dependent and for diagnostic purposes only and serves no function during normal operation.', [], 32, Not(Or(CPUNameMatches('5K.*'), CPUNameMatches('24K.*'), CPUNameMatches('74K.*'), CPUNameMatches('M4K.*'), CPUNameMatches('M14K.*'), CPUNameMatches('1074K.*'), CPUNameMatches('ProAptiv.*'), CPUNameMatches('InterAptiv.*'), And(CPUNameMatches('P5600.*'), Op('==', Reg('Config5::LLB'), 0)), CPUNameMatches('M5100.*'))), 'r'),
        Register('PWSize', 'cp0.5.7', '', {'': [Field('0', Bits(31), 'This field must be written as zero; returns zero on read.'), Field('PS', Bits(30), 'Pointer Size. This is only used by the 64-bit architectures. For the 32-bit architectures, this bit is fixed to 0.'), Field('GDW', Bits(29, 24), 'Global Directory index width. This field is encoded as follows:           0: No read is performed using Global Directory index.           0x01 - 0x 3F: A non-zero number in this field indicates the number of bits to be           extracted from BadVAddr to create an index into the Global Directory. The           least significant bit of the field is specified by PWFieldGDI.'), Field('UDW', Bits(23, 18), 'Upper Directory index width.           0: No read is performed using Upper Directory index.           0x01 - 0x 3F: A non-zero number in this field indicates the number of bits to be           extracted from BadVAddr to create an index into the Upper Directory. The           least significant bit of the field is specified by PWFieldUDI.'), Field('MDW', Bits(17, 12), 'Middle Directory index width.           0: No read is performed using Middle Directory index.           0x01 - 0x 3F: A non-zero number in this field indicates the number of bits to be           extracted from BadVAddr to create an index into the Middle Directory. The           least significant bit of the field is specified by PWFieldMDI.'), Field('PTW', Bits(11, 6), 'Page Table index width. This field is encoded as follows:           0: UNPREDICTABLE. A value of 0 in this field causes unpredictable behavior.           This field should have a non-zero value.           1: Number of bits to be extracted from BadVAddr to create an index into the           Page Table. The least significant bit of the field is specified by PWFieldPTI.'), Field('PTEW', Bits(5, 0), 'Specifies the left shift applied to the Page Table index, in addition to the shift           required to account for the native data size of the machine.           The set of available shifts is implementation-dependent. Software can discover           the available values by writing this field. If the requested shift value is not           available, PTEW will be written as zero. A shift of one must be implemented')]}, 'The PWSize register configures hardware page table walking for TLB refills. It is used in combination with the         PWBase and PWField registers. ${nl}         The hardware page walk feature supports multi-level page tables - up to four directory levels plus one page table         level. The lowest level of any page table system is an array of Page Table Entries (PTEs). This array is known as a         Page Table (PT) and is indexed using bits from the faulting address. A single-level page table system contains only a         single Page Table.         ${nl}A multi-level page table system contains multiple levels, the lowest of which are Page Table Entries. Levels above         the lowest Page Table level are known as Directories. A directory consists of an array of pointers. Each pointer in a         directory is either to another directory or to a Page Table.         ${nl}The Page Table and the Directories are indexed by bits extracted from the faulting address BadVAddr. The PWBase         register contains the base address of the first Directory or Page Table which will be accessed. The PWSize register         specifies the number of index bits to be used for each level. The PWField register specifies the location of the index         fields in BadVAddr.         ${nl}Index values used to access Directories are multiplied by the 32-bit native pointer size for the refill. When PWSizePS         = 0, the native pointer size is 32 bits (2 bit left shift), and hardware page table walking is applied only when the TLB         exception would be taken. When PWSizePS = 1, the native pointer size is 64 bits (3 bit left shift), and hardware page         Atable walking is applied only when a TLB Refill exception would be taken.         ${nl}The index value used to access the Page Table is multiplied by the native pointer size. An additional multiplier (left         shift value) can be specified using the PWSizePTEW field. This allows space to be allocated in the Page Table structure         for software-managed fields.', [], 32, Op('==', Reg('Config3::PW'), 1)),
        Register('PWField', 'cp0.5.6', '', {'': [Field('0', Bits(31, 30), 'This field must be written as zero; returns zero on read.'), Field('GDI', Bits(29, 24), 'Global Directory index. Least significant bit of the index field extracted from           the faulting address, which is used to index into the Global Directory. The number           of index bits is specified by PWSizeGDW.'), Field('UDI', Bits(23, 18), 'Upper Directory index. Least significant bit of the index field extracted from           the faulting address, which is used to index into the Upper Directory. The number           of index bits is specified by PWSizeUDW.'), Field('MDI', Bits(17, 12), 'Middle Directory index. Least significant bit of the index field extracted from           the faulting address, which is used to index into the Middle Directory. The           number of index bits is specified by PWSizeMDW.'), Field('PTI', Bits(11, 6), 'Page Table index. Least significant bit of the index field extracted from the           faulting address, which is used to index into the Page Table. The number of           index bits is specified by PWSizePTW.'), Field('PTEI', Bits(5, 0), 'Page Table Entry shift. Specifies the logical right shift and rotation which will be applied to Page Table           Entry values loaded by hardware page table walking.${p}           The entire PTE is logically right shifted by PTEI-2 bits first. The purpose of           this shift is to remove the software-only bits from what will be written into the           TLB entry. Then the two least-significant bits of the shifted value are rotated           into position for the RI and XI protection bit locations within the TLB entry.           ${nl}A value of 2 means rotate the right-most 2 bits into the RI/XI bit positions for the TLB entry.           ${nl}A value of 3 means logical shift right by 1 bit the entire PTE and then rotate the           right-most 2 bits into the RI/XI positions for the TLB entry.           ${nl}A value of 4 means logical shift right by 2bits the entire PTE and then rotate the right-most 2 bits into the RI/XI positions for the TLB entry.           ${p}In the P5600 core, the values of 1 and 0 in this field are RESERVED and           should not be used; the operation of the page table walker is UNPREDICTABLE           for these cases.           ${p}If the PTEI value is larger than the width of EntryLo0, then the value is treated           as value-32. For example, a PTEI value of 34 is interpreted as PTEI = 2. The           values of 33 and 32 are RESERVED and should not be used; the operation of           the HW Page Walker is UNPREDICTABLE for these cases.           ${p}The set of available non-zero shifts is implementation-dependent. Software can           discover the available values by writing this field. If the requested shift value is           not available, PTEI will remain unchanged. A shift of zero must be implemented.')]}, 'The PWField register configures hardware page table walking for TLB refills. It is used in combination with the         PWBase and PWSize registers.${p}         The hardware page walker supports multi-level page tables - up to four directory levels plus one page table level. The         lowest level of any page table system is an array of Page Table Entries (PTEs). This array is known as a Page Table         (PT) and is indexed using bits from the faulting address. A single-level page table system contains only a single Page         Table.${p}         A multi-level page table system consists of multiple levels, the lowest level being the Page Table Entries. Levels         above the lowest Page Table level are known as Directories. A directory consists of an array of pointers. Each pointer         in a directory is either to another directory or to a Page Table.${p}         The Page Table and the Directories are indexed by bits extracted from the faulting address. The PWBase register contains         the base address of the first Directory or Page Table which will be accessed. The PWSize register specifies the         number of index bits to be used for each level. The PWField register specifies the location of the index fields in the         faulting address. This PWField register only exists if Config3PW = 1.${p}         If a synchronous exception condition is detected on a read operation during hardware page-table walking, the automated         process is aborted and a TLB Refill exception is taken.', [], 32, Op('==', Reg('Config3::PW'), 1)),
        Register('PWBase', 'cp0.5.5', '', {'': [Field('PWBase', Bits(31, 0), 'Page Table Base address pointer.')]}, 'The PWBase register contains the Page Table Base virtual address, used as the starting point for hardware page table         walking. It is used in combination with the PWField and PWSize registers.', [], 32, Op('==', Reg('Config3::PW'), 1)),
        Register('PageMask', 'cp0.5.0', '', {'': [Field('Reserved', Bits(31, 29)), Field('Mask', Bits(28, 13), 'The Mask field is a bit mask in which a 1 bit indicates that the corresponding bit of the virtual address should not participate in the TLB match.'), Field('Reserved', Bits(12, 0))], 'proAptiv.*,P5600.*,interAptiv.*': [Field('0', Bits(31, 29), 'Must be written as zero; returns zero on read.'), Field('Mask', Bits(28, 13), "Acts as a kind of backward mask, in that a 1 bit means 'don't compare this address bit when matching this address'.  However, only a restricted range of PageMask values are legal (i.e., with 1s filling the PageMask[Mask] field from low bits upward, two at a time).", [Value('4 Kbytes', 0), Value('16 Kbytes', 3), Value('64 Kbytes', 15), Value('256 Kbytes', 63), Value('1 Mbyte', 255), Value('4 Mbytes', 1023), Value('16 Mbytes', 4095), Value('64 Mbytes', 16383), Value('256 Mbytes', 65535)]), Field('0', Bits(12, 0), 'Must be written as zero; returns zero on read.')], 'M5150.*': [Field('0', Bits(31, 29), 'Must be written as zero; returns zero on read.'), Field('Mask', Bits(28, 11), "Acts as a kind of backward mask, in that a 1 bit means 'don't compare this address bit when matching this address'.  However, only a restricted range of PageMask values are legal (i.e., with 1s filling the PageMask[Mask] field from low bits upward, two at a time).", [Value('4 Kbytes', 3), Value('16 Kbytes', 15), Value('64 Kbytes', 63), Value('256 Kbytes', 255), Value('1 Mbyte', 1023), Value('4 Mbytes', 4095), Value('16 Mbytes', 16383), Value('64 Mbytes', 65535), Value('256 Mbytes', 262143)]), Field('0', Bits(10, 0), 'Must be written as zero; returns zero on read.')]}, 'The PageMask register is a read/write register used for reading from and writing to the TLB.  It holds a comparison mask that sets the variable page size for each TLB entry.', [], 32, Op('==', Reg('Config::MT'), 1)),
        Register('EntryLo1', 'cp0.3.0', '', 'EntryLoTemplate', 'These registers store the contents of a TLB entry.  Each entry maps a pair of pages.  The EntryLo0 and EntryLo1 register store even and odd numbered virtual pages respectively.  The register contents are written to the TLB during a tlbwr or tblwi instruction, and updated by a tlbr instruction.  They are not used for any other purpose.', [], 32, Op('==', Reg('Config::MT'), 1)),
        Register('EntryLo0', 'cp0.2.0', '', 'EntryLoTemplate', 'These registers store the contents of a TLB entry.  Each entry maps a pair of pages.  The EntryLo0 and EntryLo1 register store even and odd numbered virtual pages respectively.  The register contents are written to the TLB during a tlbwr or tblwi instruction, and updated by a tlbr instruction.  They are not used for any other purpose.', [], 32, Op('==', Reg('Config::MT'), 1)),
        Register('EntryHi', 'cp0.10.0', '', {'': [Field('VPN2', Bits(31, 13), 'Virtual address field for TLB entry.'), Field('Reserved', Bits(12, 8)), Field('ASID', Bits(7, 0), 'Current address-space ID, also used for TLB entry transfer.')], 'proAptiv.*,P5600.*,interAptiv.*': [Field('VPN2', Bits(31, 13), 'VA[31:13] of the virtual address matched on a tlbp.  It is also the virtual address to be written into the TLB on a tlbwi and tlbwr, and the destination of the virtual address on a tlbr.${p}On a TLB-related exception, the VPN2 field is automatically set to the virtual address that was being translated when the exception occurred.${p}This field is written by software before a tlbp or tlbwi and written by hardware in all other cases.'), Field('0', Bits(12, 11), 'Must be written as zero; returns zero on read.'), Field('EHINV', Bits(10), 'TLBWI invalidate enable.  When this bit is set, the TLBWI instruction acts as a TLB invalidate operation, setting the hardware valid bit associated with the TLB entry to the invalid state.  When this bit is set, the PageMask and EntryLo0/EntryLo1 registers do not need to be valid.  Only the Index register is required to be valid.${p}This bit is ignored on a TLBWR instruction.'), Field('0', Bits(9, 8), 'Must be written as zero; returns zero on read.'), Field('ASID', Bits(7, 0), "Address space identifier. This field is written by hardware on a TLB read and by software to establish the current ASID value for TLB write and against which TLB references match each entry's TLB ASID field. This field is per-TC field visible in TCStatus[TASID].")], 'M5150.*': [Field('VPN2', Bits(31, 11), 'VA[31:11] of the virtual address matched on a tlbp.  It is also the virtual address to be written into the TLB on a tlbwi and tlbwr, and the destination of the virtual address on a tlbr.${p}On a TLB-related exception, the VPN2 field is automatically set to the virtual address that was being translated when the exception occurred.${p}This field is written by software before a tlbp or tlbwi and written by hardware in all other cases.'), Field('0', Bits(10, 8), 'Must be written as zero; returns zero on read.'), Field('ASID', Bits(7, 0), "Address space identifier. This field is written by hardware on a TLB read and by software to establish the current ASID value for TLB write and against which TLB references match each entry's TLB ASID field. This field is per-TC field visible in TCStatus[TASID].")]}, 'The EntryHi register contains the virtual address match information used for TLB read, write, and access operations.', [], 32, Op('==', Reg('Config::MT'), 1)),
        Register('Context', 'cp0.4.0', '', {'': [Field('PTEBase', Bits(31, 23), 'Software-only bits can be used for page table base address.'), Field('BadVPN2', Bits(22, 4), '8K-page-identifying bits from the virtual address.'), Field('Reserved', Bits(3, 0))], 'proAptiv.*,P5600.*,interAptiv.*': [Field('PTEBase', Bits(31, 23), 'This field is for use by the operating system and is normally written with a value that allows the operating system to use the Context Register as a pointer into the current PTE array in memory.'), Field('BadVPN2', Bits(22, 4), 'This field is written by hardware on a TLB exception. It contains bits VA31:32-X+Y of the virtual address that caused the exception.'), Field('PTEBaseLow', Bits(3, 0), 'This field is for use by the operating system and is normally written with a value that allows the operating system to use the Context Register as a pointer into the current PTE array in memory.')]}, 'The Context register is a read/write register containing a pointer to an entry in the page table    entry (PTE) array.  This array is an operating system data structure that stores virtual-to-physical    translations.  During a TLB miss, the operating system loads the TLB with the missing translation from    the PTE array.  The Context register duplicates some of the information provided in the BadVAddr register    but is organized in such a way that the operating system can directly reference an 8-byte page table entry    (PTE) in memory.', [], 32, Op('==', Reg('Config::MT'), 1)),
        Register('BadVAddr', 'cp0.8.0', '', {'': []}, 'The BadVAddr register is a read-only register that captures the most recent virtual    address that caused one of the following exceptions:  Address error (AdEL or AdES),    TLB Refill, TLB Invalid (TLBL, TLBS)or TLB Modified.', [], 32, True, 'r'),
        Register('CMGCRBase32', 'cp0.15.3', 'CMGCRBase', {'': [Field('CMGCR_BASE_ADDR', Bits(31, 11), 'Bits 35:15 of the base physical address of the memory-mapped       Coherence Manager Global Configuration registers. The number of       implemented physical address bits is implementation-specific.       For the unimplemented address bits, writes are ignored, reads       return zero.', [], Bits(31, 15)), Field('0', Bits(10, 0), 'Must be written as zero; returns zero on read')], 'proAptiv.*,P5600.*,interAptiv.*': [Field('U', Bits(31, 28), 'Writes are ignored; returns zero on read'), Field('CMGCR_BASE_ADDR', Bits(27, 11), 'Bits 35:15 of the base physical address of the memory-mapped       Coherence Manager Global Configuration registers. The number of       implemented physical address bits is implementation-specific.       For the unimplemented address bits, writes are ignored, reads       return zero.', [], Bits(31, 15)), Field('0', Bits(10, 0), 'Must be written as zero; returns zero on read')]}, 'This register is used in a multi-core environment and defines the 36-bit     physical base address for the memory-mapped Coherence Manager Global Configuration     Register (CMGCR) space. This register only exists if Config3CMGCR is set.', [], 32, Op('==', Reg('Config3::CMGCR'), 1), 'r'),
        Register('CDMMBase32', 'cp0.15.2', 'CDMMBase', {'': [Field('CDMM_UPPER_ADDR', Bits(31, 11), 'Bits 35:15 of the base physical address of the memory-mapped registers. For the unimplemented address bits - writes are ignored, returns zero on read.', [], Bits(31, 15)), Field('EN', Bits(10), 'Enables the CDMM region.', [Value('CDMM Region is disabled', 0), Value('CDMM Region is enabled', 1)]), Field('CI', Bits(9), 'If set to 1, this indicates that the first 64-byte Device Register Block of the CDMM is reserved for additional registers which manage CDMM region behavior and are not IO device registers.'), Field('CDMMSize', Bits(8, 0), 'This field represents the number of 64-byte Device Register Blocks (DRB) that are instantiated in the core.  The number of blocks is equal to (CDMMSize + 1).')], '74K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*': [Field('U', Bits(31, 28), 'Writes are ignored; returns zero on read'), Field('CDMM_UPPER_ADDR', Bits(27, 11), 'Bits 31:15 of the base physical address of the memory-mapped registers.', [], Bits(31, 15)), Field('EN', Bits(10), 'Enables the CDMM region.', [Value('CDMM Region is disabled', 0), Value('CDMM Region is enabled', 1)]), Field('CI', Bits(9), 'If set to 1, this indicates that the first 64-byte Device Register Block of the CDMM is reserved for additional registers which manage CDMM region behavior and are not IO device registers.'), Field('CDMMSize', Bits(8, 0), 'This field represents the number of 64-byte Device Register Blocks (DRB) that are instantiated in the core.  The number of blocks is equal to (CDMMSize + 1).')]}, 'The physical base address for the Common Device Memory Map facility is defined by this register.  This register only exists if Config3.CDMM is set to one.', [], 32, Op('==', Reg('Config3::CDMM'), 1)),
        Register('KScratch6', 'cp0.31.7', '', {}, 'KScratch6 is a read-write 32-bit register that is used by the kernel for temporary storage of information.  Existence shown in Config4[KScrExist].', [], 32, Op('and', Reg('Config4::KScrExist'), 128)),
        Register('KScratch5', 'cp0.31.6', '', {}, 'KScratch5 is a read-write 32-bit register that is used by the kernel for temporary storage of information.  Existence shown in Config4[KScrExist].', [], 32, Op('and', Reg('Config4::KScrExist'), 64)),
        Register('KScratch4', 'cp0.31.5', '', {}, 'KScratch4 is a read-write 32-bit register that is used by the kernel for temporary storage of information.  Existence shown in Config4[KScrExist].', [], 32, Op('and', Reg('Config4::KScrExist'), 32)),
        Register('KScratch3', 'cp0.31.4', '', {}, 'KScratch3 is a read-write 32-bit register that is used by the kernel for temporary storage of information.  Existence shown in Config4[KScrExist].', [], 32, Op('and', Reg('Config4::KScrExist'), 16)),
        Register('KScratch2', 'cp0.31.3', '', {}, 'KScratch2 is a read-write 32-bit register that is used by the kernel for temporary storage of information.  Existence shown in Config4[KScrExist].', [], 32, Op('and', Reg('Config4::KScrExist'), 8)),
        Register('KScratch1', 'cp0.31.2', '', {}, 'KScratch1 is a read-write 32-bit register that is used by the kernel for temporary storage of information.  Existence shown in Config4[KScrExist].', [], 32, Op('and', Reg('Config4::KScrExist'), 4)),
        Register('ErrorEPC', 'cp0.30.0', '', {}, 'The ErrorEPC register is a read/write register, similar to the EPC register, except that ErrorEPC is used on error exceptions.  All bits of the ErrorEPC register are significant and must be writable.  It is also used to store the program counter on Reset, Soft Reset, and nonmaskable interrupt (NMI) exceptions.'),
        Register('EPC32', 'cp0.14.0', 'EPC', {'': []}, 'The Exception Program Counter (EPC) is a read/write register that contains the    address at which processing resumes after an exception has been serviced.'),
        Register('WatchLo7', 'cp0.18.7', '', 'WatchLoFields32', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi6::M'), 1)),
        Register('WatchLo6', 'cp0.18.6', '', 'WatchLoFields32', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi5::M'), 1)),
        Register('WatchLo5', 'cp0.18.5', '', 'WatchLoFields32', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi4::M'), 1)),
        Register('WatchLo4', 'cp0.18.4', '', 'WatchLoFields32', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi3::M'), 1)),
        Register('WatchLo3', 'cp0.18.3', '', 'WatchLoFields32', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi2::M'), 1)),
        Register('WatchLo2', 'cp0.18.2', '', 'WatchLoFields32', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi1::M'), 1)),
        Register('WatchLo1', 'cp0.18.1', '', 'WatchLoFields32', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi0::M'), 1)),
        Register('WatchLo0', 'cp0.18.0', '', 'WatchLoFields32', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.  This register is also called WatchLo on processors that only have a single Watch pair.', [], 32, Op('==', Reg('Config1::WR'), 1)),
        Register('DESAVE', 'cp0.31.0', '', {}, u'Software-only register, with no hardware effect. Provided because the debug exception handler can\u2019t use the k0-1 GP   registers, used by ordinary exception handlers to bootstrap themselves: but a debug handler can save a GPR into   DESAVE, and then use that GPR register in code which saves everything else', [], 32, Op('==', Reg('Config1::EP'), 1)),
        Register('DEPC', 'cp0.24.0', '', {}, 'The DEPC register is updated with the virtual address of         the instruction that caused the debug exception. If the         instruction is in the branch delay slot, then the virtual         address of the immediately preceding branch or jump         instruction is placed in this register.         Execution of the DERET instruction causes a jump to the         address in the DEPC.', [], 32, Op('==', Reg('Config1::EP'), 1)),
        Register('EBase', 'cp0.15.1', '', {'': [Field('Exception Base', Bits(29, 12), 'Exception base can only be in kseg0/kseg1.'), Field('CPUNum', Bits(9, 0), 'Specifies the number of the CPU in a multi-processor system.')], 'proAptiv.*,P5600.*,interAptiv.*': [Field('ExcException Base', Bits(31, 12), 'Exception Base Address.  The size and behavior of this field depends on the state of the WG bit.  When the WG bit is set, the ExcBase field includes bits 31:30 to facilitate programmable memory segmentation.  This field specifies the base address of the exception vectors when Status[BEV] is zero.  Bits 31:30 can be written only when WG is set.  When WG is zero, these bits are unchanged on a write.${p}When the WG bit is cleared, bits 31:30 of this field must be 2 10 to make sure the exception vector maps to kseg0 or kseg1, conventionally used for OS code.${p}In a multi-core, setting EBase in any CPU to a unique value allows that CPU can have its own unique exception handlers.${p}This field should be written only when Status[BEV] is set so that any exception will be handled through the ROM entry points.'), Field('WG', Bits(11), 'Write gate.  When the WG bit is set, the ExcBase field is expanded to include bits 31:30 of the EBase register to facilitate programmable memory segmentation controlled by the SegCtl0 through SegCtl2 registers.${p}When the WG bit is cleared, bits 31:30 of the EBase register are not writeable and remain unchanged from the last time that WG was cleared.'), Field('0', Bits(10), 'Must be written as zero; returns zero on read.'), Field('CPUNum', Bits(9, 0), 'This field contains an identifier that will be unique among the CPUs in a multiprocessor system.  The value in this field is set by the SI_CPUNum[9:0] static input pins to the Multiprocessing System core.')], 'M5150': [Field('1', Bits(31)), Field('0', Bits(30)), Field('Exception Base', Bits(29, 12), 'In conjunction with bits 31:30, this field specifies the base address                   of the exception vectors when StatusBEV is zero.'), Field('0', Bits(11, 10)), Field('CPUNum', Bits(9, 0), 'Specifies the number of the CPU in a multi-processor system and can be used                   by software to distinguish a particular processor from the others.')]}, 'EBase does two vital jobs: one is to allow software to know which CPU it is running on and the other is to relocate the exception entry points.  It is primarily supplied for multi-CPU systems.  The latter is necessary because CPUs sharing a memory map have their exception entry points in kseg0.  By setting EBase differently on each CPU, you can give them distinct exception handlers.', [], 32, Op('==', Reg('Config::AR'), 1)),
        Register('DebugContextID', 'cp0.4.4', '', {}, 'The Debug Context ID register can be written to by instrumented code in the OS to set the value to the new PID (process ID) or RTOS Task ID.', [], 32, CPUNameMatches('I6[45]00.*')),
        Register('L23TagLo_WSAccess', 'cp0.28.4', 'L23TagLo (WS Accesses)', {'interAptiv.*': [Field('DP', Bits(31, 24), 'Dirty Parity.'), Field('D', Bits(23, 16), 'Dirty.'), Field('LRU', Bits(15, 9), 'LRU algorithm. For Cache-Ops that access the LRU field, the associativity impacts the number of LRU bits present and how they affect line replacement and refill. The interAptiv core supports an 8-way set associative L2 cache.\\n\\nThe 8-way configuration uses all bits of the LRU field (15:9), but since it is a pseudo-LRU algorithm, the value of the LRU field does not directly correspond to the least-to-most order of the 8 ways.')]}, 'The L23TagLo register acts as the interface to the L2 or L3 cache tag array.  The Index Store Tag and Index Load Tag operations of the CACHE instruction use the L23TagLo register as the source of tag information.  Note that the 34K core does not implement the L23TagHi register.', [], 32, Or(Op('gt', Reg('Config2::SL'), 0), Op('==', Condition('Has_L2_Registers'), True))),
        Register('L23TagLo_TagAccess', 'cp0.28.4', 'L23TagLo (Tag Accesses)', {'proAptiv.*,P5600.*': [Field('DATA', Bits(31, 0), 'Data.')], 'interAptiv.*': [Field('Tag', Bits(31, 14), 'Tag.'), Field('TP', Bits(8), 'Total Parity.'), Field('V', Bits(7), 'Valid.'), Field('D', Bits(6), 'Dirty.'), Field('L', Bits(5), 'Lock.'), Field('P', Bits(4, 0), 'Parity.')]}, 'The L23TagLo register acts as the interface to the L2 or L3 cache tag array.  The Index Store Tag and Index Load Tag operations of the CACHE instruction use the L23TagLo register as the source of tag information.', [], 32, Or(Op('gt', Reg('Config2::SL'), 0), Op('==', Condition('Has_L2_Registers'), True))),
        Register('L23DataLo', 'cp0.28.5', '', {'interAptiv.*,proAptiv.*,P5600.*': [Field('DATA', Bits(31, 0), 'Low-order data read from the cache data array.')]}, 'The L23DataLo register is a register that acts as the interface to the L2 or L3 cache data array and is intended for diagnostic operations only.  The Index Load Tag operation of the CACHE instruction reads the corresponding data values into the L23DataLo register.  If the WST bit in the ErrCtl register is set, then the contents of L23DataLo can be written to the cache data array by doing an Index Store Data CACHE instruction.  If the SPR bit in the ErrCtl register is set, then the contents of L23DataLo can be written to the scratchpad RAM data array by doing an Index Store Data CACHE instruction.', [], 32, Or(And(Op('gt', Reg('Config2::SL'), 0), Or(CPUNameMatches('InterAptiv.*'), CPUNameMatches('ProAptiv.*'), CPUNameMatches('P5600.*'))), Op('==', Condition('Has_L2_Registers'), True))),
        Register('ITagLo_0_1_1', 'cp0.28.0', 'ITagLo (WST=0, SPR=1, tag=1)', {'proAptiv.*,P5600.*': [Field('Size', Bits(19, 12), 'When reading pseudo-tag 1 of a scratchpad RAM, this field indicates the size of the scratchpad array.  This field is the number of 4KB sections it contains.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.')], 'interAptiv.*': [Field('Size', Bits(19, 12), 'When reading pseudo-tag 1 of a scratchpad RAM, this field indicates the size of the scratchpad array. This field is the number of 4KB sections it contains. (Combined with bit 11:0, the register will contain the number of bytes in the scratchpad region).'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.')]}, 'The ITagLo register acts as the interface to the instruction cache tag array.  The Index Store Tag and Index Load Tag operations of the CACHE instruction use the ITagLo register as the source of tag information.\\n\\nWhen the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM.  In this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.', [], 32, Or(Op('==', Condition('Has_ITagLo_DTagLo'), True), Op('==', Condition('Has_ITagLo_Only'), True))),
        Register('ITagLo_0_1_0', 'cp0.28.0', 'ITagLo (WST=0, SPR=1, tag=0)', {'proAptiv.*,P5600.*': [Field('BasePA', Bits(31, 12), 'When reading pseudo-tag 0 of a scratchpad RAM, this field contains bits [31:12] of the base address of the scratchpad region.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('E', Bits(7), 'When reading pseudo-tag 0 of a scratchpad RAM, this bit indicates whether the scratchpad is enabled.'), Field('0', Bits(6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.')], 'interAptiv.*': [Field('BasePA', Bits(31, 12), 'When reading pseudo-tag 0 of a scratchpad RAM, this field will contain bits [31:12] of the base address of the scratchpad region.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('E', Bits(7), 'When reading pseudo-tag 0 of a scratchpad RAM, this bit indicates whether the scratchpad is enabled.'), Field('0', Bits(6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.')]}, 'The ITagLo register acts as the interface to the instruction cache tag array.  The Index Store Tag and Index Load Tag operations of the CACHE instruction use the ITagLo register as the source of tag information.\\n\\nWhen the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM.  In this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.', [], 32, Or(Op('==', Condition('Has_ITagLo_DTagLo'), True), Op('==', Condition('Has_ITagLo_Only'), True))),
        Register('ITagLo_1_0', 'cp0.28.0', 'ITagLo (WST=1, SPR=0)', {'proAptiv.*,P5600.*': [Field('LRU', Bits(15, 10), "When reading or writing the tag in way-select test mode (that is, with ErrCtl[WST] set), this field reads or writes the LRU ('least recently used') state bits, held in the way-select RAM."), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.')], 'interAptiv.*': [Field('WSLRU', Bits(15, 10), 'This field contains the value read from the WS array after a CACHE Index Load WS operation. It is used to store into the WS array during CACHE Index Store WS operations.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.')]}, 'The ITagLo register acts as the interface to the instruction cache tag array.  The Index Store Tag and Index Load Tag operations of the CACHE instruction use the ITagLo register as the source of tag information.\\n\\nWhen the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM.  In this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.', [], 32, Or(Op('==', Condition('Has_ITagLo_DTagLo'), True), Op('==', Condition('Has_ITagLo_Only'), True))),
        Register('ITagLo_0_0', 'cp0.28.0', 'ITagLo (WST=0, SPR=0)', {'proAptiv.*,P5600.*': [Field('PTagLo', Bits(31, 12), 'The cache address tag, which is a physical address because the proAptiv.*Multiprocessing System caches are physically tagged. It holds bits 31:12 of the physical address, i.e., the low-order 12 bits of the address are implied by the position of the data in the cache.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('V', Bits(7), 'Set to 1 if this cache entry is valid (set to zero to initialize the cache).'), Field('0', Bits(6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('L', Bits(5), 'Set to 1 to lock this cache entry, preventing it from being replaced by another line when a cache miss occurs.  Used when you have data so critical that it must be in the cache; however, it is quite costly, reducing the efficiency of the cache for memory data competing for space at this index.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.'), Field('P', Bits(0), 'Parity bit over the cache tag entries (excluding the D bit).')], 'interAptiv.*': [Field('PTagLo', Bits(31, 10), 'This field contains the physical address of the cache line. Bit 31 corresponds to bit 31 of the PA and bit 10 corresponds to bit 10 of the PA.\\n\\nBit 10 is only used when 4 KB caches are implemented. For other cache sizes, this bit will not exist in the tag and will be written as a 0 on IndexLoadTag operations.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('V', Bits(7), 'This field indicates whether the cache line is valid.'), Field('0', Bits(6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('L', Bits(5), 'Specifies the lock bit for the cache tag. When this bit is set, and the valid bit is set, the corresponding cache line will not be replaced by the cache replacement algorithm.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.'), Field('P', Bits(0), 'Specifies the parity bit for the cache tag. This bit is updated with tag array parity on CACHE Index Load Tag operations and used as tag array parity on Index Store Tag operations when the PO bit of the ErrCtl register is set.')]}, 'The ITagLo register acts as the interface to the instruction cache tag array.  The Index Store Tag and Index Load Tag operations of         the CACHE instruction use the ITagLo register as the source of tag information.${p}When the WST bit of the ErrCtl register is asserted,         this register becomes the interface to the way-selection RAM.  In this mode, the fields are redefined to give appropriate access the         contents of the WS array instead of the Tag array.', [], 32, Or(Op('==', Condition('Has_ITagLo_DTagLo'), True), Op('==', Condition('Has_ITagLo_Only'), True))),
        Register('ITagHi', 'cp0.29.0', '', {'proAptiv.*,P5600.*': [Field('PREC_67', Bits(31, 25)), Field('PREC_45', Bits(24, 18)), Field('PREC_23', Bits(17, 11)), Field('PREC_01', Bits(10, 4)), Field('P_67', Bits(3)), Field('P_45', Bits(2)), Field('P_23', Bits(1)), Field('P_01', Bits(0))]}, '', [], 32, Or(CPUNameMatches('74K.*'), CPUNameMatches('1074K.*'), CPUNameMatches('InterAptiv.*'), CPUNameMatches('ProAptiv.*'), CPUNameMatches('P5600.*'))),
        Register('IDataLo', 'cp0.28.1', '', {'proAptiv.*,interAptiv.*,P5600.*': [Field('DATA', Bits(31, 0), 'Low-order data read from the cache data array.')]}, 'The IDataLo register is a register that acts as the interface to the instruction cache data array and is intended for diagnostic operations only.  The Index Load Tag operation of the CACHE instruction reads the corresponding data values into the IDataLo register.  If the WST bit in the ErrCtl register is set, then the contents of IDataLo can be written to the cache data array by doing an Index Store Data CACHE instruction.  If the SPR bit in the ErrCtl register is set, then the contents of IDataLo can be written to the scratchpad RAM data array by doing an Index Store Data CACHE instruction.', [], 32, Or(Op('==', Condition('Has_ITagLo_DTagLo'), True), Op('==', Condition('Has_ITagLo_Only'), True), CPUNameMatches('5K.*'))),
        Register('ErrCtl', 'cp0.26.0', '', {'': [Field('PE', Bits(31), 'This bit is set to 1 to enable cache parity checking.  Hard-wired to zero if parity is not implemented.'), Field('PO', Bits(30), 'Parity Overwrite.  Set 1 to set the parity bit regardless of parity computation, which is only for diagnostic/test purposes.\\n\\nAfter setting this bit you can use cache IndexStoreTag to set the cache data parity to the value currently in PI (for I-cache) or PD (for D-cache), while the tag parity is forcefully set from ITagLoP/DTagLoP.'), Field('WST', Bits(29), 'Write to 1 for test mode for cache IndexLoadTag/cache IndexStoreTag instructions, which then read/write the cache internal way-selection RAM instead of the cache tags.'), Field('SPR', Bits(28), 'Scratchpad RAM.  When set, index-type cache instructions work on the scratchpad/DSPRAM/ISPRAM, if implemented.'), Field('PCO', Bits(27), 'Precode override.  Used for diagnostic/test of the instruction cache.  When this bit is set, then the precode values in the ITagHi register are used instead of the hardware generated precode values.  This applies to index store data cacheop operations.'), Field('ITC', Bits(26), '1 to use cacheops to access ITC storage locations.'), Field('LBE', Bits(25), 'Reads 1 after a bus error on load.'), Field('WABE', Bits(24), 'Reads 1 after a bus error on a cache read on a write miss.'), Field('L2EccEn', Bits(23), 'L2 cache ECC enable.  Indicates whether ECC is enabled on the L2Cache if present.  If the L2 cache is not present, this bit has no meaning.\\n\\n 0: L2 cache present, L2 ECC disabled\\n 1: L2 cache present, L2 ECC enabled.'), Field('PCD', Bits(22), 'Precode Disable.  When set, cache IndexStoreTag instructions do not update the corresponding precode field and precode parity in the instruction cache tag array.'), Field('DYT', Bits(21), "Setting this bit allows cache load/store data operations to work on the 'dirty array' of the slice of cache memory which holds the 'dirty'/'stored-into' bits."), Field('SE', Bits(20), 'Indicates that a second cache error was detected before the first error was processed.  This is an unrecoverable error.  This bit is set when a cache error is detected while the FE bit is set.  This bit is cleared on reset or when a cache error is detected with FE cleared.'), Field('FE', Bits(19), 'Indicates that this is the first cache error and therefore potentially recoverable.  Error handling software should clear this bit when the error has been processed.  This bit is cleared on reset.  Refer to SE bit description for implications of this bit.'), Field('0', Bits(18, 12), 'Reserved.  Must be written as zero; returns zero on read.'), Field('PI', Bits(11, 4), 'Parity bits being read/written to the instruction cache when PO is set.'), Field('PD', Bits(3, 0), 'Parity bits being read/written to the data cache when PO is set.')], 'M6200': [Field('EE', Bits(31), 'ECC Enable. If ECC is configured, this bit enables or disables ECC protection for SRAM.'), Field('SPR', Bits(28), 'When asserted, all Store Word (SW) instructions are redirected from the DS interface to the IS interface of the M6200 core.'), Field('PE', Bits(27), 'Parity Enable. If parity is configured, this bit enables or disables parity protection for SRAM.')], 'interAptiv.*': [Field('PE', Bits(31), 'Parity or ECC enable. This bit enables or disables the cache parity or ECC protection for both the instruction cache and the data cache. The selection of parity or ECC is done at build time and the result is stored in the L1ECC bit of this register.\\n\\nThis field is only writable if the cache parity option was implemented when the CPU was built. If cache parity or ECC is not supported, this field is always read as 0. Software can test for cache parity support by attempting to write a 1 to this field, then read back the value.'), Field('PO', Bits(30), 'Parity Overwrite.  Set 1 to set the parity bit regardless of parity computation, which is only for diagnostic/test purposes.\\n\\nAfter setting this bit you can use cache IndexStoreTag to set the cache data parity to the value currently in PI (for I-cache) or PD (for D-cache), while the tag parity is forcefully set from ITagLoP/DTagLoP.'), Field('WST', Bits(29), 'Write to 1 for test mode for cache IndexLoadTag/cache IndexStoreTag instructions, which then read/write the cache internal way-selection RAM instead of the cache tags.'), Field('SPR', Bits(28), 'Scratchpad RAM.  When set, index-type cache instructions work on the scratchpad/DSPRAM/ISPRAM, if implemented.'), Field('PCO', Bits(27), 'Precode override.  Used for diagnostic/test of the instruction cache.  When this bit is set, then the precode values in the ITagHi register are used instead of the hardware generated precode values.  This applies to index store data cacheop operations.'), Field('ITC', Bits(26), '1 to use cacheops to access ITC storage locations.'), Field('LBE', Bits(25), 'Reads 1 after a bus error on load. A Per-TC BE bit will indicate which TCs were impacted.'), Field('WABE', Bits(24), 'Reads 1 after a bus error on a cache read on a write miss. There is no indication of which TC(s) the store request came from. It is possible for both LBE and WABE to be set if the bus error was on a line being used for both loads and stores.'), Field('L2P', Bits(23), 'L2 ECC enable.  This bit can be set only if the L2 cache is ECC-capable. This bit, in conjunction with the PE bit, enables or disables the ECC protection for the L2 cache.'), Field('L1ECC', Bits(22), 'L1 ECC enabled. This bit indicates if the core was configured with ECC on the L1 data cache.'), Field('0', Bits(21), 'Must be written as zero; returns zero on read.'), Field('SE', Bits(20), 'Indicates that a second cache error was detected before the first error was processed.  This is an unrecoverable error.  This bit is set when a cache error is detected while the FE bit is set.  This bit is cleared on reset or when a cache error is detected with FE cleared.'), Field('FE', Bits(19), 'Indicates that this is the first cache error and therefore potentially recoverable.  Error handling software should clear this bit when the error has been processed.  This bit is cleared on reset.  Refer to SE bit description for implications of this bit.'), Field('PCI', Bits(18, 13), 'Instruction precode bits being read/written to the instruction cache data RAM.'), Field('PI', Bits(12, 4), 'Parity bits being read/written to the instruction cache data RAM.\\n\\nBit 12 - Even parity bit for the pre-code bits.\\nBits 11:4 - Per-byte even parity bits for the 64b of data.'), Field('PD', Bits(3, 0), 'Parity bits being read/written to the data cache data RAM. PD[0] is even parity for the least-significant byte of the requested data. This field is 0 if L1 data cache ECC is implemented as indicated by the L1ECC bit of this register.')], 'proAptiv.*,P5600.*': [Field('PE', Bits(31), 'This bit is set to 1 to enable cache parity checking.  Hard-wired to zero if parity is not implemented.'), Field('PO', Bits(30), 'Parity Overwrite.  Set 1 to set the parity bit regardless of parity computation, which is only for diagnostic/test purposes.\\n\\nAfter setting this bit you can use cache IndexStoreTag to set the cache data parity to the value currently in PI (for I-cache) or PD (for D-cache), while the tag parity is forcefully set from ITagLoP/DTagLoP.'), Field('WST', Bits(29), "Write to 1 for test mode for cache IndexLoadTag/cache IndexStoreTag instructions, which then read/write the cache's internal way-selection RAM instead of the cache tags."), Field('SPR', Bits(28), 'Scratchpad RAM.  When set, index-type cache instructions work on the scratchpad/DSPRAM/ISPRAM, if implemented.'), Field('PCO', Bits(27), 'Precode override.  Used for diagnostic/test of the instruction cache.  When this bit is set, then the precode values in the ITagHi register are used instead of the hardware generated precode values.  This applies to index store data cacheop operations.'), Field('0', Bits(26), 'Reserved.  Must be written as zero; returns zero on read.'), Field('LBE', Bits(25), 'Reads 1 after a bus error on load.'), Field('WABE', Bits(24), 'Reads 1 after a bus error on a cache read on a write miss.'), Field('L2EccEn', Bits(23), 'L2 cache ECC enable.  Indicates whether ECC is enabled on the L2Cache if present.  If the L2 cache is not present, this bit has no meaning.\\n\\n 0: L2 cache present, L2 ECC disabled\\n 1: L2 cache present, L2 ECC enabled.'), Field('PCD', Bits(22), 'Precode Disable.  When set, cache IndexStoreTag instructions do not update the corresponding precode field and precode parity in the instruction cache tag array.'), Field('DYT', Bits(21), "Setting this bit allows cache load/store data operations to work on the 'dirty array' of the slice of cache memory which holds the 'dirty'/'stored-into' bits."), Field('SE', Bits(20), 'Indicates that a second cache error was detected before the first error was processed.  This is an unrecoverable error.  This bit is set when a cache error is detected while the FE bit is set.  This bit is cleared on reset or when a cache error is detected with FE cleared.'), Field('FE', Bits(19), 'Indicates that this is the first cache error and therefore potentially recoverable.  Error handling software should clear this bit when the error has been processed.  This bit is cleared on reset.  Refer to SE bit description for implications of this bit.'), Field('0', Bits(18, 12), 'Reserved.  Must be written as zero; returns zero on read.'), Field('PI', Bits(11, 4), 'Parity bits being read/written to the instruction cache when PO is set.'), Field('PD', Bits(3, 0), 'Parity bits being read/written to the data cache when PO is set.')], 'M5150': [Field('PE', Bits(31), 'Parity Enable. This bit enables or disables the parity protectionfor both the instruction caches/SPRAM and the data           caches/SPRAM .           ${p}This field is only write-able if the parity option was implemented when the M5150 was built. If parity is not supported,           this field is always read as 0. Software can test for parity support by attempting to write a 1 to this field, then           read back the value.'), Field('PO', Bits(30), 'Parity Overwrite. If set, the PI/PD fields of this register overwrites calculated parity for the data array. In addition,           the P field of the TagLo register overwrites calculated parity for the tag array. This bit only has significance during           CACHE Index Store Tag and CACHE Index Store Data operations.'), Field('WST', Bits(29), 'Indicates whether the tag array or the way-select array should be read/written on Index Load/Store Tag CACHE           instructions. Also enables the Index Store Data CACHE instruction which writes the contents of DataLo to the data array.'), Field('SPR', Bits(28), 'Forces indexed CACHE instructions to operate on the ScratchPad RAM instead of the cache'), Field('PI', Bits(7, 4), 'Parity bit read from or written to instruction cache data RAM.'), Field('PD', Bits(3, 0), 'Parity bits read from or written to data cache data RAM.')], 'M6250': [Field('EE', Bits(31), 'ECC Enable. If ECC is configured, this bit enables or disables ECC protection for caches/SPRAM. If SPRAM is configured, ISP_ECCPresent/DSP_ECCPresent must be asserted before EE is asserted.'), Field('EO', Bits(30), 'ECC Overwrite. When ECC is enabled, this bit controls whether or not to allow software to override hardware-generated ECC bits via the IDataLoECC, and DDataLoECC, ITagHi, DTagHi and DDataHiECC registers, when the CACHE Index Store Tag and CACHE Index Store Data operations are executed.'), Field('WST', Bits(30), 'This bit indicates whether the tag array or the way-select array should be read/written on Index Load/Store Tag CACHE instructions.'), Field('SPR', Bits(28), 'When asserted, all Store Word (SW) instructions are redirected from the DS interface to the IS interface of the M6250 core.'), Field('PE', Bits(27), 'Parity Enable. If parity is configured, this bit enables or disables parity protection for the bus.')], 'M5100': [Field('PE', Bits(31), 'This bit is set to 1 to enable cache parity checking.  Hard-wired to zero if parity is not implemented.'), Field('0', Bits(30, 0), 'Reserved.  Must be written as zero; returns zero on read.')]}, 'The ErrCtl register controls parity protection of data and instruction caches and provides for software testing of the way-selection and scratchpad RAMs.', [], 32, Not(CPUNameMatches('M4K.*'))),
        Register('DTagLo_0_1_1', 'cp0.28.2', 'DTagLo (WST=0, SPR=1, tag=1)', {'interAptiv.*': [Field('Size', Bits(19, 12), 'When reading pseudo-tag 1 of a scratchpad RAM, this field indicates the size of the scratchpad array. This field is the number of 4KB sections it contains. (Combined with the 0 in 11:0, the register will contain the number of bytes in the scratchpad region).')]}, 'The DTagLo register acts as the interface to the data cache tag array.  The Index Store Tag and Index Load Tag operations of the CACHE instruction use the DTagLo register as the source of tag information.\\n\\nWhen the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM.  In this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.', [], 32, Op('==', Condition('Has_ITagLo_DTagLo'), True)),
        Register('DTagLo_0_1_0', 'cp0.28.2', 'DTagLo (WST=0, SPR=1, tag=0)', {'proAptiv.*,P5600.*': [Field('PTAG', Bits(31, 12), 'This field contains bits [31:12] of the base address of the scratchpad region.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('E', Bits(7), 'This bit indicates whether the scratchpad is enabled.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.')], 'interAptiv.*': [Field('BasePA', Bits(31, 12), 'When reading pseudo-tag 0 of a scratchpad RAM, this field will contain bits [31:12] of the base address of the scratchpad region.'), Field('E', Bits(7), 'When reading pseudo-tag 0 of a scratchpad RAM, this bit indicates whether the scratchpad is enabled.')]}, 'The DTagLo register acts as the interface to the data cache tag array.  The Index Store Tag and Index Load Tag operations of the CACHE instruction use the DTagLo register as the source of tag information.\\n\\nWhen the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM.  In this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.', [], 32, Op('==', Condition('Has_ITagLo_DTagLo'), True)),
        Register('DTagLo_1_0', 'cp0.28.2', 'DTagLo (WST=1, SPR=0)', {'proAptiv.*,P5600.*': [Field('LP', Bits(23, 20), 'Parity for Cache-line locking control bits, held in the way select RAM. Each bit of this field is a parity bit for the corresponding bit in the L field.'), Field('L', Bits(19, 16), 'Cache-line locking control bits, held in the way select RAM.'), Field('LRU', Bits(15, 10), 'This field contains the LRU (least recently used) state bits, held in the way select RAM.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.')], 'interAptiv.*': [Field('WSDP', Bits(23, 20), 'Dirty Parity (Optional). This field contains the value read from the WS array during a CACHE Index Load WS operation.\\nIf the PO field of the ErrCtl register is asserted, then this field is used to store the dirty parity bits during a CACHE Index Store WS operation.'), Field('WSD', Bits(19, 16), 'Dirty bits. This field contains the value read from the WS array after a CACHE Index Load WS operation. It is used to store into the WS array during CACHE Index Store WS operations.'), Field('WSLRU', Bits(15, 10), 'LRU bits. This field contains the value read from the WS array after a CACHE Index Load WS operation. It is used to store into the WS array during CACHE Index Store WS operations.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('R', Bits(4, 3), 'Reserved.  Must be written as zero; returns zero on read.')]}, 'The DTagLo register acts as the interface to the data cache tag array.  The Index Store Tag and Index Load Tag operations of the CACHE instruction use the DTagLo register as the source of tag information.\\n\\nWhen the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM.  In this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.', [], 32, Op('==', Condition('Has_ITagLo_DTagLo'), True)),
        Register('DTagLo_0_0', 'cp0.28.2', 'DTagLo (WST=0, SPR=0)', {'proAptiv.*,P5600.*': [Field('PTagLo', Bits(31, 12), u'The cache address tag \u2014 a physical address because the caches are physically tagged. It holds bits 31-12 of the physical address \u2014 the low 12 bits of the address are implied by the position of the data in the cache.'), Field('VA11', Bits(11), 'This bit always gets the virtual address bit [11] of the tag if the index load tag cache instruction is executed.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('V', Bits(7), 'This field indicates whether the cache line is valid.'), Field('E', Bits(6), 'This bit is set if this cache entry is exclusive (set zero to initialize the cache).'), Field('L', Bits(5), 'Specifies the lock bit for the cache tag. When this bit is set, and the valid bit is set, the corresponding cache line will not be replaced by the cache replacement algorithm.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.'), Field('P', Bits(0), 'Parity bit over the PTAG, E, and V bits of the cache tag entries.')], 'interAptiv.*': [Field('PTagLo', Bits(31, 10), 'This field contains the physical address of the cache line. Bit 31 corresponds to bit 31 of the PA and bit 10 corresponds to bit 10 of the PA.\\n\\nBit 10 is only used when 4 KB caches are implemented. For other cache sizes, this bit will not exist in the tag and will be written as a 0 on IndexLoadTag operations.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('V', Bits(7), 'This field indicates whether the cache line is valid.'), Field('D', Bits(6), 'This field indicates whether the cache line is dirty. It will only be set if bit 7 (valid) is also set. For L1 I-cache, this field must be written as zero and returns zero on read.'), Field('L', Bits(5), 'Specifies the lock bit for the cache tag. When this bit is set, and the valid bit is set, the corresponding cache line will not be replaced by the cache replacement algorithm.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.'), Field('P', Bits(0), 'Specifies the parity bit for the cache tag. This bit is updated with tag array parity on CACHE Index Load Tag operations and used as tag array parity on Index Store Tag operations when the PO bit of the ErrCtl register is set.\\nThis parity does not cover the dirty bit; the dirty bit has a separate parity bit placed in the way selection RAM.\\nNote that this bit is read only when L1 data cache ECC is enabled.')]}, 'The DTagLo register acts as the interface to the data cache tag array.  The Index Store Tag and Index Load Tag operations of the CACHE instruction use the DTagLo register as the source of tag information.\\n\\nWhen the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM.  In this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.', [], 32, Op('==', Condition('Has_ITagLo_DTagLo'), True)),
        Register('DTagHi', 'cp0.29.2', '', {}, '', [], 32, Or(CPUNameMatches('74K.*'), CPUNameMatches('1074K.*'), CPUNameMatches('InterAptiv.*'))),
        Register('DDataHi', 'cp0.29.3', '', {}, '', [], 32, Not(CPUNameMatches('M5100')))],
 '64': [Register('ra', '', '', {}, 'Return address for subroutine.', [], 64),
        Register('s8', '', '', {}, "Frame pointer; compilers sometimes generate code which access subroutine variables with this register as an index.\\n\\nRegister is sometimes referenced as's8'.", [], 64),
        Register('sp', '', '', {}, 'Stack pointer; compilers sometimes generate code which access subroutine variables by a constant offset from sp.\\n\\nThe stack grows from high addresses to low addresses.', [], 64),
        Register('gp', '', '', {}, 'Global pointer; some runtime systems maintain this to give easy access to (some) static or extern variables.', [], 64),
        Register('k1', '', '', {}, 'Reserved for use by interrupt/trap handler; may change under your feet.', [], 64),
        Register('k0', '', '', {}, 'Reserved for use by interrupt/trap handler; may change under your feet.', [], 64),
        Register('s7', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.', [], 64),
        Register('s6', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.', [], 64),
        Register('s5', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.', [], 64),
        Register('s4', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.', [], 64),
        Register('s3', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.', [], 64),
        Register('s2', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.', [], 64),
        Register('s1', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.', [], 64),
        Register('s0', '', '', {}, 'Subroutine register variable; a subroutine that writes one of these must save the old value and restore it before it exits, so the calling routine sees the values preserved.', [], 64),
        Register('t9', '', '', {}, 'Temporary, subroutines can use without saving.', [], 64),
        Register('t8', '', '', {}, 'Temporary, subroutines can use without saving.', [], 64),
        Register('t3', '', '', {}, 'Temporary, subroutines can use without saving.', [], 64),
        Register('t2', '', '', {}, 'Temporary, subroutines can use without saving.', [], 64),
        Register('t1', '', '', {}, 'Temporary, subroutines can use without saving.', [], 64),
        Register('t0', '', '', {}, 'Temporary, subroutines can use without saving.', [], 64),
        Register('a7', '', '', {}, 'Argument, More parameters for a subroutine.', [], 64),
        Register('a6', '', '', {}, 'Argument, More parameters for a subroutine.', [], 64),
        Register('a5', '', '', {}, 'Argument, More parameters for a subroutine.', [], 64),
        Register('a4', '', '', {}, 'Argument, More parameters for a subroutine.', [], 64),
        Register('a3', '', '', {}, 'Argument, First few parameters for a subroutine.', [], 64),
        Register('a2', '', '', {}, 'Argument, First few parameters for a subroutine.', [], 64),
        Register('a1', '', '', {}, 'Argument, First few parameters for a subroutine.', [], 64),
        Register('a0', '', '', {}, 'Argument, First few parameters for a subroutine.', [], 64),
        Register('v1', '', '', {}, 'Value returned by subroutine.', [], 64),
        Register('v0', '', '', {}, 'Value returned by subroutine.', [], 64),
        Register('UserLocal64', 'cp0.4.2', 'UserLocal', {}, 'UserLocal is a read-write 64-bit register that is not interpreted by the hardware and conditionally readable by software.    This register is suitable for a kernel-maintained ID whose value can be read by user-level code with    rdhwr 29, as long as HWRENAUL is set.', [], 64, Op('==', Reg('Config3::ULRI'), 1)),
        Register('LLAddr', 'cp0.17.0', '', {'': [Field('PAddr', Bits(43, 2), 'This field encodes the physical address read by the most recent Load Linked instruction.      The format of this register is implementation-dependent, and an implementation may      implement as many of the bits or format the address in any way that it finds convenient.      LLAddr[1] is always aligned to PA[5], which implies that PAddr is always 32-byte      aligned. This implementation has 48 physical address bits, therefore this field covers      PAddr[47:6].'), Field('LLB', Bits(0), 'LLB is set when the LL instruction is executed. The SC instructions and other hardware events may clear LLB. This field allows the LLbit to be software accessible. LLB can be cleared by software but cannot be set.')]}, 'The LLAddr register stores the physical address (to the enclosing 32-byte block) of the target location of any     LL/SC sequence. This register is readable purely for diagnostic reasons. This register is used by the hardware to properly    handle LL/SC sequences by monitoring if the memory location has potentially been written between the LL and SC    instructions.', [], 64, CPUNameMatches('I6[45]00.*,P6600.*'), 'r'),
        Register('XContextConfig', 'cp0.4.3', '', {'P6600.*': [Field('VirtualIndex', Bits(38, 2), 'A mask of 0 to 37 contiguous 1 bits in this field causes the corresponding      bits of the XContext register to be written with the highorder      bits of the virtual address causing a TLB exception.      Behavior of the processor is UNDEFINED if non-contiguous 1      bits are written into the register field. Note that it is the responsibility      of software to ensure that this field is written with contiguous      ones because if non-contiguous 1 bits are written, no exception      will be taken.'), Field('0', Bits(1, 0), 'Must be written as zero; returns zero on read.')]}, '', [], 64, Or(CPUNameMatches('P6600.*'))),
        Register('XContextP6600', 'cp0.20.0', 'XContext', {}, 'The XContext register is a read/write register containing a pointer to an entry in the page table entry (PTE) array. This   array is an operating system data structure that stores virtual-to-physical translations. During a TLB miss, the operating   system loads the TLB with the missing translation from the PTE array. The XContext register is primarily   intended for use with the XTLB Refill handler, but is also loaded by hardware on a TLB Refill. However, it is   unlikely to be useful to software in the TLB Refill Handler. The XContext register duplicates some of the information   provided in the BadVaddr register. The size of the BadVPN2 field, indicated by the X-1:Y parameter in the figure   below, depends on the number of consecutive ones in the XContextConfig register.', [], 64, CPUNameMatches('P6600.*')),
        Register('XContextI6400', 'cp0.20.0', 'XContext', {'': [Field('Undefined', Bits(31, 0), 'Undefined for this processor')], 'I6[45]00.*': [Field('PTEBase', Bits(63, 41), 'This field is for use by the operating system and is normally written with a      value that allows the operating system to use the Context Register as a pointer into      the current PTE array in memory.'), Field('BadVPN2', Bits(38, 4), 'This field is written by hardware on a TLB exception. It contains bits VA[31:13]     of the virtual address that caused the exception')]}, 'The XContext register is a read/write register containing a pointer to an entry in the page table entry (PTE) array. This   array is an operating system data structure that stores virtual-to-physical translations. During a TLB miss, the operating   system loads the TLB with the missing translation from the PTE array. The XContext register is primarily   intended for use with the XTLB Refill handler, but is also loaded by hardware on a TLB Refill.', [], 64, CPUNameMatches('I6[45]00.*')),
        Register('PWSize', 'cp0.5.7', '', {'': [Field('0', Bits(31), 'This field must be written as zero; returns zero on read.'), Field('PS', Bits(30), 'Pointer Size. This is only used by the 64-bit architectures. For the 32-bit architectures, this bit is fixed to 0.'), Field('BDW', Bits(37, 32), 'Base Directory index. This field is encoded as follows:{$p}      0: No read is performed using the base directory index.{$nl}      0x01 - 0x3F: The number of bits to be extracted from BadVAddr to create an index into the base directory. The least significant bit of the field is specified by      the PWField.BDI field.'), Field('GDW', Bits(29, 24), 'Global Directory index width. This field is encoded as follows:           0: No read is performed using Global Directory index.           0x01 - 0x 3F: A non-zero number in this field indicates the number of bits to be           extracted from BadVAddr to create an index into the Global Directory. The           least significant bit of the field is specified by PWFieldGDI.'), Field('UDW', Bits(23, 18), 'Upper Directory index width.           0: No read is performed using Upper Directory index.           0x01 - 0x 3F: A non-zero number in this field indicates the number of bits to be           extracted from BadVAddr to create an index into the Upper Directory. The           least significant bit of the field is specified by PWFieldUDI.'), Field('MDW', Bits(17, 12), 'Middle Directory index width.           0: No read is performed using Middle Directory index.           0x01 - 0x 3F: A non-zero number in this field indicates the number of bits to be           extracted from BadVAddr to create an index into the Middle Directory. The           least significant bit of the field is specified by PWFieldMDI.'), Field('PTW', Bits(11, 6), 'Page Table index width. This field is encoded as follows:           0: UNPREDICTABLE. A value of 0 in this field causes unpredictable behavior.           This field should have a non-zero value.           1: Number of bits to be extracted from BadVAddr to create an index into the           Page Table. The least significant bit of the field is specified by PWFieldPTI.'), Field('PTEW', Bits(5, 0), 'Specifies the left shift applied to the Page Table index, in addition to the shift           required to account for the native data size of the machine.           The set of available shifts is implementation-dependent. Software can discover           the available values by writing this field. If the requested shift value is not           available, PTEW will be written as zero. A shift of one must be implemented')], 'P6600.*': [Field('0', Bits(31), 'This field must be written as zero; returns zero on read.'), Field('PS', Bits(30), 'Pointer Size. This is only used by the 64-bit architectures. For the 32-bit architectures, this bit is fixed to 0.'), Field('BDW', Bits(37, 32), 'Base Directory index. This field is encoded as follows:{$p}      0: No read is performed using the base directory index.{$nl}      0x01 - 0x3F: The number of bits to be extracted from BadVAddr to create an index into the base directory. The least significant bit of the field is specified by      the PWField.BDI field.'), Field('GDW', Bits(29, 24), 'Global Directory index width. This field is encoded as follows:           0: No read is performed using Global Directory index.           0x01 - 0x 3F: A non-zero number in this field indicates the number of bits to be           extracted from BadVAddr to create an index into the Global Directory. The           least significant bit of the field is specified by PWFieldGDI.'), Field('UDW', Bits(23, 18), 'Upper Directory index width.           0: No read is performed using Upper Directory index.           0x01 - 0x 3F: A non-zero number in this field indicates the number of bits to be           extracted from BadVAddr to create an index into the Upper Directory. The           least significant bit of the field is specified by PWFieldUDI.'), Field('MDW', Bits(17, 12), 'Middle Directory index width.           0: No read is performed using Middle Directory index.           0x01 - 0x 3F: A non-zero number in this field indicates the number of bits to be           extracted from BadVAddr to create an index into the Middle Directory. The           least significant bit of the field is specified by PWFieldMDI.'), Field('PTW', Bits(11, 6), 'Page Table index width. This field is encoded as follows:           0: UNPREDICTABLE. A value of 0 in this field causes unpredictable behavior.           This field should have a non-zero value.           1: Number of bits to be extracted from BadVAddr to create an index into the           Page Table. The least significant bit of the field is specified by PWFieldPTI.'), Field('PTEW', Bits(5, 0), 'Specifies the left shift applied to the Page Table index, in addition to the shift           required to account for the native data size of the machine.           The set of available shifts is implementation-dependent. Software can discover           the available values by writing this field. If the requested shift value is not           available, PTEW will be written as zero. A shift of one must be implemented')]}, 'The PWSize register configures hardware page table walking for TLB refills. It is used in combination with the         PWBase and PWField registers. ${nl}         The hardware page walk feature supports multi-level page tables - up to four directory levels plus one page table         level. The lowest level of any page table system is an array of Page Table Entries (PTEs). This array is known as a         Page Table (PT) and is indexed using bits from the faulting address. A single-level page table system contains only a         single Page Table.         ${nl}A multi-level page table system contains multiple levels, the lowest of which are Page Table Entries. Levels above         the lowest Page Table level are known as Directories. A directory consists of an array of pointers. Each pointer in a         directory is either to another directory or to a Page Table.         ${nl}The Page Table and the Directories are indexed by bits extracted from the faulting address BadVAddr. The PWBase         register contains the base address of the first Directory or Page Table which will be accessed. The PWSize register         specifies the number of index bits to be used for each level. The PWField register specifies the location of the index         fields in BadVAddr.         ${nl}Index values used to access Directories are multiplied by the 32-bit native pointer size for the refill. When PWSizePS         = 0, the native pointer size is 32 bits (2 bit left shift), and hardware page table walking is applied only when the TLB         exception would be taken. When PWSizePS = 1, the native pointer size is 64 bits (3 bit left shift), and hardware page         Atable walking is applied only when a TLB Refill exception would be taken.         ${nl}The index value used to access the Page Table is multiplied by the native pointer size. An additional multiplier (left         shift value) can be specified using the PWSizePTEW field. This allows space to be allocated in the Page Table structure         for software-managed fields.', [], 64, Op('==', Reg('Config3::PW'), 1)),
        Register('PWField', 'cp0.5.6', '', {'': [Field('0', Bits(31, 30), 'This field must be written as zero; returns zero on read.'), Field('GDI', Bits(29, 24), 'Global Directory index. Least significant bit of the index field extracted from           the faulting address, which is used to index into the Global Directory. The number           of index bits is specified by PWSizeGDW.'), Field('UDI', Bits(23, 18), 'Upper Directory index. Least significant bit of the index field extracted from           the faulting address, which is used to index into the Upper Directory. The number           of index bits is specified by PWSizeUDW.'), Field('MDI', Bits(17, 12), 'Middle Directory index. Least significant bit of the index field extracted from           the faulting address, which is used to index into the Middle Directory. The           number of index bits is specified by PWSizeMDW.'), Field('PTI', Bits(11, 6), 'Page Table index. Least significant bit of the index field extracted from the           faulting address, which is used to index into the Page Table. The number of           index bits is specified by PWSizePTW.'), Field('PTEI', Bits(5, 0), 'Page Table Entry shift. Specifies the logical right shift and rotation which will be applied to Page Table           Entry values loaded by hardware page table walking.${p}           The entire PTE is logically right shifted by PTEI-2 bits first. The purpose of           this shift is to remove the software-only bits from what will be written into the           TLB entry. Then the two least-significant bits of the shifted value are rotated           into position for the RI and XI protection bit locations within the TLB entry.           ${nl}A value of 2 means rotate the right-most 2 bits into the RI/XI bit positions for the TLB entry.           ${nl}A value of 3 means logical shift right by 1 bit the entire PTE and then rotate the           right-most 2 bits into the RI/XI positions for the TLB entry.           ${nl}A value of 4 means logical shift right by 2bits the entire PTE and then rotate the right-most 2 bits into the RI/XI positions for the TLB entry.           ${p}In the P5600 core, the values of 1 and 0 in this field are RESERVED and           should not be used; the operation of the page table walker is UNPREDICTABLE           for these cases.           ${p}If the PTEI value is larger than the width of EntryLo0, then the value is treated           as value-32. For example, a PTEI value of 34 is interpreted as PTEI = 2. The           values of 33 and 32 are RESERVED and should not be used; the operation of           the HW Page Walker is UNPREDICTABLE for these cases.           ${p}The set of available non-zero shifts is implementation-dependent. Software can           discover the available values by writing this field. If the requested shift value is           not available, PTEI will remain unchanged. A shift of zero must be implemented.')]}, 'The PWField register configures hardware page table walking for TLB refills. It is used in combination with the         PWBase and PWSize registers.${p}         The hardware page walker supports multi-level page tables - up to four directory levels plus one page table level. The         lowest level of any page table system is an array of Page Table Entries (PTEs). This array is known as a Page Table         (PT) and is indexed using bits from the faulting address. A single-level page table system contains only a single Page         Table.${p}         A multi-level page table system consists of multiple levels, the lowest level being the Page Table Entries. Levels         above the lowest Page Table level are known as Directories. A directory consists of an array of pointers. Each pointer         in a directory is either to another directory or to a Page Table.${p}         The Page Table and the Directories are indexed by bits extracted from the faulting address. The PWBase register contains         the base address of the first Directory or Page Table which will be accessed. The PWSize register specifies the         number of index bits to be used for each level. The PWField register specifies the location of the index fields in the         faulting address. This PWField register only exists if Config3PW = 1.${p}         If a synchronous exception condition is detected on a read operation during hardware page-table walking, the automated         process is aborted and a TLB Refill exception is taken.', [], 64, Op('==', Reg('Config3::PW'), 1)),
        Register('PWBase', 'cp0.5.5', '', {'': [Field('PWBase', Bits(31, 0), 'Page Table Base address pointer.')]}, 'The PWBase register contains the Page Table Base virtual address, used as the starting point for hardware page table         walking. It is used in combination with the PWField and PWSize registers.', [], 64, Op('==', Reg('Config3::PW'), 1)),
        Register('PageMask', 'cp0.5.0', '', {'': [], 'I6[45]00.*': [Field('Mask', Bits(30, 13), "The Mask field is a bit mask in which a '1' bit indicates that the corresponding bit of     the virtual address should not participate in the TLB match.")], 'P6600.*': [Field('Mask', Bits(32, 0), 'The mask field is a bit mask in which a logic 1 indicates that the corresponding     bit of the virtual address should not participate in the TLB match. Note that     only a restricted range of PageMask values are legal (i.e., with 1s filling the     PageMaskMask field from low bits upward, two at a time).     Maximum page size is 4 GB', [Value('16 Kbytes', 24576), Value('64 Kbytes', 122880), Value('256 Kbytes', 516096), Value('1 Mbyte', 2088960), Value('4 Mbytes', 8380416), Value('16 Mbytes', 33546240), Value('64 Mbytes', 134209536), Value('256 Mbytes', 536862720), Value('1 Gbytes', 2147475456), Value('4 Gbytes', 8589926400L)])]}, 'Every TLB entry has an independent virtual-address mask that allows it to ignore some address bits when deciding to   match. By selectively ignoring lower page addresses, the entry can be made to match all the addresses in a page   larger than 4KB.${p}   Software can determine the maximum page size supported by writing all ones to the PageMask register, then reading   the value back. If a pair of bits reads back as ones, the processor implements that page size. Note that the bits are read   in pairs, so bits 14:13 are read first and can have only a value of 00 or 11. If they are both 11, bits 16:15 are read, and   so on.', [], 64, Or(Op('==', Reg('Config::MT'), 1), Op('==', Reg('Config::MT'), 4))),
        Register('GlobalNumber', 'cp0.3.1', '', {'I6[45]00.*': [Field('ClusterNum', Bits(19, 16), 'A unique number asssigned to a cluster of cores in the system. Reserved if clustering     is not implemented. Unimplemented bits in the field are not writeable; reads return 0.     This field is read-only, but can be preset, or optionally can be programmed by a register     external to COP0 through a memory-mapped register.'), Field('CoreNum', Bits(11, 8), 'A unique number assigned to a physical core in a cluster. Unimplemented bits     in the field are not writeable; reads return 0.     This field is read-only, but can be preset, or optionally can be programmed by a     register external to COP0 through a memory-mapped register.'), Field('VPId', Bits(7, 0), 'A unique number assigned to a virtual processor in a core. Unimplemented bits     in the field are not writeable; reads return 0. The number of unimplemented bits     is dependent on whether contiguous or non-contiguous numbering is supported.     If contiguous, then VPId size equals ceiling (log2 (total VP count in cluster) ).     If non-contiguous, then VPId size equals log2 (maximum VP cont of any core).     This field is read-only, but can be preset, or optionally can be programmed by a     register external to COP0 through a memory-mapped register.')]}, 'Global Identifiers', [], 32, True, 'r'),
        Register('EntryLo1', 'cp0.3.0', '', 'EntryLoTemplate64', 'These registers store the contents of a TLB entry.  Each entry maps a pair of pages.  The EntryLo0 and EntryLo1 register store even and odd numbered virtual pages respectively.  The register contents are written to the TLB during a tlbwr or tblwi instruction, and updated by a tlbr instruction.  They are not used for any other purpose.', [], 64, Or(Op('==', Reg('Config::MT'), 1), Op('==', Reg('Config::MT'), 4))),
        Register('EntryLo0', 'cp0.2.0', '', 'EntryLoTemplate64', 'These registers store the contents of a TLB entry.  Each entry maps a pair of pages.  The EntryLo0 and EntryLo1 register store even and odd numbered virtual pages respectively.  The register contents are written to the TLB during a tlbwr or tblwi instruction, and updated by a tlbr instruction.  They are not used for any other purpose.', [], 64, Or(Op('==', Reg('Config::MT'), 1), Op('==', Reg('Config::MT'), 4))),
        Register('EntryHi', 'cp0.10.0', '', {'': [Field('Reserved', Bits(63, 0), 'Undefined for this core')], 'I6[45]00.*,P6600.*': [Field('R', Bits(63, 62), 'Virtual memory region, corresponding to VA[63:62]. This field is written      by hardware on a TLB exception or on a TLB read, and is written     by software before a TLB write.', [Value('xuseg: user address region', 0), Value('xsseg: supervisor address region', 1), Value('Reserved', 2), Value('xkseg: kernel address region', 3)]), Field('VPN2', Bits(47, 13), 'VA[47:13] of the virtual address (virtual page number / 2). This field is written by hardware on a TLB      exception or on a TLB read, and is written by software before a TLB write.'), Field('VPN2X', Bits(12, 11), '1 kB pages are not implemented', [], None, 'I6[45]00.*'), Field('EHINV', Bits(10), 'TLBWI invalidate enable.  When this bit is set, the TLBWI instruction acts as a      TLB invalidate operation, setting the hardware valid bit associated with the TLB entry      to the invalid state.  When this bit is set, the PageMask and EntryLo0/EntryLo1 registers      do not need to be valid.  Only the Index register is required to be valid.${p}This bit      is ignored on a TLBWR instruction.'), Field('ASIDX', Bits(9, 8), 'Address space identifier extension. The function of this field depends on the state of the     AE bit in the Config4 register as follows: This field extends the width of the ASID value by 2 bits.      In this case, the ASID value is stored in bits 9:0 of this register.', [], None, 'I6[45]00.*'), Field('ASID', Bits(7, 0), u'Address space identifier. This field is used to stage data to and from the     TLB, but in normal running software it\u2019s also the source of the current     ASID value, used to extend the virtual address and help to map address     translations for the current process.     This field is written by hardware on a TLB read and by software to establish     the current ASID value for TLB write and against which TLB references     match each entry\u2019s TLB ASID field.     This field supports up to 256 unique ASID values, consisting of a virtual     tag that is in addition to the 32-bit address.')]}, 'The EntryHi register contains the virtual address match information used for TLB read, write, and access operations.', [], 64, Or(Op('==', Reg('Config::MT'), 1), Op('==', Reg('Config::MT'), 4))),
        Register('ContextI6400', 'cp0.4.0', 'Context', {'': [Field('PTEBase', Bits(63, 23), 'This field is for use by the operating system and is normally written with a      value that allows the operating system to use the Context Register as a pointer into      the current PTE array in memory.'), Field('BadVPN2', Bits(22, 4), 'This field is written by hardware on a TLB exception. It contains bits VA[31:13]     of the virtual address that caused the exception')]}, 'The Context register is a read/write register containing a pointer to an entry in the page table    entry (PTE) array.  This array is an operating system data structure that stores virtual-to-physical    translations.  During a TLB miss, the operating system loads the TLB with the missing translation from    the PTE array.  The Context register duplicates some of the information provided in the BadVAddr register    but is organized in such a way that the operating system can directly reference an 8-byte page table entry    (PTE) in memory..', [], 64, CPUNameMatches('I6[45]00.*')),
        Register('ContextP6600', 'cp0.4.0', 'Context', {}, 'The 64-bit Context register is a read/write register containing a pointer to an entry in the page table entry (PTE) array.   This array is an operating system data structure that stores virtual-to-physical translations. During a TLB miss, the   operating system loads the TLB with the missing translation from the PTE array. The Context register duplicates   some of the information provided in the BadVAddr register but is organized in such a way that the operating system   can directly reference an 8-byte page table entry (PTE) in memory.${p}   The BadVPN2 field of the Context register is not defined after an address error exception, and this field may be modified   by hardware during the address error exception sequence.${p}   The pointer implemented by the Context register can point to any power-of-two-sized PTE structure within memory.   This allows the TLB refill handler to use the pointer without additional shifting and masking steps. For example, if   the low-order bit of the PTEBase field is 20, the page table entry (PTE) structure occurs on a 1M boundary. If the   low-order bit is 21, PTE structure occurs on a 2M boundary, etc. Depending on the value in the ContextConfig register,   it may point to an 8-byte pair of 32-bit PTEs within a single-level page table scheme, or to a first level page directory   entry in a two-level lookup scheme.${p}   A TLB exception (Refill, Invalid, Modified, Read Inhibit, Execute Inhibit) causes the virtual address to be written to   a variable range of bits, defined as (X-1):Y of the Context register. This range corresponds to the contiguous range of   set bits in the ContextConfig register. Bits 63:X, Y-1:0 are read/write to software and are unaffected by the exception.   For example, if X = 23 and Y = 4, i.e. bits 22:4 are set in ContextConfig, the behavior is identical to the standard   MIPS32 Context register (bits 22:4 are filled with VA31:13). Although the fields have been made variable in size and   interpretation, the MIPS32 nomenclature is retained. Bits 63:X are referred to as the PTEBase field, and bits X-1:Y   are referred to as BadVPN2.${p}   The value of the Context register is UNPREDICTABLE following a modification of the contents of the   ContextConfig register. After the ContextConfig register is modified, software should write the PTEBase field of the   Context register. However, note that the contents of the BadVPN2 field will not be valid until the next TLB exception.', [], 64, CPUNameMatches('P6600.*')),
        Register('BadVAddr', 'cp0.8.0', '', {'': []}, 'Bad virtual address. This register stores the virtual address that causes one of the   TLB exceptions.', [], 64, True, 'r'),
        Register('CMGCRBase64', 'cp0.15.3', 'CMGCRBase', {'I6[45]00.*': [Field('CMGCR_BASE_PHYSICAL_ADDR', Bits(43, 11), 'This field contains 47:15 of the base physical address of      the memory-mapped Coherence Manager GCR registers.      This register field reflects the value of the GCR_BASE      field within the memory-mapped Coherence Manager      GCR Base Register.', [], Bits(47, 15))], 'P6600.*': [Field('CMGCR_BASE_ADDR', Bits(35, 11), 'Bits 39:15 of the base physical address of the memory-mapped       Coherence Manager Global Configuration registers. The number of       implemented physical address bits is implementation-specific.       For the unimplemented address bits, writes are ignored, reads       return zero.', [], Bits(39, 15))]}, 'This register is used in a multi-core environment and defines the 36-bit physical base address for the memory-mapped   Coherence Manager Global Configuration Register (CMGCR) space. This register only exists if Config3CMGCR is   set.', [], 64, Op('==', Reg('Config3::CMGCR'), 1), 'r'),
        Register('CDMMBase64', 'cp0.15.2', 'CDMMBase', {'I6[45]00.*': [Field('CDMM_UPPER_ADDR', Bits(43, 11), 'Bits 47:15 of the base physical address of the memory-mapped registers.', [], Bits(47, 15)), Field('EN', Bits(10), 'Enables the CDMM region. If this bit is cleared, memory requests to     this address region go to regular system memory. If this bit is set,     memory requests to this region go to the CDMM logic.', [Value('CDMM Region is disabled', 0), Value('CDMM Region is enabled', 1)]), Field('CI', Bits(9), 'If set to 1, this indicates that the first 64-byte Device Register Block of the CDMM is reserved for additional registers which manage CDMM region behavior and are not IO device registers.'), Field('CDMMSize', Bits(8, 0), 'This field represents the number of 64-byte Device Register Blocks (DRB) that are instantiated in the core.  The number of blocks is equal to (CDMMSize + 1).')], 'P6600.*': [Field('CDMM_UPPER_ADDR', Bits(35, 11), 'Bits 39:15 of the base physical address of the common device     memory-mapped registers', [], Bits(39, 15)), Field('EN', Bits(10), 'Enables the CDMM region. If this bit is cleared, memory requests to     this address region go to regular system memory. If this bit is set,     memory requests to this region go to the CDMM logic.', [Value('CDMM Region is disabled', 0), Value('CDMM Region is enabled', 1)]), Field('CI', Bits(9), 'If set to 1, this indicates that the first 64-byte Device Register Block of the CDMM is reserved for additional registers which manage CDMM region behavior and are not IO device registers.'), Field('CDMMSize', Bits(8, 0), 'This field represents the number of 64-byte Device Register Blocks (DRB) that are instantiated in the core.  The number of blocks is equal to (CDMMSize + 1).')]}, 'The physical base address for the Common Device Memory Map facility is defined by this register.  This register only exists if Config3.CDMM is set to one.', [], 64, Op('==', Reg('Config3::CDMM'), 1)),
        Register('KScratch6', 'cp0.31.7', '', {}, 'KScratch6 is a read-write 64-bit register that is used by the kernel for temporary storage of information.', [], 64),
        Register('KScratch5', 'cp0.31.6', '', {}, 'KScratch5 is a read-write 64-bit register that is used by the kernel for temporary storage of information.', [], 64),
        Register('KScratch4', 'cp0.31.5', '', {}, 'KScratch4 is a read-write 64-bit register that is used by the kernel for temporary storage of information.', [], 64),
        Register('KScratch3', 'cp0.31.4', '', {}, 'KScratch3 is a read-write 64-bit register that is used by the kernel for temporary storage of information.', [], 64),
        Register('KScratch2', 'cp0.31.3', '', {}, 'KScratch2 is a read-write 64-bit register that is used by the kernel for temporary storage of information.', [], 64),
        Register('KScratch1', 'cp0.31.2', '', {}, 'KScratch1 is a read-write 64-bit register that is used by the kernel for temporary storage of information.', [], 64),
        Register('ErrorEPC', 'cp0.30.0', '', {}, 'The ErrorEPC register is a read/write register, similar to the EPC register, except that ErrorEPC is used on error exceptions.  All bits of the ErrorEPC register are significant and must be writable.  It is also used to store the program counter on Reset, Soft Reset, and nonmaskable interrupt (NMI) exceptions.', [], 64),
        Register('EPC64', 'cp0.14.0', 'EPC', {'': []}, 'Exception Program Counter. Contains the address at which processing resumes    after an exception has been serviced. Unless the EXL bit in the Status register   is already a 1, hardware writes the EPC register when an exception occurs.${p}   For synchronous (precise) exceptions, EPC contains either:${p}   ${tab}1. the virtual address of the instruction that was the direct cause of the exception, or${nl}   ${tab}2. the virtual address of the immediately preceding branch or jump instruction, when the exception   causing instruction is in a branch delay slot, and the Branch Delay bit in the Cause register is set.${p}   For asynchronous (imprecise) exceptions, EPC contains the address of the instruction at which to   resume execution.${p}   The processor reads the EPC register as the result of execution of the ERET instruction. Software may   write the EPC register to change the processor resume address and read the EPC register to determine   at what address the processor will resume.', [], 64),
        Register('WatchLo3_I6400', 'cp0.18.3', 'WatchLo3', 'WatchLoFields64', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 64, And(Op('==', Condition('WatchLoX64Cores'), True), Op('==', Reg('WatchHi2::M'), 1))),
        Register('WatchLo2_I6400', 'cp0.18.2', 'WatchLo2', 'WatchLoFields64', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 64, And(Op('==', Condition('WatchLoX64Cores'), True), Op('==', Reg('WatchHi1::M'), 1))),
        Register('WatchLo1_I6400', 'cp0.18.1', 'WatchLo1', 'WatchLoFields64', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 64, And(Op('==', Condition('WatchLoX64Cores'), True), Op('==', Reg('WatchHi0::M'), 1))),
        Register('WatchLo0_I6400', 'cp0.18.0', 'WatchLo0', 'WatchLoFields64', 'Used in conjunction with WatchHi0-3 respectively, each of these registers carries the virtual address and what-tomatch    fields for a CP0 watchpoint. WatchLo0-1 are used for instruction side accesses and WatchLo2-3 are used for    data side accesses. The bit assignments for each of the WatchLo registers is identical.', [], 64, And(Op('==', Condition('WatchLoX64Cores'), True), Op('==', Reg('Config1::WR'), 1))),
        Register('DESAVE64', 'cp0.31.0', 'DESAVE', {}, 'The Debug Exception Save (DeSave) register is a read/write register that functions as a simple memory location.  This register is used by the debug exception handler to save one of the GPRs, which is then used to save the rest of the context to a pre-determined memory area (such as in the EJTAG Probe).  This register allows the safe debugging of exception handlers and other types of code where the existence of a valid stack for context saving cannot be assumed.', [], 64, Op('==', Reg('Config1::EP'), 1)),
        Register('DEPC64', 'cp0.24.0', 'DEPC', {}, 'The DEPC register is a read-write register that contains the address at which processing   resumes after a debug exception has been serviced. All bits of the DEPC register are significant   and must be writable.${p}   When a debug exception occurs, the processor writes the DEPC register with: (1)   the virtual address of the instruction that was the direct cause of the exception, or   (2) the virtual address of the immediately preceding branch or jump instruction, when the   exception causing instruction is in a branch delay slot, and the Debug Branch Delay bit   (DBD) in the Debug register is set.${p}   The processor reads the DEPC register as the result of execution of the DERET instruction.${p}   Software may write the DEPC register to change the processor resume address and read   the DEPC register to determine at what address the processor will resume.', [], 64, Op('==', Reg('Config1::EP'), 1)),
        Register('EBase', 'cp0.15.1', '', {'': [Field('Undefined', Bits(63, 0), 'Not defined for this processor')], 'I6[45]00.*,P6600.*': [Field('ExcBase', Bits(63, 12), 'Exception Base Address.  The size and behavior of this field depends on the state of the WG bit.  When the WG bit is set, the ExcBase field includes bits 31:30 to facilitate programmable memory segmentation.  This field specifies the base address of the exception vectors when Status[BEV] is zero.  Bits 31:30 can be written only when WG is set.  When WG is zero, these bits are unchanged on a write.${p}When the WG bit is cleared, bits 31:30 of this field must be 2 10 to make sure the exception vector maps to kseg0 or kseg1, conventionally used for OS code.${p}In a multi-core, setting EBase in any CPU to a unique value allows that CPU can have its own unique exception handlers.${p}This field should be written only when Status[BEV] is set so that any exception will be handled through the ROM entry points.'), Field('WG', Bits(11), 'When the WG bit is set, the ExcBase field is expanded to include bits 63:30 of     the EBase register to facilitate programmable memory segmentation controlled     by the SegCtl0 through SegCtl2 registers. When the WG bit is cleared, bits 63:30 of      the EBase register are not writeable and remain unchanged from the last time that      WG was cleared.'), Field('CPUNum', Bits(9, 0), u'This field contains an identifier that will be unique among the CPU\u2019s in a multiprocessor     system. The value in this field is set by the SI_CPUNum[9:0] static     input pins to the P6600 core.', [], None, 'P6600'), Field('VPNum', Bits(9, 0), 'Virtual Processor Number. VPNum is used to indicate the virtual processor number', [], None, 'I6400,I6500')]}, 'The 64-bit EBase register is a read/write register containing the base address of the exception vectors used when   StatusBEV equals 0, and a read-only CPU number value that may be used by software to distinguish different processors   in a multi-processor system.${p}    The EBase register provides the ability for software to identify the specific processor within a multi-processor system,   and allows the exception vectors for each processor to be different. Bits 63:12 of the EBase register are concatenated   with zeros to form the base of the exception vectors when StatusBEV is 0. The exception vector base address   comes from the fixed defaults when StatusBEV is 1, or for any EJTAG Debug exception.${p}   The size of the ExcBase field depends on the state of the WG bit. At reset, the WG bit is cleared by default. In this   case, the ExcBase field is comprised of bits 29:12. Bits 63:30 of the EBase Register are not writeable and retain their   previous state.${p}   When the WG bit is set, bits 63:30 of the ExcBase field become writeable and are used to relocate the ExcBase field   to other segments. This is shown in Figure 2.11. Note that if the WG bit is set by software (allowing bits 63:30 to   become part of the ExcBase field) and then cleared, bits 63:30 can no longer be written by software and the state of   these bits remains unchanged for any writes after WG was cleared.${p}   If the value of the exception base register is to be changed, this must be done with StatusBEV equal to 1. The operation   of the processor is UNDEFINED if the exception base field is written with a different value when StatusBEV is   0.${p}   Combining bits 63:12 with the Exception Base field allows the base address of the exception vectors to be placed at   any 16 Kbyte page boundary.', [], 64, Op('==', Reg('Config::AR'), 2)),
        Register('CacheErrP6600', 'cp0.27.0', 'CacheErr', {'': [Field('EREC', Bits(31, 30), u'This 2-bit field indicates the block where the error occurred.     The FTLB parity error sets the EREC field to \u2018b11, and sets either the ED or ET     bits indicating a data or tag parity error (not both). It also updates the Index (bits     16:0) and Way (bits 21:19) fields. The other bits are left as 0. Note that the index     field contains the FTLB set and not the index value from the CP0 Index register.', [Value('L1 Instruction Cache', 0), Value('External Cache', 1), Value('L1 Data Cache', 2), Value('FTLB Parity', 3)]), Field('ED/ET', Bits(29, 28), 'The encoding of these two bits depends on the state of the EREC field above. If     the state of this feld contains an encoding of 00, 01, or 10, indicating a cache     error, the encoding of this field is as shown below.${p}     ${tab}00: No tag or data RAM error detected${nl}     ${tab}01: Primary tag RAM error${nl}     ${tab}10: Data RAM error${nl}     ${tab}11: Duplicate tag RAM error${p}     A parity error in the FTLB tag sets the ET bit (28), while a parity error in the     FTLB data sets the ED bit (29). One or both of these bits may be set.'), Field('ES', Bits(27), 'Error source. In a multi-core system, this bit reads 0 if the error was caused by     one of the cores and 1 if the error was caused by an external snoop request.     In a single-core system, this bit is not used.'), Field('EE', Bits(26), 'Error external: In a multi-core system, this bit indicates that a parity error was     seen on a coherent L1 cache in another CPU. In a single-core system, this bit is not used.'), Field('EB/EM', Bits(25), 'If EREC equals 0 indicating an error in the L1 cache, this bit is EB, indicating     an error in Both caches. If data and instruction-fetch errors are reported on the     same instruction, it is unrecoverable. If so, the rest of the register reports on the     instruction-fetch error.${p}     If EREC equals 1, indicating an error in the L2 cache, this bit is EM, indicating     there are errors in multiple locations in the cache.'), Field('EF', Bits(24), "Unrecoverable (fatal) error (other than the EB type above). Some parity errors     can be fixed by invalidating the cache line and relying on good data from memory.     However, if this bit is set, it indicates the error cannot be fixed. Here are     some possible scenarios of when the EF bit might be set by hardware:${p}     * Dirty parity error in dirty line being displaced from cache.${nl}     * Line being displaced from cache has a tag parity error.${nl}     * The line being displaced from cache tag indicates it has been written by the     CPU since it was obtained from memory (the line is 'dirty' and needs a writeback),     but it has a data parity error.${nl}     * Writeback store miss and CacheErrEW error.${nl}     * At least one more cache error happened concurrently with or after this one,${nl}     but before the original error reached the cache error exception handler.     * If EREC equals 0, and a second L2 error occurs when an earlier L2 error is     pending.${nl}"), Field('EW', Bits(22), 'Parity error on way-selection RAM array.'), Field('Way', Bits(21, 19), 'If EREC equals 0, bit 19 is unused. Bits 21:20 indicate the way-number of the     cache entry where the error occurred.${p}     If EREC equals 1, indicating an L2 or higher-level cache error, bits 21:19 indicate     the way-number of the cache entry where the error occurred.     On a FTLB error, bits 20:19 indicate the number of ways in each set. Bit 21 is     not used on a FTLB error.'), Field('DR', Bits(18), "A 1 bit indicates that the reported error affected the cache-line 'dirty' bits. This     bit is only meaningful in case of an L1 data cache access."), Field('Index', Bits(16, 0), "The cache index or Scratchpad RAM index of the double word entry where the     error occurred. The way of the faulty cache is written by hardware in the Way     field. The CacheErr bits [16:0] represents the Address index bits [19:3].${p}     The index-type cache instruction will need an 'index' with the way bits glued     on top of this cache-entry field; you know how to put that together, because the     shape of the cache is defined in the Config1-2 registers.${p}     On a TLB error, this field indicates the number of sets in the FTLB. The number     of bits is implementation dependent and is always right-justified in the Index     field.")]}, '', [], 32, Or(CPUNameMatches('P6600.*')), 'r'),
        Register('ErrCTLP6600', 'cp0.26.0', 'ErrCTL', {'': [Field('PE', Bits(31), 'Parity/ECC enable. This bit enables or disables ECC protection for the L1 I-Cache, L1 D-Cache, and FTLB'), Field('PO', Bits(30), 'Parity Override. When this bit is set, the CACHE Index Store     Tag operation will use the ECC values provided by the DTagLo,     DDataHi or ITagLo, IDataHi registers instead of generating ECC     in hardware'), Field('WST', Bits(29), u'Write to 1 for test mode for cache IndexLoadTag/     cache IndexStoreTag instructions, which then read/write the cache\u2019s     internal way-selection RAM instead of the cache tags.'), Field('PCO', Bits(27), 'Precode Override. When this bit is set, the CACHE Index Store     Tag operation to the L1 I-Cache will use the precode values from     the IDataHi register instead of generating precode in hardware.'), Field('LBE', Bits(25), u"Indicates whether a bus error (the last one, if there\u2019s been more than one) was     triggered by a load. This bits is 'sticky', remaining set until explicitly written zero."), Field('WABE', Bits(24), u"Indicates whether a bus error (the last one, if there\u2019s been more than one) was     triggered by a write-allocate. A write-allocate is where a     cacheable write has missed in the cache, and the cache has read the line from memory.     This bits is 'sticky', remaining set until explicitly written zero."), Field('L2P', Bits(23), 'L2 cache parity enable. Indicates whether parity is enabled on the L2Cache if     present. If the L2 cache is not present, this bit has no meaning.', [Value('L2 cache present, L2 parity disabled', 0), Value('L2 cache present, L2 parity enabled', 1)]), Field('PCD', Bits(22), 'Precode Disable. When set, cache IndexStoreTag instructions do     not update the corresponding precode field and precode parity in the instruction     cache tag array.'), Field('DYT', Bits(21), u"Setting this bit allows cache load/store data operations to work on the 'dirty     array' \u2014 the slice of cache memory which holds the 'dirty'/'stored-into' bits."), Field('SE', Bits(20), 'Indicates that a second cache or TLB error was detected before the first error     was processed. This is an unrecoverable error. This bit is set when a cache error     is detected while the FE bit is set. This bit is cleared on reset or when a cache     error is detected with FE cleared.'), Field('FE', Bits(19), 'Indicates that this is the first cache or TLB error and therefore potentially     recoverable. Error handling software should clear this bit when the error has     been processed. This bit is set by hardware and cleared by software on reset.     Refer to the SE bit description for implications of this bit.     Note that software can only write a 0 to this bit. A write value of 1 will not have     any effect.'), Field('PI', Bits(11, 4), 'Parity bits per double-word (two instructions) of data being read/written to the     instruction cache data when the PO bit is set. During a read of IDataHi and     IDataLo registers, the parity bits are stored here.     This field is updated by hardware on every instruction fetch and also during a     CacheOp store.     During a CacheOp store, this field can be used for instruction cache data parity     error injection apart from the Instruction cache store index.     During a CacheOp read, this field can be used to check/read the instruction     cache parity bits and also for storing the parity bits when an index load tag is     executed.'), Field('PD', Bits(3, 0), 'Parity bits being read/written to the data cache when PO is set.')]}, 'Most of the fields of this register are for test software only. The MIPS64 architecture defines this register as implementation-   dependent, but most CPUs put the parity-enable control in the top bit. So running OS software is well   advised to set this register to 0x8000.0000 to enable cache parity checking, or to zero to disable parity checking.', [], 32, Or(CPUNameMatches('P6600.*'))),
        Register('L23DataHiP6600', 'cp0.29.5', 'L23DataHi', {'': []}, 'On P6600 family cores, test software can read or write cache data using a cache index load/store data instruction.   Which word of the cache line is transferred depends on the low address fed to the cache instruction.', [], 32, CPUNameMatches('P6600.*')),
        Register('L23DataLoP6600', 'cp0.28.5', 'L23DataLo', {'': []}, 'The L23DataLo register is a register that acts as the interface to the L2 or L3 cache data array and is intended for diagnostic   operations only. The Index Load Tag operation of the CACHE instruction reads the corresponding data values   into the L23DataLo register. If the WST bit in the ErrCtl register is set, then the contents of L23DataLo can be written   to the cache data array by doing an Index Store Data CACHE instruction.   The core can be configured without L2/L3 cache support. In this case, this register will be a read-only register that   reads as 0.   On P6600 family cores, test software can read or write cache data using a cache index load/store data instruction.   Which word of the cache line is transferred depends on the low address fed to the cache instruction.', [], 32, CPUNameMatches('P6600.*')),
        Register('L23TagLoWAP6600', 'cp0.28.4', 'L23TagLo (WS Accesses)', {'': [Field('DP', Bits(31, 24), 'Dirty Parity'), Field('D', Bits(23, 16), 'Dirty'), Field('LRU', Bits(15, 9), 'LRU algorithm. For Cache-Ops that access the LRU field, the associativity     impacts the number of LRU bits present and how they     affect line replacement and refill. The P6600 core supports an 8-     way set associative L2 cache.${p}     The 8-way configuration uses all bits of the LRU field (15:9), but     since it is a pseudo-LRU algorithm, the value of the LRU field does     not directly correspond to the least-to-most order of the 8 ways.')]}, 'The L23TagLo register acts as the interface to the L2 or L3 cache tag array. The L2 and L3 Index Store Tag and Index    Load Tag operations of the CACHE instruction use the L23TagLo register as the source of tag information. Note that    the P6600 CPU does not implement the L23TagHi register', [], 64, CPUNameMatches('P6600.*')),
        Register('L23TagLoTAP6600', 'cp0.28.4', 'L23TagLo (Tag Accesses)', {'': [Field('Tag', Bits(39, 14)), Field('TP', Bits(8), 'Total Parity'), Field('V', Bits(7), 'Valid'), Field('D', Bits(6), 'Dirty'), Field('L', Bits(5), 'Lock'), Field('P', Bits(4, 0), 'Parity')]}, 'The L23TagLo register acts as the interface to the L2 or L3 cache tag array. The L2 and L3 Index Store Tag and Index    Load Tag operations of the CACHE instruction use the L23TagLo register as the source of tag information. Note that    the P6600 CPU does not implement the L23TagHi register', [], 64, CPUNameMatches('P6600.*')),
        Register('DDataLoP6600', 'cp0.28.3', 'DDataLo', {'': []}, '', [], 64, Or(CPUNameMatches('P6600.*'))),
        Register('DTagLoWST0DYT1', 'cp0.28.2', 'DTagLo (WST=0, DYT=1)', {'': [Field('DP', Bits(23, 20), "Parity for Cache line 'dirty' bits.     Index Load: load from DP field of Dirty RAM;     Index Store: store to DP field of Dirty RAM if ErrCtlPO=1, else generate;"), Field('D', Bits(19, 16), "Cache line 'dirty' bits.     Index Load: load from D field of Dirty RAM;     Index Store: store to D field of Dirty RAM"), Field('A', Bits(11, 10), "Cache line 'alias' bits.     Index Load: load from A field of Dirty RAM;     Index Store: store 0 and A[10] to A field of Dirty RAM")]}, "The 64-bit DTagLo register acts as the interface to the data cache tag array. The Index Store Tag and Index Load Tag   operations of the CACHE instruction use the DTagLo register as the source of tag information.${p}   When the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM. In   this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.   These registers are a staging location for cache tag information being read/written with cache load-tag/store-tag   operations.${p}   The D-cache has five logical memory arrays associated with this DTagLo register. The tag RAM stores tags and other   state bits with special attention to the needs of the CPU. The duplicate tag RAM also stores tags and state, but is optimized   for the needs of interventions. Both of these arrays are set-associative (4-way). The Dirty RAM and duplicate   Dirty RAM store the dirty bits (indicating modified data) for intervention uses, and each combine their ways together   in a single entry per set. The WS RAM also combines the lock and LRU data in a single entry per set. Accessing these   arrays for index cache loads and stores is controlled by using three bits in the ErrCtl register to create modes that   allow the correct access to these arrays.${p}   Note that the P6600 core does not implement the DTagHi register.${p}   The interpretation of this register changes depending on the settings of ErrCtlWST and ErrCtlDYT.${p}   ${tab}1. Default cache interface mode (ErrCtlWST = 0, ErrCtlDYT = 0)${nl}   ${tab}2. Diagnostic 'way select test mode' (ErrCtlWST = 1, ErrCtlDYT = 0)${nl}   ${tab}2. Diagnostic 'dirty array test mode' (ErrCtlWST = 0, ErrCtlDYT = 1)${p}   For all modes, the data RAM, tag RAM, WS RAM, and duplicate tag RAM are read. In addition, for duplicate tag   array test mode, the duplicate tag RAM is also read, and for duplicate dirty array test mode, the duplicate Dirty RAM   is read.${p}   The dirty RAM is another slice of the cache memory (distinct from the tag and data arrays). Test software can access   either by cache load-tag/store-tag operations when ErrCtlDYT is set: then you get the data in these fields. For stores,   the Dirty RAM is written. For stores, the Dirty RAM and duplicate Dirty RAM are written. Also for stores, the   ErrCtlPO bit controls whether the Dirty RAM is written with DP bits or with generated parity; the other RAMs written   in this mode always use generated parity.", [], 64, CPUNameMatches('P6600.*')),
        Register('DTagLoWST1DYT0', 'cp0.28.2', 'DTagLo (WST=1, DYT=0)', {'': [Field('LP', Bits(23, 20), 'Parity for Cache-line locking control bits, held in the way select RAM.     Each bit of this field is a parity bit for the corresponding bit in the L field.     Index Load: load from LP field of WS RAM; Index Store: store to appropriate way of LP field of WS RAM if     ErrCtlPO=1, else generate;'), Field('L', Bits(19, 16), 'Cache-line locking control bits, held in the way select RAM.     Index Load: load from L field of WS RAM; Index Store: store to appropriate way of L field of WS RAM.'), Field('LRU', Bits(15, 10), "When reading or writing the tag in way select test mode (that is, with     ErrCtlWST set) this field reads or writes the LRU ('least recently used')     state bits, held in the way select RAM. Index Load: load from LRU field of WS RAM;     Index Store: store to LRU field of WS RAM")]}, u"The 64-bit DTagLo register acts as the interface to the data cache tag array. The Index Store Tag and Index Load Tag   operations of the CACHE instruction use the DTagLo register as the source of tag information.${p}   When the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM. In   this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.   These registers are a staging location for cache tag information being read/written with cache load-tag/store-tag   operations.${p}   The D-cache has five logical memory arrays associated with this DTagLo register. The tag RAM stores tags and other   state bits with special attention to the needs of the CPU. The duplicate tag RAM also stores tags and state, but is optimized   for the needs of interventions. Both of these arrays are set-associative (4-way). The Dirty RAM and duplicate   Dirty RAM store the dirty bits (indicating modified data) for intervention uses, and each combine their ways together   in a single entry per set. The WS RAM also combines the lock and LRU data in a single entry per set. Accessing these   arrays for index cache loads and stores is controlled by using three bits in the ErrCtl register to create modes that   allow the correct access to these arrays.${p}   Note that the P6600 core does not implement the DTagHi register.${p}   The interpretation of this register changes depending on the settings of ErrCtlWST and ErrCtlDYT.${p}   ${tab}1. Default cache interface mode (ErrCtlWST = 0, ErrCtlDYT = 0)${nl}   ${tab}2. Diagnostic 'way select test mode' (ErrCtlWST = 1, ErrCtlDYT = 0)${nl}   ${tab}2. Diagnostic 'dirty array test mode' (ErrCtlWST = 0, ErrCtlDYT = 1)${p}   For all modes, the data RAM, tag RAM, WS RAM, and duplicate tag RAM are read. In addition, for duplicate tag   array test mode, the duplicate tag RAM is also read, and for duplicate dirty array test mode, the duplicate Dirty RAM   is read.${p}   The way-select RAM is an independent slice of the cache memory (distinct from the tag and data arrays). Test software   can access either by cache load-tag/store-tag operations when ErrCtlWST is set: then you get the data in these   fields. For stores in this mode, the WS RAM is written. Also for stores, the ErrCtlPO bit controls whether the WS   RAM is written with LP bits or with generated parity; the other RAMs written in this mode always use generated parity.   Also for stores, the LP and L fields only have the appropriate way written in the WS RAM. It is software\u2019s   responsibility to maintain consistency with the value of the L field written into the duplicate tag RAM.", [], 64, CPUNameMatches('P6600.*')),
        Register('DTagLoWST0DYT0', 'cp0.28.2', 'DTagLo (WST=0, DYT=0)', {'': [Field('PTagLo', Bits(39, 12), u'The cache address tag \u2014 a physical address because the P6600 caches     are physically tagged. It holds bi ts 39:12 of the physical address. The     low 12 bits of the address are implied by the position of the data in the     cache.'), Field('VA11', Bits(11), 'This bit always gets the virtual address bit [11] of the tag if the index load tag cache instruction is executed.'), Field('V', Bits(7), 'Valid entry: This bit is set if this cache entry is valid (set zero to initialize the cache).     Index Load: load from V field in primary tag RAM     Index Store: store to V field in primary and duplicate tag RAM'), Field('E', Bits(6), 'Exclusive entry: This bit is set if this cache entry is exclusive (set zero to initialize the cache).     Index Load: load from E field in primary tag RAM     Index Store: store to E field in primary tag RAM'), Field('L', Bits(5), u'Locked entry: This bit is set to lock this cache entry, preventing it from     being replaced by another line when there\u2019s a cache miss. Done when you     have data so critical that it must be in the cache: it\u2019s quite costly, reducing     the efficiency of the cache for memory data competing for space at this index.     Index Load: load from appropriate way of L field in WS RAM     Index Store: store to appropriate way of L and LP field in WS RAM, and     if V is set, make selected way MRU in WS RAM; also, store to L field of     duplicate tag RAM.'), Field('P', Bits(0), 'Parity bit over the PTAG, E, and V bits of the cache tag entries     Index Load: load from P field in primary tag RAM     Index Store: possible write value for the P field of the primary tag RAM;     write this bit if ErrCtl.PO = 1, else generate;     parity written to other RAMs is generated.')]}, u"The 64-bit DTagLo register acts as the interface to the data cache tag array. The Index Store Tag and Index Load Tag   operations of the CACHE instruction use the DTagLo register as the source of tag information.${p}   When the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM. In   this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.   These registers are a staging location for cache tag information being read/written with cache load-tag/store-tag   operations.${p}   The D-cache has five logical memory arrays associated with this DTagLo register. The tag RAM stores tags and other   state bits with special attention to the needs of the CPU. The duplicate tag RAM also stores tags and state, but is optimized   for the needs of interventions. Both of these arrays are set-associative (4-way). The Dirty RAM and duplicate   Dirty RAM store the dirty bits (indicating modified data) for intervention uses, and each combine their ways together   in a single entry per set. The WS RAM also combines the lock and LRU data in a single entry per set. Accessing these   arrays for index cache loads and stores is controlled by using three bits in the ErrCtl register to create modes that   allow the correct access to these arrays.${p}   Note that the P6600 core does not implement the DTagHi register.${p}   The interpretation of this register changes depending on the settings of ErrCtlWST and ErrCtlDYT.${p}   ${tab}1. Default cache interface mode (ErrCtl.WST = 0, ErrCtl.DYT = 0)${nl}   ${tab}2. Diagnostic 'way select test mode' (ErrCtl.WST = 1, ErrCtl.DYT = 0)${nl}   ${tab}2. Diagnostic 'dirty array test mode' (ErrCtl.WST = 0, ErrCtl.DYT = 1)${p}   For all modes, the data RAM, tag RAM, WS RAM, and duplicate tag RAM are read. In addition, for duplicate tag   array test mode, the duplicate tag RAM is also read, and for duplicate dirty array test mode, the duplicate Dirty RAM   is read.${p}   In this mode, this register is a staging location for cache tag information being read/written with cache load-tag/   store-tag operations\u2014routinely used in cache initialization. For stores in this mode, the tag RAM, WS RAM, and   duplicate tag RAM are written. Also for stores, the ErrCtlPO bit controls whether the tag RAM is written with P bit or   with generated parity; the other RAMs written in this mode always use generated parity.", [], 64, CPUNameMatches('P6600.*')),
        Register('IDataHiP6600', 'cp0.29.1', 'IDataHi', {'': []}, 'Instruction data hi', [], 32, CPUNameMatches('P6600.*')),
        Register('IDataLoP6600', 'cp0.28.1', 'IDataLo', {'': []}, 'Instruction data lo', [], 32, CPUNameMatches('P6600.*')),
        Register('ITagHiP6600', 'cp0.29.0', 'ITagHi', {'': [Field('PREC_67', Bits(31, 25)), Field('PREC_45', Bits(24, 18)), Field('PREC_23', Bits(17, 11)), Field('PREC_01', Bits(10, 4)), Field('P_67', Bits(3)), Field('P_45', Bits(2)), Field('P_23', Bits(1)), Field('P_01', Bits(0))]}, u'This register represents the I-cache Predecode bits and is intended for diagnostic use only.   P6600 family cores do some decoding of instructions when they\u2019re loaded into   the I-cache, which helps speed instruction dispatch. When you use cache tag   load/store instructions, you see that information here.   The individual PREC fields hold precode information for pairs of adjacent   instructions in the I-cache line, and the P fields hold parity over them.', [], 32, CPUNameMatches('P6600.*')),
        Register('ITagLoWST1P6600', 'cp0.28.0', 'ITagLo (WST=1)', {'': [Field('LRU', Bits(15, 10), 'LRU bits. This field contains the value read from the WS array after a    CACHE Index Load WS operation. It is used to store into the WS array    during CACHE Index Store WS operations.${p}    When reading or writing the tag in way-select test mode (that is, with    ErrCtlWST set), this field reads or writes the LRU (least recently used)    state bits, held in the way-select RAM.')]}, 'When the WST bit of the ErrCtl register is asserted, this register becomes the interface to the way-selection RAM. In   this mode, the fields are redefined to give appropriate access the contents of the WS array instead of the Tag array.${p}   The way-select RAM is an independent slice of the cache memory (distinct from the tag and data arrays). Test software   can access the data in these fields either by cache load-tag or store-tag operations when ErrCtlWST is set.', [], 64, CPUNameMatches('P6600.*')),
        Register('ITagLoWST0P6600', 'cp0.28.0', 'ITagLo (WST=0)', {'': [Field('PTag', Bits(39, 12), u'The cache address tag, which is a physical address because the P6600\u2019s caches     are physically tagged. It holds bits 40:16 of the physical address. The low-order     16 bits of the address are implied by the position of the data in the cache.'), Field('V', Bits(7), 'Set to 1 if this cache entry is valid (set to zero to initialize the cache).'), Field('L', Bits(5), 'Specifies the lock bit for the cache tag. This bit is set to lock this cache entry,     preventing it from being replaced by another line when a cache miss occurs.     When this bit is set, and the V bit is set, the corresponding cache line will not be     replaced by the cache replacement algorithm.     This can be used for critical data that must not be removed from the cache. However,     this can reduce the efficiency of the cache for memory data competing for     space at this index.'), Field('P', Bits(0), 'Parity bit over the cache tag entries. This bit is updated with tag array parity on     CACHE Index Load Tag operations and used as tag array parity on Index Store     Tag operations when the PO bit of the ErrCtl register is set.')]}, u'The 64-bit ITagLo register acts as the interface to the instruction cache tag array. The Index Store Tag and Index Load   Tag operations of the CACHE instruction use the ITagLo register as the source of tag information.${p}   When ITagLo (ErrCtlWST = 0), this register is a staging location for cache tag information being read/written with cache load-tag/   store-tag operations\u2014routinely used in cache initialization.', [], 64, CPUNameMatches('P6600.*')),
        Register('CacheErrI6400', 'cp0.27.0', 'CacheErr', {'': [Field('State', Bits(31, 30), 'Error detection state', [Value('No error', 0, 'No error detected'), Value('Corrected error', 1, "Corrected Error (includes errors 'corrected' by invalidating a clean line with an uncorrectable/double-bit error)."), Value('Uncorrectable error', 2, 'Uncorrectable error detected')]), Field('Array', Bits(29, 26), 'RAM array where error was detected', [Value('L1 I-Cache Tag', 0), Value('L1 I_Cache Data', 1), Value('L1 D-Cache Tag', 2), Value('L1 D-Cache Data', 3), Value('FTLB Tag', 4), Value('FTLB Data', 5), Value('L2-Cache Tag', 6), Value('L2-Cache Data', 7)])]}, '', [], 32, Or(CPUNameMatches('I6[45]00.*')), 'r'),
        Register('ErrCTLI6400', 'cp0.26.0', 'ErrCTL', {'': [Field('PE', Bits(31), 'Parity/ECC enable. This bit enables or disables ECC protection for the L1 I-Cache, L1 D-Cache, and FTLB'), Field('PO', Bits(30), 'Parity Override. When this bit is set, the CACHE Index Store     Tag operation will use the ECC values provided by the DTagLo,     DDataHi or ITagLo, IDataHi registers instead of generating ECC     in hardware'), Field('PCO', Bits(27), 'Precode Override. When this bit is set, the CACHE Index Store     Tag operation to the L1 I-Cache will use the precode values from     the IDataHi register instead of generating precode in hardware.')]}, 'Error Control', [], 32, Or(CPUNameMatches('I6[45]00.*'))),
        Register('DDataHiI6400', 'cp0.29.1', 'DDataHi', {'': [Field('DataHi', Bits(63, 17)), Field('ERR', Bits(16), "ECC error bit. This bit is set after an IndexStoreTag (CACHEOP=3'b010) operation to the data cache", [Value('No ECC error detected', 0), Value('ECC error detected', 1)]), Field('ECC', Bits(14, 8), 'Error Checking Code:     On an IndexLoadTag, this field indicates the raw code bits from the cache tag array.     On an IndexStoreTag, the value in this field is used if ErrCtlPO = 1, otherwise the     core will internally generate the correct ECC value')]}, '', [], 64, Or(CPUNameMatches('I6[45]00.*'))),
        Register('DDataLoI6400', 'cp0.28.3', 'DDataLo', {'': [Field('DataLo', Bits(31, 0))]}, '', [], 64, Or(CPUNameMatches('I6[45]00.*'))),
        Register('DTagLoI6400', 'cp0.28.2', 'DTagLo', {'': [Field('PTag', Bits(47, 12), "The cache address tag, which is a physical address because the core's caches are     physically tagged. It holds bits 47:14 of the physical address for a 64 KB cache. It     holds 47:13 of the physical address for a 32 KB cache. The low-order 14/13 bits of     the address are implied by the position of the data in the cache."), Field('D', Bits(11), 'Dirty bit. Indicates the line is dirty.'), Field('X', Bits(10), 'Exclusive Bit. Indicates that the line is in the coherent state of Exclusive or Modified.'), Field('V', Bits(9), 'Valid entry: This bit is set if this cache entry is valid (set zero to initialize the cache).     Index Load: load from V field in primary tag RAM     Index Store: store to V field in primary and duplicate tag RAM'), Field('ERR', Bits(8), 'Indicates that a cache error (invalid ECC) was detected by the most recent CACHE     IndxLdTag instruction.', [Value('No Cache error detected', 0), Value('Cache error detected', 1)]), Field('ECC', Bits(6, 0), 'Error Checking Code. This field contains ECC bits from the Tag RAM.     On an IndexLoadTag, this field indicates the raw code bits from the cache tag array.     On an IndexStoreTag, the value in this field is used if ErrCtlPO = 1, otherwise the     core will internally generate the correct ECC value.')]}, 'The DTagLo register acts as the interface to the data cache tag array.', [], 64, Or(CPUNameMatches('I6[45]00.*'))),
        Register('IDataHiI6400', 'cp0.29.1', 'IDataHi', {'': [Field('DataHi', Bits(63, 17)), Field('ERR', Bits(16), "ECC error bit. This bit is set after an IndexStoreTag (CACHEOP=3'b010) operation to the data cache.", [Value('No ECC error detected', 0), Value('ECC error detected', 1)]), Field('ECC', Bits(15, 8), 'Error Checking Code.${p}                             On an IndexLoad, this field indicates the raw code bits from the cache data array.${p}                             On an IndexStore, the value in this field is used if ErrCtl.PO = 1, otherwise the core will internally generate the correct ECC value.'), Field('PRE1', Bits(7, 4), 'Instruction 1 precode bits. This field stores the instruction 1 precode bits.'), Field('PRE0', Bits(3, 0), 'Instruction 0 precode bits. This field stores the instruction 0 precode bits.')]}, 'Instruction data hi', [], 64, Or(CPUNameMatches('I6[45]00.*'))),
        Register('IDataLoI6400', 'cp0.28.1', 'IDataLo', {'': [Field('I1', Bits(63, 32)), Field('I0', Bits(31, 0))]}, 'Instruction data lo', [], 64, Or(CPUNameMatches('I6[45]00.*'))),
        Register('ITagLoI6400', 'cp0.28.0', 'ITagLo', {'': [Field('PTag', Bits(47, 12), "The cache address tag, which is a physical address because the core's caches are     physically tagged. It holds bits 47:14 of the physical address for a 64 KB cache. It     holds 47:13 of the physical address for a 32 KB cache. The low-order 14/13 bits of the     address are implied by the position of the data in the cache."), Field('Valid', Bits(9), 'Valid entry: This bit is set if this cache entry is valid (set zero to initialize the cache).     Index Load: load from V field in primary tag RAM     Index Store: store to V field in primary and duplicate tag RAM'), Field('ERR', Bits(8), 'Indicates that a cache error (invalid ECC) was detected by the most recent CACHE     IndxLdTag instruction.', [Value('No Cache error detected', 0), Value('Cache error detected', 1)]), Field('ECC', Bits(6, 0), 'Error Checking Code. This field contains ECC bits from the Tag RAM.     On an IndexLoadTag, this field indicates the raw code bits from the cache tag array.     On an IndexStoreTag, the value in this field is used if ErrCtlPO = 1, otherwise the     core will internally generate the correct ECC value.')]}, 'The ITagLo register acts as the interface to the instruction cache tag array.', [], 64, Or(CPUNameMatches('I6[45]00.*')))],
 'any': [Register('GIC_VB_DINT_SEND', 'gic_6000', '', {'': [Field('Reserved', Bits(31, 1), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('SEND_DINT', Bits(0), 'If this register field is written with a value of 0x1, the    EJ_DINT_GROUP signal is asserted in a one-shot manner.')]}, 'This register allows software to assert the EJ_DINT_GROUP signal directly', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Condition('GIC_PRESENT_AND_ENABLED'))),
         Register('GIC_SH_WEDGE', 'gic_0280', '', {'': [Field('RW', Bits(31), 'Controls whether this write is setting or clearing a bit in the Edge    Detect Register.${p}    If this bit is set, the selected bit in the register is set.${p}    If this bit is cleared, the selected bit in the register is cleared.'), Field('Interrupt', Bits(30, 0), 'This field is the encoded value of the interrupt that is being cleared   or set. For example, a value of 0xB means interrupt 11 (decimal).')]}, 'This register is used to support interrupt messages. A write to this    register will atomically set or clear one bit in the Edge Detect Register.    Setting a bit in this register will be treated equivalently to having the    edge detection logic see an active edge. This bypasses the edge detection    logic and thus it does not matter whether the corresponding interrupt is    configured to be rising, falling, or dual edge sensitive. However, the    behavior is undefined unless the equivalent bit in the Global Interrupt    Trigger Type register is set to 0x1 indicating edge signaling.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Condition('GIC_PRESENT_AND_ENABLED')), 'w'),
         Register('GIC_SH_TRIG255_224', 'gic_019c', '', {}, 'Global Interrupt Trigger Type for external interrupts 255 to 224.${p}   [@GIC_SH_TRIG_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 28)))),
         Register('GIC_SH_TRIG223_192', 'gic_0198', '', {}, 'Global Interrupt Trigger Type for external interrupts 223 to 192.${p}   [@GIC_SH_TRIG_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 24)))),
         Register('GIC_SH_TRIG191_160', 'gic_0194', '', {}, 'Global Interrupt Trigger Type for external interrupts 191 to 160.${p}   [@GIC_SH_TRIG_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 20)))),
         Register('GIC_SH_TRIG159_128', 'gic_0190', '', {}, 'Global Interrupt Trigger Type for external interrupts 159 to 128.${p}   [@GIC_SH_TRIG_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 16)))),
         Register('GIC_SH_TRIG127_96', 'gic_018c', '', {}, 'Global Interrupt Trigger Type for external interrupts 127 to 96.${p}   [@GIC_SH_TRIG_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 12)))),
         Register('GIC_SH_TRIG95_64', 'gic_0188', '', {}, 'Global Interrupt Trigger Type for external interrupts 95 to 64.${p}   [@GIC_SH_TRIG_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 8)))),
         Register('GIC_SH_TRIG63_32', 'gic_0184', '', {}, 'Global Interrupt Trigger Type for external interrupts 63 to 32.${p}   [@GIC_SH_TRIG_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 4)))),
         Register('GIC_SH_TRIG31_0', 'gic_0180', '', {}, 'Global Interrupt Trigger Type for external interrupts 31 to 00.${p}   [@GIC_SH_TRIG_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 0)))),
         Register('GIC_SH_SMASK255_224', 'gic_039c', '', {}, 'Global Interrupt Set Mask for external interrupts 255 to 224.${p}   [@GIC_SH_SMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 28))), 'w'),
         Register('GIC_SH_SMASK223_192', 'gic_0398', '', {}, 'Global Interrupt Set Mask for external interrupts 223 to 192.${p}   [@GIC_SH_SMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 24))), 'w'),
         Register('GIC_SH_SMASK191_160', 'gic_0394', '', {}, 'Global Interrupt Set Mask for external interrupts 191 to 160.${p}   [@GIC_SH_SMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 20))), 'w'),
         Register('GIC_SH_SMASK159_128', 'gic_0390', '', {}, 'Global Interrupt Set Mask for external interrupts 159 to 128.${p}   [@GIC_SH_SMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 16))), 'w'),
         Register('GIC_SH_SMASK127_96', 'gic_038c', '', {}, 'Global Interrupt Set Mask for external interrupts 127 to 96.${p}   [@GIC_SH_SMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 12))), 'w'),
         Register('GIC_SH_SMASK95_64', 'gic_0388', '', {}, 'Global Interrupt Set Mask for external interrupts 95 to 64.${p}   [@GIC_SH_SMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 8))), 'w'),
         Register('GIC_SH_SMASK63_32', 'gic_0384', '', {}, 'Global Interrupt Set Mask for external interrupts 63 to 32.${p}   [@GIC_SH_SMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 4))), 'w'),
         Register('GIC_SH_SMASK31_0', 'gic_0380', '', {}, 'Global Interrupt Set Mask for external interrupts 31 to 00.${p}   [@GIC_SH_SMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 0))), 'w'),
         Register('GIC_SH_RMASK255_224', 'gic_031c', '', {}, 'Global Interrupt Reset Mask for external interrupts 255 to 224.${p}   [@GIC_SH_RMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 28))), 'w'),
         Register('GIC_SH_RMASK223_192', 'gic_0318', '', {}, 'Global Interrupt Reset Mask for external interrupts 223 to 192.${p}   [@GIC_SH_RMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 24))), 'w'),
         Register('GIC_SH_RMASK191_160', 'gic_0314', '', {}, 'Global Interrupt Reset Mask for external interrupts 191 to 160.${p}   [@GIC_SH_RMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 20))), 'w'),
         Register('GIC_SH_RMASK159_128', 'gic_0310', '', {}, 'Global Interrupt Reset Mask for external interrupts 159 to 128.${p}   [@GIC_SH_RMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 16))), 'w'),
         Register('GIC_SH_RMASK127_96', 'gic_030c', '', {}, 'Global Interrupt Reset Mask for external interrupts 127 to 96.${p}   [@GIC_SH_RMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 12))), 'w'),
         Register('GIC_SH_RMASK95_64', 'gic_0308', '', {}, 'Global Interrupt Reset Mask for external interrupts 95 to 64.${p}   [@GIC_SH_RMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 8))), 'w'),
         Register('GIC_SH_RMASK63_32', 'gic_0304', '', {}, 'Global Interrupt Reset Mask for external interrupts 63 to 32.${p}   [@GIC_SH_RMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 4))), 'w'),
         Register('GIC_SH_RMASK31_0', 'gic_0300', '', {}, 'Global Interrupt Reset Mask for external interrupts 31 to 00.${p}   [@GIC_SH_RMASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 0))), 'w'),
         Register('GIC_SH_RevisionID', 'gic_0020', '', {'': [Field('0', Bits(31, 29), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('MAJOR_REV', Bits(15, 8), 'GIC Major revision number.${p}    This field reflects the major revision of the GIC block. A major    revision might reflect the changes from one product generation    to another.'), Field('MINOR_REV', Bits(7, 0), 'CM Minor revision number.${p}    This field reflects the minor revision of the GIC block. A minor    revision might reflect the changes from one release to another')]}, 'Global Interrupt Controller Revision ID Register', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Condition('GIC_PRESENT_AND_ENABLED'))),
         Register('GIC_SH_POL255_224', 'gic_011c', '', {}, 'Global Interrupt Polarity for external interrupts 255 to 224.${p}   [@GIC_SH_POL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 28)))),
         Register('GIC_SH_POL223_192', 'gic_0118', '', {}, 'Global Interrupt Polarity for external interrupts 223 to 192.${p}   [@GIC_SH_POL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 24)))),
         Register('GIC_SH_POL191_160', 'gic_0114', '', {}, 'Global Interrupt Polarity for external interrupts 191 to 160.${p}   [@GIC_SH_POL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 20)))),
         Register('GIC_SH_POL159_128', 'gic_0110', '', {}, 'Global Interrupt Polarity for external interrupts 159 to 128.${p}   [@GIC_SH_POL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 16)))),
         Register('GIC_SH_POL127_96', 'gic_010c', '', {}, 'Global Interrupt Polarity for external interrupts 127 to 96.${p}   [@GIC_SH_POL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 12)))),
         Register('GIC_SH_POL95_64', 'gic_0108', '', {}, 'Global Interrupt Polarity for external interrupts 95 to 64.${p}   [@GIC_SH_POL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 8)))),
         Register('GIC_SH_POL63_32', 'gic_0104', '', {}, 'Global Interrupt Polarity for external interrupts 63 to 32.${p}   [@GIC_SH_POL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 4)))),
         Register('GIC_SH_POL31_0', 'gic_0100', '', {}, 'Global Interrupt Polarity for external interrupts 31 to 00.${p}   [@GIC_SH_POL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 0)))),
         Register('GIC_SH_PEND255_224', 'gic_049c', '', {}, 'Global Interrupt Mask for external interrupts 255 to 224.${p}   [@GIC_SH_PEND_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 28))), 'r'),
         Register('GIC_SH_PEND223_192', 'gic_0498', '', {}, 'Global Interrupt Mask for external interrupts 223 to 192.${p}   [@GIC_SH_PEND_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 24))), 'r'),
         Register('GIC_SH_PEND191_160', 'gic_0494', '', {}, 'Global Interrupt Mask for external interrupts 191 to 160.${p}   [@GIC_SH_PEND_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 20))), 'r'),
         Register('GIC_SH_PEND159_128', 'gic_0490', '', {}, 'Global Interrupt Mask for external interrupts 159 to 128.${p}   [@GIC_SH_PEND_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 16))), 'r'),
         Register('GIC_SH_PEND127_96', 'gic_048c', '', {}, 'Global Interrupt Mask for external interrupts 127 to 96.${p}   [@GIC_SH_PEND_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 12))), 'r'),
         Register('GIC_SH_PEND95_64', 'gic_0488', '', {}, 'Global Interrupt Mask for external interrupts 95 to 64.${p}   [@GIC_SH_PEND_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 8))), 'r'),
         Register('GIC_SH_PEND63_32', 'gic_0484', '', {}, 'Global Interrupt Mask for external interrupts 63 to 32.${p}   [@GIC_SH_PEND_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 4))), 'r'),
         Register('GIC_SH_PEND31_0', 'gic_0480', '', {}, 'Global Interrupt Mask for external interrupts 31 to 00.${p}   [@GIC_SH_PEND_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 0))), 'r'),
         Register('GIC_SH_MASK255_224', 'gic_041c', '', {}, 'Global Interrupt Mask for external interrupts 255 to 224.${p}   [@GIC_SH_MASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 28))), 'r'),
         Register('GIC_SH_MASK223_192', 'gic_0418', '', {}, 'Global Interrupt Mask for external interrupts 223 to 192.${p}   [@GIC_SH_MASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 24))), 'r'),
         Register('GIC_SH_MASK191_160', 'gic_0414', '', {}, 'Global Interrupt Mask for external interrupts 191 to 160.${p}   [@GIC_SH_MASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 20))), 'r'),
         Register('GIC_SH_MASK159_128', 'gic_0410', '', {}, 'Global Interrupt Mask for external interrupts 159 to 128.${p}   [@GIC_SH_MASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 16))), 'r'),
         Register('GIC_SH_MASK127_96', 'gic_040c', '', {}, 'Global Interrupt Mask for external interrupts 127 to 96.${p}   [@GIC_SH_MASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 12))), 'r'),
         Register('GIC_SH_MASK95_64', 'gic_0408', '', {}, 'Global Interrupt Mask for external interrupts 95 to 64.${p}   [@GIC_SH_MASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 8))), 'r'),
         Register('GIC_SH_MASK63_32', 'gic_0404', '', {}, 'Global Interrupt Mask for external interrupts 63 to 32.${p}   [@GIC_SH_MASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 4))), 'r'),
         Register('GIC_SH_MASK31_0', 'gic_0400', '', {}, 'Global Interrupt Mask for external interrupts 31 to 00.${p}   [@GIC_SH_MASK_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 0))), 'r'),
         Register('GIC_SH_DUAL255_224', 'gic_021c', '', {}, 'Global Interrupt Dual Edge Register for external interrupts 255 to 224.${p}   [@GIC_SH_DUAL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 28)))),
         Register('GIC_SH_DUAL223_192', 'gic_0218', '', {}, 'Global Interrupt Dual Edge Register for external interrupts 223 to 192.${p}   [@GIC_SH_DUAL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 24)))),
         Register('GIC_SH_DUAL191_160', 'gic_0214', '', {}, 'Global Interrupt Dual Edge Register for external interrupts 191 to 160.${p}   [@GIC_SH_DUAL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 20)))),
         Register('GIC_SH_DUAL159_128', 'gic_0210', '', {}, 'Global Interrupt Dual Edge Register for external interrupts 159 to 128.${p}   [@GIC_SH_DUAL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 16)))),
         Register('GIC_SH_DUAL127_96', 'gic_020c', '', {}, 'Global Interrupt Dual Edge Register for external interrupts 127 to 96.${p}   [@GIC_SH_DUAL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 12)))),
         Register('GIC_SH_DUAL95_64', 'gic_0208', '', {}, 'Global Interrupt Dual Edge Register for external interrupts 95 to 64.${p}   [@GIC_SH_DUAL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 8)))),
         Register('GIC_SH_DUAL63_32', 'gic_0204', '', {}, 'Global Interrupt Dual Edge Register for external interrupts 63 to 32.${p}   [@GIC_SH_DUAL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 4)))),
         Register('GIC_SH_DUAL31_0', 'gic_0200', '', {}, 'Global Interrupt Dual Edge Register for external interrupts 31 to 00.${p}   [@GIC_SH_DUAL_DESC@]', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), And(Op('==', Condition('GIC_PRESENT_AND_ENABLED'), True), Op('gte', Reg('GIC_SH_CONFIG::NUMINTERRUPTS'), 0)))),
         Register('GIC_SH_CounterLo', 'gic_0010', '', {}, 'Lower Half of an up-counter.${p}   When the counter reaches its maximum value, the counter   rolls over to a value of 0x0.${p}   The counter is running at an implementation-specific frequency   which is fixed, that is, not changing dynamically   due to power management. It is recommended that this   frequency be as close as possible to the highest clock frequency   of the CPU subsystem.${p}   This counter is disabled by writing the COUNTSTOP bit   in the GIC_SH_CONFIG register.${p}   This counter should only be written when   GIC_SH_CONFIGCOUNTSTOP = 1; otherwise, the registers   results after the write are unpredictable.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Condition('GIC_PRESENT_AND_ENABLED'))),
         Register('GIC_SH_CounterHi', 'gic_0014', '', {}, 'Upper Half of an up-counter.${p}   When the counter reaches its maximum value, the counter   rolls over to a value of 0x0.${p}   The counter is running at an implementation-specific frequency   which is fixed, that is, not changing dynamically   due to power management. It is recommended that this   frequency be as close as possible to the highest clock frequency   of the CPU subsystem.${p}   This counter is disabled by writing the COUNTSTOP bit   in the GIC_SH_CONFIG register.${p}   This counter should only be written when   GIC_SH_CONFIGCOUNTSTOP = 1; otherwise, the register   results after the write are unpredictable.${p}   Unimplemented bits ignore writes and return 0 when read.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Condition('GIC_PRESENT_AND_ENABLED'))),
         Register('GIC_SH_CONFIG', 'gic_0000', '', {'': [Field('VZP', Bits(31), 'This bit is set to 1 to indicate that the P5600 GIC supports virtualization.'), Field('VZE', Bits(30), 'Controls the GIC mode of operation.', [Value('VZ disabled. GIC operates in non-virtualized mode.', 0), Value('VZ enabled. GIC operates in virtualized mode.', 1)]), Field('IRC', Bits(29), 'Interrupt Read Control. Allows root software visibility into root and guest-specific interrupts.${nl}    0 : Root accesses all register bits unqualified.${nl}    1 : Root accesses only those register bits that are specific to GIC_SH_CONFIG[IRGID]. This may be root(IRGID=0), or guest (IRGID=nZ).', [Value('Root accesses all register bits unqualified.', 0), Value('Root accesses only those register bits that are specified.', 1)]), Field('COUNTSTOP', Bits(28), 'Setting this bit will stop GIC_CounterHi and    GIC_CounterLo.${p}    Used to freeze the shared counters when cores go into    power-down or debug modes.'), Field('COUNTBITS', Bits(27, 24), 'Number of Implemented Bits in GIC_CounterHi.${p}    Total Number of Counter Bits = 32 + COUNTBITS*4,    E.g.:.${p}    ${tab}0x0 = 32bits, GIC_CounterHi not implemented${nl}    ${tab}0x1 = 36bits, GIC_CounterHi width = 4 bits${nl}    ${tab}0x2 = 40bits, GIC_CounterHi width = 8 bits${nl}    ${tab}...${nl}    ${tab}0x7 = 60bits, GIC_CounterHi width = 28 bits${nl}    ${tab}0x8 = 64bits, GIC_CounterHi width = 32 bits${nl}    ${tab}9-15 Reserved'), Field('NUMINTERRUPTS', Bits(23, 16), 'Number of External Interrupt Sources.  Number of interrupts is equal to     (8 * (value+1)). Value is fixed by customer at IP configuration time.'), Field('IRGID', Bits(15, 8), 'Interrupt Read Guest ID. Specified GuestID for root read of the     shared section registers. Field width matches that of GuestCtl0.GID.'), Field('GNMI', Bits(7), 'Guest NMI'), Field('PVPES', Bits(6, 0), 'Total number of VPEs in the system is value + 1.')]}, 'Global Interrupt Controller Global Config Register', [], 64, And(CPUNameMatches('P5600.*'), Condition('GIC_PRESENT_AND_ENABLED'))),
         Register('GIC_SH_CONFIG', 'gic_0000', '', {'': [Field('Reserved', Bits(31, 29), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('COUNTSTOP', Bits(28), 'Setting this bit will stop GIC_CounterHi and    GIC_CounterLo.${p}    Used to freeze the shared counters when cores go into    power-down or debug modes.'), Field('COUNTBITS', Bits(27, 24), 'Number of Implemented Bits in GIC_CounterHi.${p}    Total Number of Counter Bits = 32 + COUNTBITS*4,    E.g.:.${p}    ${tab}0x0 = 32bits, GIC_CounterHi not implemented${nl}    ${tab}0x1 = 36bits, GIC_CounterHi width = 4 bits${nl}    ${tab}0x2 = 40bits, GIC_CounterHi width = 8 bits${nl}    ${tab}...${nl}    ${tab}0x7 = 60bits, GIC_CounterHi width = 28 bits${nl}    ${tab}0x8 = 64bits, GIC_CounterHi width = 32 bits${nl}    ${tab}9-15 Reserved'), Field('NUMINTERRUPTS', Bits(23, 16), 'Number of External Interrupt Sources.  Number of interrupts is equal to     (8 * (value+1)). Value is fixed by customer at IP configuration time.'), Field('Reserved', Bits(15, 9), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('PVPES', Bits(8, 0), 'Total number of VPEs in the system is value + 1.')]}, 'Global Interrupt Controller Global Config Register', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,interAptiv.*'), Condition('GIC_PRESENT_AND_ENABLED'))),
         Register('GCR_CL_TCID', 'gcr_cl_0040', '', 'Cx_TCID_FIELDS', 'Core Local TCID Register${p}   In the ${proc} core, there is one thread context per core.    Hence only one TCID register if required.', [], 64, CPUNameMatches('proAptiv.*,P5600.*'), 'r'),
         Register('GCR_CL_RESET_EXT_BASE', 'gcr_cl_0030', '', 'Cx_RESET_EXT_BASE_FIELDS', u'Core Local Reset Exception Extended Base Register${p}   This register is an extension to the Core-Local Reset    Exception Base Register (see Section \u201cCore Local Reset   Exception Base Register (GCR_Cx_RESET_BASE Offset 0x0020)\u201d).    It also is used to drive the SI_ExceptionBase input to the local    core. The value is used for placing the exception vectors within    the virtual address map during core boot-up time (e.g., when    COP0 Status[BEV]=1). The value in this register is reset only on    Cold Reset (not Warm Reset).', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_CL_RESET_BASE', 'gcr_cl_0020', '', 'Cx_RESET_BASE_FIELDS', 'Core Local Reset Exception Base Register${p}   This register is used to drive the SI_ExceptionBase[31:12]    input to the local core. The value is used for placing the   exception vectors within the virtual address map during core    boot-up time (e.g., when COP0 Status[BEV] = 1). The value in    this register is reset only on Cold Reset (not Warm Reset).', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_CL_OTHER', 'gcr_cl_0018', '', 'Cx_OTHER_FIELDS', 'Core Other Addressing Register${p}This register must be    written with the correct core number before accessing the    Core-Other address segment.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_CL_ID', 'gcr_cl_0028', '', 'Cx_ID_FIELDS', 'The aliased memory scheme is normally invisible to    software when accessing GCR registers within the Core-Local    control block. What actually happens is that an offset is    used to make a subset of the GCR registers appear in the    Core-Local addressing window.${p} This register reports the    core number that is used as the addressing offset for the    Core-Local control block.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), 'r'),
         Register('GCR_CL_CONFIG', 'gcr_cl_0010', '', 'Cx_CONFIG_FIELDS', 'Core Local Config Register', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_CL_COHERENCE', 'gcr_cl_0008', '', 'Cx_COHERENCE_FIELDS', 'This register allows each core to respond to intervention    requests from only a subset of the coherent masters within the CPS.    Software can control entry and exit from the coherence domain by    setting the COH_DOMAIN_EN bit in this register for:${p}   - Initialization during (asynchronous) Boot${p}   - Power control for shutting down and bringing up a Core${p}   - Attaching Legacy Cores to the ${proc} CPS (1004K/1074K only)', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_REV', 'gcr_0030', '', {'': [Field('Reserved', Bits(31, 16), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('MAJOR_REV', Bits(15, 8), 'CM Major revision number.${p}    This field reflects the major revision of the GCR block. A    major revision might reflect the changes from one product    generation to another.${p}    This value changes based on the processor revision. Refer    to the errata sheet of the ${proc} core for the exact value    of this field.'), Field('MINOR_REV', Bits(7, 0), 'CM Minor revision number.${p}    This field reflects the minor revision of the GCR block. A    minor revision might reflect the changes from one release    to another.${p}    This value changes based on the processor revision. Refer    to the errata sheet of the ${proc} core for the exact value    of this field.')]}, 'GCR Revision Register', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_L2_ONLY_SYNC_BASE', 'gcr_0070', '', {'': [Field('SYNC_BASE', Bits(31, 12), 'L2-only SYNC base address.${p}This field sets the base     address of the 4KB GCR L2 only Sync of the interAptiv MPS.'), Field('Reserved', Bits(11, 1), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('SYNC_EN', Bits(0), 'L2-only SYNC enable.${p}If this bit is set, the CM2 treats     an uncached write request as an L2 only Sync.${p}If set to 0,     the CM2 treats the uncached write as a regular uncached     request.')]}, 'The ${proc} core provides a mechanism to execute a SYNC    operation to only the L2 cache, without affecting the core. Refer    to the [L2-Only SYNC Operation] section of the core specification    for more information on how this register is used.', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_IOCU1_REV', 'gcr_0200', '', {'': [Field('Reserved', Bits(31, 16), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('MAJOR_REV', Bits(15, 8), 'This field reflects the major revision of the IOCU attached     to the CM. A major revision might reflect the changes from one     product generation to another. The value of 0x0 means that no IOCU     is attached.'), Field('MINOR_REV', Bits(7, 0), 'This field reflects the minor revision of the IOCU attached     to the CM. A minor revision might reflect the changes from one     release to another.')]}, '', [], 64, CPUNameMatches('1004K.*,1074K.*,interAptiv.*,proAptiv.*,P5600.*'), 'r'),
         Register('GCR_GIC_STATUS', 'gcr_00d0', '', {'': [Field('Reserved', Bits(31, 1), 'Reads as 0x0. Writes ignored. Must be written with a value of 0x0'), Field('GIC_EX', Bits(0), 'Indicates if the General Interrupt Controller is connected to the CM.')]}, 'Global Interrupt Controller Status Register', [], 64, CPUNameMatches('1004K.*,1074K.*,interAptiv.*,proAptiv.*,P5600.*')),
         Register('GCR_GIC_BASE', 'gcr_0080', '', {'': [Field('GIC_BASE_ADDR', Bits(31, 17), 'Global Interrupt Controller Base Address. This field sets     the base address of the 128KB Global Interrupt Controller.'), Field('Reserved', Bits(16, 1), 'Reads as 0x0. Writes ignored. Must be written with a value of 0x0.'), Field('GIC_EN', Bits(0), 'Global Interrupt Controller Enable. If this bit is set, the     address region for the GIC is enabled. This bit can not be set to     1 if GIC_EX = 0, indicating that a GIC is not attached to the CM2.     R/W (if GIC_EX = 1), R (if GIC_EX = 0)')]}, 'Global Interrupt Controller Base Address Register', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_GIC_STATUS::GIC_EX'), 1))),
         Register('GCR_ERROR_MULT', 'gcr_0058', '', {'': [Field('Reserved', Bits(31, 5), 'Read as 0x0'), Field('CM_ERROR_2ND', Bits(4, 0), 'Type of second error. Loaded when the Global CM Error    Cause Register has valid error information and a second    error is detected.')]}, 'Global CM Error Multiple Register', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_ERROR_ADDR', 'gcr_0050', '', {}, 'Request address which caused error. Loaded when the   Global Error Cause Register is loaded.   Bits 2:0 should always be 0.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_ERROR_CAUSE', 'gcr_0048', '', {'': [Field('CM_ERROR_TYPE', Bits(31, 27), 'Indicates type of error detected. When CM_ERROR_TYPE    is zero, no errors have been detected. When    CM_ERROR_TYPE is non-zero, another error will not be    reloaded until a power-on reset or this field is written to 0.'), Field('ERROR_INFO', Bits(26, 0), 'Information about the error.      Please consult the core specification for more detail.     May also be called CM_ERROR_INFO')]}, 'Global CM Error Cause Register', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_ERROR_MASK', 'gcr_0040', '', {}, 'CM Error Mask register.${p}    Each bit in this field represents an Error Type. If the bit is    set, an interrupt is generated if an error of that type is detected.${p}    If the bit is set, the transaction for Read-Type Errors completes    with OK response to avoid double reporting of the error.${p}    The Error Types that can be captured is implementation-specific.${p}    Reset State: 0x000A_002A (write errors cause interrupts;     read errors provide error response)', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_CUSTOM_STATUS', 'gcr_0068', '', {'': [Field('Reserved', Bits(31, 1), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('GCU_EX', Bits(0), 'If this bit is set, the Custom GCR is connected to the    CM2. The state of this bit is set based on whether or not    this block is implemented at build time as determined by    the state of the GU_Present signal.${p}    If a Custom GCR block is not present, the GU_Present    pin is driven to 0. If there is a custom GCR block present,    then the user must drive GU_Present = 1 inside their custom    GCR module.')]}, 'GCR Custom Status Register', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_CUSTOM_BASE', 'gcr_0060', '', {'': [Field('CUSTOM_BASE', Bits(31, 16), 'This field sets the base address of the 64KB GCR    custom user-defined block of the ${proc} Multiprocessing    System.'), Field('Reserved', Bits(15, 1), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('GCU_EN', Bits(0), 'If this bit is set, the address region for the Custom    GCR is enabled.${p} This bit cannot be set to 1 if GGU_EX = 0,     indicating that a custom GCR is not attached to the CM.    R/W (if GGU_EX = 1), R (if GGU_EX = 0)')]}, 'This register allows for the implementation of custom    registers that are designed by the customer and instantiated into   the design at build time. Refer to the [Custom GCR Implementation]    section of the core specification for more information on how this    register is used.', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_CPC_STATUS', 'gcr_00f0', '', {'': [Field('Reserved', Bits(31, 1), 'Reads as 0x0. Writes ignored. Must be written with a value of 0x0'), Field('CPC_EX', Bits(0), 'Indicates if the Cluster Power Controller is connected to the CM.')]}, '', [], 64, CPUNameMatches('1004K.*,1074K.*,interAptiv.*,proAptiv.*,P5600.*')),
         Register('GCR_CPC_BASE', 'gcr_0088', '', {'': [Field('CPC_BASE_ADDR', Bits(31, 15), 'This field sets the base address of the 32K Cluster Power Controller.'), Field('Reserved', Bits(14, 1), 'Reads as 0x0. Writes ignored. Must be written with a value of 0x0.'), Field('CPC_EN', Bits(0), 'If this bit is set, the address region for the CPC is enabled.     This bit can not be set if 1 CPC_EX = 0, indicating that a CPC     is not attached to the CM. R/W (if CPC_EX = 1), R (if CPC_EX = 0)')]}, 'Cluster Power Controller Base Address Register', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_CPC_STATUS::CPC_EX'), 1))),
         Register('GCR_CONTROL2', 'gcr_0018', '', {'': [Field('Reserved', Bits(31, 20), 'Read as 0x0. Writes ignored. Must be written     with a value of 0x0.'), Field('L2_CACHEOP_LIMIT', Bits(19, 16), u'L2 CacheOp transaction limit.${p}    The total number of L2 CacheOp transactions allowed by    the CM2 serialization arbiter to be simultaneously inflight.    An L2 CacheOp is defined as any transaction with    MAddrSpace = 0b001 or 0b010. In this context, an L2    CacheOp transaction is considered in-flight when it is    selected for serialization by the CM2 until the request is    issued on the CM2\u2019s system memory OCP Port.${p}    Setting a value of 0x0 disables the limit (i.e., the CM2    serialization arbiter will not explicitly limit the number of    in-flight L12 CacheOps).${p}    Setting a value of 0x1 allows only a single in-flight L2    CacheOp. Setting a value of 0x2 allows two in-flight L2    CacheOps, etc...${p}    The purpose of this limit is to avoid the case where one or    more cores substantially impact the performance of other    cores by issuing a rapid succession of L2 CacheOps.'), Field('Reserved', Bits(15, 4), 'Read as 0x0. Writes ignored. Must be written     with a value of 0x0.'), Field('L1_CACHEOP_LIMIT', Bits(3, 0), 'L1 CacheOp transaction limit.${p}    The total number of L1 CacheOp transactions allowed by    the CM2 serialization arbiter to be simultaneously inflight.    A L1 CacheOp is defined as a transaction with    MAddrSpace = 0b011 or 0b1xx. In this context, a transaction    is considered in-flight when it is selected for serialization    by the CM2 until its intervention response is    processed by the CM2 (if the cacheOp did not receive a    DVA intervention response) or until all intervention data    has been received (if the cacheOp received a DVA intervention    response).${p}    Setting a value of 0x0 disables the limit (i.e., the CM2    serialization arbiter will not explicitly limit the number of    in-flight L1 CacheOps).${p}    Setting a value of 0x1 allows only a single in-flight L1    CacheOp. Setting a value of 0x2 allows two in-flight L1    CacheOps, etc...${p}    The purpose of this limit is to avoid the case where one or    more cores substantially impact the performance of other    cores by issuing a rapid succession of L1 CacheOps that    receive an intervention response of DVA.')]}, 'Global CM Control2 Register', [], 64, CPUNameMatches('interAptiv.*,proAptiv.*,P5600.*')),
         Register('GCR_CONTROL2', 'gcr_0018', '', {'': [Field('Reserved', Bits(31, 20), 'Read as 0x0. Writes ignored. Must be written     with a value of 0x0.'), Field('L2_CACHEOP_LIMIT', Bits(19, 16), u'The total number of L2/L3 CacheOp transactions allowed    by the CM serialization arbiter to be simultaneously inflight.    An L2/L3 CacheOp is defined as any transaction    with MAddrSpace = 0b001 or 0b010. In this context, an    L2 CacheOp transaction is considered in-flight when it is    selected for serialization by the CM until the request is    issued on the CM\u2019s L2/Memory OCP Port.${p}    Setting a value of 0x0 disables the limit (i.e., the CM serialization    arbiter will not explicitly limit the number of inflight    L12/L3 CacheOps)...${p}    Setting a value of 0x1 allows only a single in-flight L2/L3    CacheOp. Setting a value of 0x2 allows two in-flight L2/    L3 CacheOps, etc...${p}    The purpose of this limit is to avoid the case where one or    more cores substantially impact the performance of other    cores by issuing a rapid succession of L2/L3 CacheOps.    This is particularly a potential problem when the the    CM:L2 clock ratio is not 1:1.'), Field('Reserved', Bits(15, 4), 'Read as 0x0. Writes ignored. Must be written     with a value of 0x0.'), Field('L1_CACHEOP_LIMIT', Bits(3, 0), 'The total number of L1 CacheOp transactions allowed by    the CM serialization arbiter to be simultaneously in-flight.    A L1 CacheOp is defined as a transaction with MAddrSpace    = 0b011 or 0b1xx. In this context, a transaction is    considered in-flight when it is selected for serialization by    the CM until its intervention response is processed by the    CM (if the cacheOp did not receive a DVA intervention    response) or until all intervention data has been received    (if the cacheOp received a DVA intervention response).${p}    Setting a value of 0x0 disables the limit (i.e., the CM serialization    arbiter will not explicitly limit the number of inflight    L1 CacheOps)...${p}    Setting a value of 0x1 allows only a single in-flight L1    CacheOp. Setting a value of 0x2 allows two in-flight L1    CacheOps, etc...${p}    The purpose of this limit is to avoid the case where one or    more cores substantially impact the performance of other    cores by issuing a rapid succession of L1 CacheOps that    receive an intervention response of DVA.')]}, 'Global CM Control2 Register', [], 64, CPUNameMatches('1004K.*,1074K.*')),
         Register('GCR_CONTROL', 'gcr_0010', '', {'': [Field('Reserved', Bits(31, 17), 'Read as 0x0. Must be written with a value of 0x0.'), Field('SYNCCTL', Bits(16), 'Determines SYNC behavior when a SYNC level 0x0 is executed by a core.', [Value('Sync0 generates Intervention Sync', 0), Value('Sync0 generates Memory Sync', 1)]), Field('Reserved', Bits(15, 8), 'Read as 0x0. Must be written with a value of 0x0.'), Field('Unused', Bits(7, 6), u'These bits are currently unused. When writing to this     register, software should assign a value of 2\u2019b00 to this field.'), Field('SYNCDIS', Bits(5), u'SYNC transmit disable. Set to 1 to disable the     propagation of SYNC transactions on the system memory     port. This has the same effect as deasserting SI_SyncTxEn.     Setting to 0 makes the propagation of SYNC transactions     on the system memory port dependent solely on the state     of SI_SyncTxEn. Refer to the pin descriptions chapter in     the ${proc} Hardware User\u2019s Manual for more information     on this pin.'), Field('IVU_EN', Bits(4), u'Stall until interventions are completed. Set to 1     to stall serialization when a core\u2019s clock is stopping     or is being powered down by the CPC until all previous     interventions are complete. Set to 0 for no stalling of     serialization when a core is going offline.'), Field('SHST_EN', Bits(3), 'Force coherent read data to shared state in L1 data     cache. If set to 1 then Coherent Read Data is always     installed in the Level 1 cache of the requesting ${proc}     Multiprocessing System core in the SHARED state. If set to     0 then Coherent Read Data may be installed in the Level 1     cache in the SHARED state (if the data coexists in other     Level 1 caches) or EXCLUSIVE (if the data does not coexist     in other Level 1 caches).'), Field('PARK_EN', Bits(2), 'I/O port parking enable. If set to 1 and the     SI[iocu]_CMP_IOC_ParkEn signal is 1, then I/O Port Parking     is enabled for the corresponding IOCU. I/O Port parking is     a mechanism where the CM2 only serializes requests from     the IOCU for some period of time. If set to 0 or     SI[iocu]_CMP_IOC_ParkEn signal is 0, then the I/O Port     Parking is disabled for the corresponding IOCU. This bit     has no effect in systems without an IOCU (i.e., they are     not hardware I/O coherent).'), Field('MMIO_LIMIT_DIS', Bits(1), 'Limit requests to memory-mapped I/O. If set to 0,     the CM2 avoids deadlock in systems with hardware I/O     coherence by limiting requests issued to Memory- Mapped     I/O. An MMIO request will be selected for serialization     only if the previous request and write data (if applicable)     has been accepted by the IOCU. If set to 1, MMIO requests     are not limited and therefore deadlock may occur in systems     with hardware I/O coherence unless avoided by some other     mechanism. This bit has no effect in systems without an     IOCU (i.e., they are not hardware I/O coherent) because     there are no MMIO ports and therefore the limit does not     apply.'), Field('SPEC_READ_EN', Bits(0), 'Speculative coherent read enable. If set to 1, the     CM2 may speculatively read memory for a coherent read     before the intervention for that read has completed.     Performance is improved by reading memory in parallel     with the intervention. If set to 0, the CM2 will never     issue speculative reads to memory.')]}, 'Global CM Control Register', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_CONTROL', 'gcr_0010', '', {'': [Field('Reserved', Bits(31, 17), 'Read as 0x0. Must be written with a value of 0x0.'), Field('SYNCCTL', Bits(16), 'Determines SYNC behavior when a SYNC level 0x0 is     executed by a core.', [Value('Sync0 generates Intervention Sync', 0), Value('Sync0 generates Memory Sync', 1)]), Field('Reserved', Bits(15, 8), 'Read as 0x0. Must be written with a value of 0x0.'), Field('Reserved', Bits(7), 'Read as 0x0. Must be written with a value of 0x0.'), Field('CM_DROP_L3_CACHEOP_WR', Bits(6), 'Set to 1 for the CM to drop Non-Index L3 CacheOp     writes after it has been serialized.'), Field('CM_SYNC_TX_DISABLE', Bits(5), 'Set to 1 to disable the propagation of SYNC     transactions on the L2/Memory Port. This has the same     effect as deasserting SI_CM_SyncTxEn. Setting to 0 makes     the propagation of SYNC transactions on the L2/Memory     port dependent solely on the state of SI_CM_SyncTxEn.'), Field('CM_AUTO_CLR_IVU_EN', Bits(4), u'Set to 1 to stall serialization when a core\u2019s clock     is stopping or is being powered down (i.e., assertion of     SI_Iv_LPReq) until all previous interventions are complete.      Set to 0 for no stalling of serialization when a core is     going offline.'), Field('CM_COHST_SH_ALWAYS_EN', Bits(3), 'If set to 1 then Coherent Read Data is always installed     in the Level 1 cache of the requesting ${proc} core in the     SHARED state. If set to 0 then Coherent Read Data may be     installed in the Level 1 cache in the SHARED state (if the     data coexists in other Level 1 caches) or EXCLUSIVE (if the     data does not coexist in other Level 1 caches).'), Field('CM_PARK_EN', Bits(2), 'If set to 1 and the SI_CMP_IOC_ParkEn signal is 1,     then I/O Port Parking is enabled. I/O Port parking is a     mechanism where the CM only serializes requests from the     IOCU for some period of time. If set to 0 or SI_CMP_IOC_ParkEn     signal is 0, then the I/O Port Parking is disabled. This     bit has no effect in systems without an IOCU (i.e., they     are not hardware I/O coherent).'), Field('CM_DISABLE_MMIO_LIMIT', Bits(1), 'If set to 0, the CM avoids deadlock in systems with     hardware I/O coherence by limiting requests issued to     Memory-Mapped I/O. An MMIO request will be selected for     serialization only if the previous request and write data     (if applicable) has been accepted by the IOCU. If set to 1,     MMIO requests are not limited and therefore deadlock may      occur in systems with hardware I/O coherence unless avoided      by some other mechanism. This bit has no effect in systems      without an IOCU (i.e., they are not hardware I/O coherent)      because there are no MMIO ports and therefore the limit      does not apply.'), Field('CM_SPEC_READ_EN', Bits(0), 'If set to 1, the     CM may speculatively read memory for a coherent read before the     intervention for that read has completed. Performance is     improved by reading memory in parallel with the intervention.     If set to 0, the CM will never issue speculative reads to memory.')]}, 'Global CM Control Register', [], 64, CPUNameMatches('1074K.*')),
         Register('GCR_CONTROL', 'gcr_0010', '', {'': [Field('Reserved', Bits(31, 17), 'Read as 0x0. Must be written with a value of 0x0.'), Field('SYNCCTL', Bits(16), 'Determines SYNC behavior when a SYNC level 0x0 is executed by a core.', [Value('Sync0 generates Intervention Sync', 0), Value('Sync0 generates Memory Sync', 1)]), Field('Reserved', Bits(15, 6), 'Read as 0x0. Must be written with a value of 0x0.'), Field('CM_SYNC_TX_DISABLE', Bits(5), 'Set to 1 to disable the propagation of SYNC     transactions on the L2/Memory Port. This has the     same effect as deasserting SI_CM_SyncTxEn. Setting     to 0 makes the propagation of SYNC transactions on     the L2/Memory port dependent solely on the state of     SI_CM_SyncTxEn.'), Field('CM_AUTO_CLR_IVU_EN', Bits(4), u'Set to 1 to stall serialization when a core\u2019s     clock is stopping or is being powered down (i.e.,     assertion of SI_Iv_LPReq) until all previous interventions     are complete.  Set to 0 for no stalling of serialization     when a core is going offline.'), Field('CM_COHST_SH_ALWAYS_EN', Bits(3), 'If set to 1 then Coherent Read Data is always     installed in the Level 1 cache of the requesting ${proc}     core in the SHARED state. If set to 0 then Coherent Read     Data may be installed in the Level 1 cache in the SHARED     state (if the data coexists in other Level 1 caches) or     EXCLUSIVE (if the data does not coexist in other Level     1 caches).'), Field('CM_PARK_EN', Bits(2), 'If set to 1 and the SI_CMP_IOC_ParkEn signal is 1,     then I/O Port Parking is enabled. I/O Port parking is a     mechanism where the CM only serializes requests from the     IOCU for some period of time. If set to 0 or SI_CMP_IOC_ParkEn     signal is 0, then the I/O Port Parking is disabled. This     bit has no effect in systems without an IOCU (i.e., they     are not hardware I/O coherent).'), Field('CM_DISABLE_MMIO_LIMIT', Bits(1), 'If set to 0, the CM avoids deadlock in systems with     hardware I/O coherence by limiting requests issued to     Memory-Mapped I/O. An MMIO request will be selected for     serialization only if the previous request and write data     (if applicable) has been accepted by the IOCU.${p}If set to     1, MMIO requests are not limited and therefore deadlock     may occur in systems with hardware I/O coherence unless     avoided by some other mechanism. This bit has no effect     in systems without an IOCU (i.e., they are not hardware     I/O coherent) because there are no MMIO ports and therefore     the limit does not apply.'), Field('CM_SPEC_READ_EN', Bits(0), 'If set to 1, the CM may speculatively read memory     for a coherent read before the intervention for that read     has completed. Performance is improved by reading memory in     parallel with the intervention. If set to 0, the CM will     never issue speculative reads to memory.')]}, 'Global CM Control Register', [], 64, CPUNameMatches('1004K.*')),
         Register('GCR_CONFIG', 'gcr_0000', '', {'': [Field('Reserved', Bits(31, 20)), Field('ADDR_REGIONS', Bits(19, 16), 'Number of address regions. Total number     of CM Address Regions. Note: only 0, 4, or 6     address regions are currently supported. All     other encoded values not listed below are     reserved.'), Field('Reserved', Bits(15, 12)), Field('NUMIOCU', Bits(11, 8), u'Total number of IOCUs in the system.     Note: only 0, or 1 IOCU\u2019s are currently supported'), Field('PCORES', Bits(7, 0), 'Total number of cores in the system not     including the IOCUs. All values not shown are     reserved (cores = (value-1))')]}, '', [], 64, CPUNameMatches('1004K.*,1074K.*')),
         Register('GCR_CONFIG', 'gcr_0000', '', {'': [Field('Reserved', Bits(31, 20)), Field('ADDR_REGIONS', Bits(19, 16), 'Number of address regions. Total number of CM2     Address Regions. Note: only 0, 4, 6, or 8 address     regions are currently supported. All other encoded     values not listed below are reserved.'), Field('Reserved', Bits(15, 12)), Field('NUMIOCU', Bits(11, 8), u'Total number of IOCUs in the system. Note:     only 0, 1, or 2 IOCU\u2019s are currently supported'), Field('PCORES', Bits(7, 0), 'Total number of cores in the system not     including the IOCUs. All values not shown are     reserved (cores = (value-1))')]}, '', [], 64, CPUNameMatches('proAptiv.*,P5600.*, interAptiv.*')),
         Register('GCR_CACHE_REV', 'gcr_00e0', '', {'': [Field('Reserved', Bits(31, 16), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('MAJOR_REV', Bits(15, 8), 'This field reflects the major revision of the Cache     block inside the CM.'), Field('MINOR_REV', Bits(7, 0), 'This field reflects the minor revision of the Cache     block inside the CM.')]}, 'Cache Revision Register', [], 64, CPUNameMatches('1004K.*,1074K.*,interAptiv.*,proAptiv.*,P5600.*'), 'r'),
         Register('GCR_BASE', 'gcr_0008', '', {'': [Field('GCR_BASE', Bits(31, 15), 'This field sets the base address of the 32KB GCR block.     This register has a fixed value after     reset if configured as Read-Only (an IP Configuration Option).'), Field('Reserved', Bits(14, 8), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('CCA', Bits(7, 5), 'Used with CCAEN/CCA_DEFAULT_OVERRIDE_ENABLE to force     the Cache Coherence Attribute (CCA) value for transactions     on the L2/Memory OCP.', [Value('WT: Write Through', 0), Value('Reserved', 1), Value('UC: Uncached', 2), Value('WB: Writeback, cacheable, non-coherent', 3), Value('CWBE: Mapped to WB', 4), Value('CWB: Mapped to WB', 5), Value('Reserved', 6), Value('UCA: Uncached Accelerated', 7)]), Field('CCAEN', Bits(4), 'If CCAEN/CCA_DEFAULT_OVERRIDE_ENABLE is set to 1     and CM_DEFAULT_TARGET is set to Memory, then transactions     with addresses do not map to any region will have a CCA     value set to CCA/CCA_DEFAULT_OVERRIDE_VALUE when driven     to L2/Memory.'), Field('Reserved', Bits(3, 2), 'Read as 0x0. Must be written with a value of 0x0.'), Field('CM_DEFAULT_TARGET', Bits(1, 0), 'Determines the target device for addresses which do     not match any address map entry. (This field may also be     prefixed CM2_ in spec)', [Value('Memory', 0), Value('Reserved', 1), Value('IOCU', 2), Value('Reserved', 3)])]}, '', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_ACCESS', 'gcr_0020', '', {'': [Field('Reserved', Bits(31, 8), 'Reads as 0x0. Writes ignored. Must be written with a value of 0x0.'), Field('CM_ACCESS_EN', Bits(7, 0), 'Requester access to global control registers.    Each bit in this field represents a coherent requester.${p}    If the bit is set, that requester is able to write to the GCR    registers (this includes all registers within the Global,    Core-Local, Core-Other, and Global Debug control    blocks. The GIC is always writable by all requestors).${p}    If the bit is clear, any write request from that requestor to    the GCR registers (Global, Core-Local, Core-Other, or    Global Debug control blocks) will be dropped.')]}, 'Global CSR Access Privilege Register', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_TCBTW_HI', 'gcr_db_0208', '', {}, 'Reads to this register access the contents of the On-Chip Trace Buffer entry    (most significant 32-bits) which is referenced by the GCR_DB_TCBRDP register. Writes    to this register modify the On-Chip Trace Buffer entry (most significant 32-bits)    which is referenced by the GCR_DB_TCBWRP register.${p} To read or write a 64-bit trace    word from the Trace Buffer, the GCR_DB_TCBTW_HI register must be accessed first before    the GCR_DB_TCBTW_LO register. The access of the GCR_DB_TCBTW_LO register causes the    appropriate pointer register to be incremented. The use of load half-word or load byte   instructions can lead to unpredictable results, and is not recommended.${p} This    register is also accessible by EJTAG via the TCBDATA instruction as described in the    EJTAG Debug Support chapter.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_TCBTW_LO', 'gcr_db_0200', '', {}, 'Reads to this register access the contents of the On-Chip Trace Buffer entry    (least significant 32-bits) which is referenced by the GCR_DB_TCBRDP register. Writes    to this register modify the On-Chip Trace Buffer entry (least significant 32-bits)    which is referenced by the GCR_DB_TCBWRP register.${p} A side effect of reading the    TCBTW_LO register is that the TCBRDP register increments to the next TW in the onchip   trace memory. If TCBRDP is at the max size of the on-chip trace memory, the increment    wraps back to address zero. A side effect of writing the TCBTW_LO register is that    the TCBWRP register increments to the next TW in the on-chip trace memory. If TCBWRP   is at the max size of the on-chip trace memory, the increment wraps back to address    zero. The use of load half-word or load byte instructions can lead to unpredictable    results, and is not recommended.${p} This register is also accessible by EJTAG via the    TCBDATA instruction as described in the EJTAG Debug Support chapter.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_TCBSYS', 'gcr_db_0040', '', {'': [Field('STA', Bits(31), 'System Trace Available. Set to 1 if the System Trace     Interface is present. Otherwise it is set to 0.'), Field('UsrCtl', Bits(30, 0), 'User-defined Control.')]}, 'The TCBSYS register contents are driven to the    TC_Sys_UserCtl[31:0] output signals. This register is also    mapped to offset 0x0040 in the Global Debug Block of the CM    GCRs. Thus, any change to this register will be reflected in    these output signals. This    register is also accessible by EJTAG via the TCBDATA instruction    as described in the EJTAG Debug Support chapter.', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_TCBSTP', 'gcr_db_0118', '', {}, 'The TCBSTP register is the start pointer register. This pointer is    used to determine when all entries in the trace buffer have been filled    (when TCBWRP has the same value as TCBSTP ). This pointer is reset to zero    when the TCBCONTROLBTR bit is written to 1. If a continuous trace to    on-chip memory wraps around the on-chip memory, TSBSTP will have the same    value as TCBWRP.${p} This register is also accessible by EJTAG via the    TCBDATA instruction as described in the EJTAG Debug Support chapter.${p}   The value of n depends on the size of the on-chip    trace memory. As the address points to a 64-bit TW, the lower three bits    are always zero.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_TCBWRP', 'gcr_db_0110', '', {}, 'The TCBWRP register is an address pointer to on-chip trace memory.    It points to the location where the next new TW for on-chip trace will    be written.${p} This register is also accessible by EJTAG via the TCBDATA    instruction as described in the EJTAG Debug Support chapter.${p}    The value of n depends on the size of the on-chip trace memory.    As the address points to a 64-bit TW, the lower three bits are always zero.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_TCBRDP', 'gcr_db_0108', '', {}, 'The TCBRDP register is an address pointer to on-chip trace memory.    It points to the TW read when reading the TCBTW register. When writing    the TCBCONTROLBRM bit to 1, this pointer is reset to the current value    of TCBSTP.${p} This register is also accessible by EJTAG via the TCBDATA    instruction as described in the EJTAG Debug Support chapter.${p}   The value of n depends on the size of the    on-chip trace memory. As the address points to a 64-bit TW, lower    three bits are always zero.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_TCBCONTROLE', 'gcr_db_0020', '', {'': [Field('Reserved', Bits(31, 9), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('TrIdle', Bits(8), 'Trace Unit Idle. This bit indicates if the trace hardware is currently    idle (not processing any data). This can be useful when switching    control of trace from hardware to software and vice versa. The bit is    read-only and updated by the trace hardware.${p}    TrIdle is set when the system traces on all cores, and the CM2, have    disabled PDTrace and the trace funnel has written all outstanding    trace information to the off-chip or on-chip memory.'), Field('0', Bits(7, 0), 'Reads as 0x0. Must be written with a value of 0x0.')]}, '', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), 'r'),
         Register('GCR_DB_TCBCONTROLD', 'gcr_db_0010', '', {'': [Field('Reserved', Bits(31, 30), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('P6_Ctl', Bits(29, 28), 'Provides specific control over tracing transactions on Port    6 of the CM. (the IOCU on 6 core configurations).', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P5_Ctl', Bits(27, 26), 'Provides specific control over tracing transactions on Port    5 of the CM (core 5). See encoding for P6_Ctl.', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P4_Ctl', Bits(25, 24), 'Provides specific control over tracing transactions on Port    4 of the CM (core 4 on 6 core configurations or the    IOCU on 4 core or less configurations). See encoding for    P6_Ctl.', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P3_Ctl', Bits(23, 22), 'Provides specific control over tracing transactions on Port    3 of the CM (core 3). See encoding for P6_Ctl.', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P2_Ctl', Bits(21, 20), 'Provides specific control over tracing transactions on Port    2 of the CM (core 2). See encoding for P6_Ctl.', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P1_Ctl', Bits(19, 18), 'Provides specific control over tracing transactions on Port    1 of the CM (core 1). See encoding for P6_Ctl.', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P0_Ctl', Bits(17, 16), 'Provides specific control over tracing transactions on Port    0 of the CM (core 0). See encoding for P6_Ctl.', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('Reserved', Bits(15, 12), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('TwSrcVal', Bits(11, 8), 'The source ID inserted into the Trace Word by the CM.    NOTE: When disabling trace by setting Global_CM_En    to 0, the value in TWSrcVal continues to be used until all    trace messages have been flushed from the CM. Therefore,    when writing to this register to disabled, the correct    value must still be written into the TWSrcVal field.'), Field('WB', Bits(7), 'When this bit is set, Coherent Writeback requests are    traced. If this bit is not set, all Coherent Writeback    requests are suppressed from the CM PDTrace Stream'), Field('ST_En', Bits(6), 'System Trace Enable. Driven to the CM output pin    TC_Sys_Enable. External logic can use this output to control    generation of the System Trace stream.'), Field('IO', Bits(5), 'Inhibit Overflow on the CM PDTrace FIFO full condition.    When set to 0, the CM will drop a new PDTrace    message if the internal PDTrace FIFOs are full.    When set to 1, the CM will not drop PDTrace messages,    but may stall transactions within the CM when the internal    PDTrace FIFOs are full.'), Field('TLev', Bits(4, 3), 'This defines the current trace level being used by CM    PDtrace', [Value('No Timing Information', 0), Value('Include Stall Times, Causes', 1), Value('Reserved', 2), Value('Reserved', 3)]), Field('AE', Bits(2), 'When set to 1, address tracing is always enabled for the    CM. When set to 0, address tracing may be enabled on a    per-port basis through the P[x]_Ctl bits.'), Field('Global_CM_En', Bits(1), 'Setting this bit to 1 enables tracing from the CM as long    as the CM_EN bit is also enabled.'), Field('CM_EN', Bits(0), 'This is the master trace enable for the CM. When zero,    tracing from the CM is always disabled. When set to one,    tracing is enabled from whenever the other enabling functions    are also true.')]}, '', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_TCBCONTROLD', 'gcr_db_0010', '', {'': [Field('Reserved', Bits(31, 26), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('P4_Ctl', Bits(25, 24), 'Provides specific control over tracing transactions on Port    4 of the CM. (the IOCU).', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P3_Ctl', Bits(23, 22), 'Provides specific control over tracing transactions on Port    3 of the CM (core 3).', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P2_Ctl', Bits(21, 20), 'Provides specific control over tracing transactions on Port    2 of the CM (core 2).', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P1_Ctl', Bits(19, 18), 'Provides specific control over tracing transactions on Port    1 of the CM (core 1).', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('P0_Ctl', Bits(17, 16), 'Provides specific control over tracing transactions on Port    0 of the CM (core 0).', [Value('Tracing Enabled, No Address Tracing', 0), Value('Tracing Enabled  with Address Tracing', 1), Value('Reserved', 2), Value('Tracing Disabled', 3)]), Field('Reserved', Bits(15, 12), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('TwSrcVal', Bits(11, 8), 'The source ID inserted into the Trace Word by the CM.    NOTE: When disabling trace by setting SW_Trace_ON    to 0, the value in TWSrcVal continues to be used until all    trace messages have been flushed from the CM. Therefore,    when writing to this register to disabled, the correct    value must sill be written into the TWSrcVal field.'), Field('WB', Bits(7), 'When this bit is set, Coherent Writeback requests are    traced. If this bit is not set, all Coherent Writeback    requests are suppressed from the CM PDTrace Stream'), Field('Reserved', Bits(6), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('IO', Bits(5), 'Inhibit Overflow on the CM PDTrace FIFO full condition.    When set to 0, the CM will drop a new PDTrace    message if the internal PDTrace FIFOs are full.    When set to 1, the CM will not drop PDTrace messages,    but may stall transactions within the CM when the internal    PDTrace FIFOs are full.'), Field('TLev', Bits(4, 3), 'This defines the current trace level being used by CM    PDtrace', [Value('No Timing Information', 0), Value('Include Stall Times, Causes', 1), Value('Reserved', 2), Value('Reserved', 3)]), Field('AE', Bits(2), 'When set to 1, address tracing is always enabled for the    CM. When set to 0, address tracing may be enabled on a    per-port basis through the P[x]_Ctl bits.'), Field('Global_CM_En', Bits(1), 'Setting this bit to 1 enables tracing from the CM as long    as the CM_EN bit is also enabled.'), Field('CM_EN', Bits(0), 'This is the master trace enable for the CM. When zero,    tracing from the CM is always disabled. When set to one,    tracing is enabled from whenever the other enabling functions    are also true.')]}, '', [], 64, CPUNameMatches('1004K.*,1074K.*')),
         Register('GCR_DB_TCBCONTROLB', 'gcr_db_0008', '', {'': [Field('WE', Bits(31), 'Write Enable. Only when set to 1 will     the other bits of this register be written.    This bit will always read 0.'), Field('Reserved', Bits(30, 28), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('TWSrcWidth', Bits(27, 26), u'Used to indicate the number of bits used in the source field of the    Trace Word. The value for the CM is always 2\u2019b10, indicating a four    bit source field width.'), Field('Reserved', Bits(25, 20), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('STCE', Bits(19), 'System Trace capture enable. When asserted, the System Trace port of    the Funnel is enabled to capture System Trace stream data. When not    asserted, System Trace stream data is not captured regardless of    TC_Sys_Valid[1:0] input pin state.'), Field('TRPAD', Bits(18), 'Trace RAM access disable bit. When set, core reads and writes to the    on-chip trace RAM using GCR accesses are inhibited.${p}    If TRPAD is set, memory-mapped writes to the GCR_DB_TCBTW_LO     and GCR_DB_TCBTW_HI registers have no effect, and memory-mapped     reads from GCR_DB_TCBTW_LO and GCR_DB_TCBTW_HI do not access     the Trace RAM and 0 is returned.${p}    Also, when TRPAD is set, then memory-mapped writes to the following    registers are inhibited:${p}    ${tab}TCBTW${nl}    ${tab}TCBRDP${nl}    ${tab}TCBWRP${nl}    ${tab}TCBSTP'), Field('Reserved', Bits(17), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('RM', Bits(16), 'Read on-chip trace memory.${p} When this bit is set,     the read address-pointer of the on-chip memory in register     TCBRDP is set to the value held in TCBSTP. Subsequent access     to the TCBTW register (through the TCBDATA register), will     automatically increment the read pointer in register TCBRDP     after each read.${p}When the write pointer is reached, this     bit is automatically reset to 0, and the TCBTW register will     read all zeros.${p}Once set to 1, writing 1 again will have     no effect. The bit is reset by setting the TR bit or by     reading the last Trace word in TCBTW.'), Field('TR', Bits(15), 'Trace memory reset.${p}When written to one, the     address pointers for the on-chip trace memory TCBSTP,     TCBRDP and TCBWRP are reset to zero. Also the RM and BF     bits are reset to 0.${p}This bit is automatically reset     back to 0, when the reset specified above is completed.'), Field('BF', Bits(14), 'Buffer Full indicator that the TCB uses to communicate     to external software that the on-chip trace memory is full.     This bit is cleared when writing a 1 to the TR bit.${p}    This bit has no function if on-chip memory is not     implemented.'), Field('TM', Bits(13, 12), 'Trace Mode. This field determines how the trace memory     is filled when using the simple-break control in the PDtrace    IF to start or stop trace.${p}In Trace-To mode, the on-chip     trace memory is filled, continuously wrapping around,     overwriting older Trace Words, as long as there is trace data     coming from the core.${p}In Trace-From mode, the on-chip trace     memory is filled from the point that the core starts tracing     until the on-chip trace memory is full (when the write pointer     address is the same as the start pointer address). If a     TCBTRIGx trigger control register is used to start/stop tracing,     then this field should be set to Trace-To mode.${p}These bits     have no function if on-chip memory is not implemented.', [Value('Trace-To', 0), Value('Trace-From', 1), Value('Reserved', 2), Value('Reserved', 3)]), Field('0', Bits(11), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('CR', Bits(10, 8), 'Off-chip Clock Ratio. Writing this field, sets the ratio of the core    clock to the off-chip trace memory interface clock. The clock-ratio    encoding is shown in Table 8.51.${p}    Note: As the Probe interface works in double data rate (DDR) mode, a    1:2 ratio indicates one data packet sent per core clock rising edge.${p}    These bits have no function if off-chip memory is not implemented.', [Value('1:20', 0), Value('1:16', 1), Value('1:12', 2), Value('1:10', 3), Value('1:2', 4), Value('1:4', 5), Value('1:6', 6), Value('1:8', 7)]), Field('Cal', Bits(7), 'Calibrate off-chip trace interface.${p}    If set, the off-chip trace pins will produce the following     pattern in consecutive trace clock cycles. If more than 4 data     pins exist, the pattern is replicated for each set of 4 pins.     The pattern repeats from top to bottom until the Cal bit is     de-asserted.${p}    ${tab}3${tab}2${tab}1${tab}0${nl}    ${tab}_${tab}_${tab}_${tab}_${nl}    ${tab}0${tab}0${tab}0${tab}0${nl}    ${tab}1${tab}1${tab}1${tab}1${nl}    ${tab}0${tab}0${tab}0${tab}0${nl}    ${tab}0${tab}1${tab}0${tab}1${nl}    ${tab}1${tab}0${tab}1${tab}0${nl}    ${tab}1${tab}0${tab}0${tab}0${nl}    ${tab}0${tab}1${tab}0${tab}0${nl}    ${tab}0${tab}0${tab}1${tab}0${nl}    ${tab}0${tab}0${tab}0${tab}1${nl}    ${tab}1${tab}1${tab}1${tab}0${nl}    ${tab}1${tab}1${tab}0${tab}1${nl}    ${tab}1${tab}0${tab}1${tab}1${nl}    ${tab}0${tab}1${tab}1${tab}1${p}    Note: The clock source of the TCB and PIB must be running.    These bits have no function if off-chip memory is     not implemented.'), Field('Reserved', Bits(6, 2), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('OfC', Bits(1), 'If set to 1, trace is sent to off-chip memory using TR_DATA pins.    If not set, trace info is sent to on-chip memory.    This bit is read only if one of these options exists.'), Field('EN', Bits(0), 'Funnel Trace Enable. When this bit is set, the trace funnels accepts    trace information from the CM, cores, and/or system trace and writes    the information to off-chip or on-chip memory.    When this bit is cleared, the trace funnel drops all new trace information    from the those sources. The trace information already accepted by    the trace funnel is sent to the off-chip or on-chip memory, but new    trace information is dropped and not written out.')]}, '', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_TCBCONTROLB', 'gcr_db_0008', '', {'': [Field('WE', Bits(31), 'Write Enable. Only when set to 1 will     the other bits of this register be written.    This bit will always read 0.'), Field('Reserved', Bits(30, 28), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('TWSrcWidth', Bits(27, 26), u'Used to indicate the number of bits used in the source field of the    Trace Word. The value for the CM is always 2\u2019b10, indicating a four    bit source field width.'), Field('Reserved', Bits(25, 20), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('Reserved', Bits(19), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('TRPAD', Bits(18), 'Trace RAM access disable bit. When set, core reads and writes to the    on-chip trace RAM using GCR accesses are inhibited.${p}    If TRPAD is set, memory-mapped writes to the GCR_DB_TCBTW_LO     and GCR_DB_TCBTW_HI registers have no effect, and memory-mapped     reads from GCR_DB_TCBTW_LO and GCR_DB_TCBTW_HI do not access     the Trace RAM and 0 is returned.${p}    Also, when TRPAD is set, then memory-mapped writes to the following    registers are inhibited:${p}    ${tab}TCBTW${nl}    ${tab}TCBRDP${nl}    ${tab}TCBWRP${nl}    ${tab}TCBSTP'), Field('Reserved', Bits(17), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('RM', Bits(16), 'Read on-chip trace memory.    When written to 1, the read address-pointer of the on-chip    memory in register TCBRDP is set to the value held in    TCBSTP.${p}    Subsequent access to the TCBTW register (through the    TCBDATA register), will automatically increment the read    pointer in register TCBRDP after each read.${p}    When the write pointer is reached, this bit is automatically    reset to 0, and the TCBTW register will read all zeros.    Once set to 1, writing 1 again will have no effect. The bit    is reset by setting the TR bit or by reading the last Trace    word in TCBTW.'), Field('TR', Bits(15), 'Trace memory reset.${p}When written to one, the     address pointers for the on-chip trace memory TCBSTP,     TCBRDP and TCBWRP are reset to zero. Also the RM and BF     bits are reset to 0.${p}This bit is automatically reset     back to 0, when the reset specified above is completed.'), Field('BF', Bits(14), 'Buffer Full indicator that the TCB uses to communicate to    external software that the on-chip trace memory is full.    Note that this applies only in the situation that the on-chip    trace memory is being deployed in the trace-from and    trace-to mode.${p}    This bit is cleared when writing a 1 to the TR bit.    This bit has no function if on-chip memory is not implemented.'), Field('TM', Bits(13, 12), 'Trace Mode. This field determines how the trace memory     is filled when using the simple-break control in the PDtrace    IF to start or stop trace.${p}In Trace-To mode, the on-chip     trace memory is filled, continuously wrapping around,     overwriting older Trace Words, as long as there is trace data     coming from the core.${p}In Trace-From mode, the on-chip trace     memory is filled from the point that the core starts tracing     until the on-chip trace memory is full (when the write pointer     address is the same as the start pointer address). If a     TCBTRIGx trigger control register is used to start/stop tracing,     then this field should be set to Trace-To mode.${p}These bits     have no function if on-chip memory is not implemented.', [Value('Trace-To', 0), Value('Trace-From', 1), Value('Reserved', 2), Value('Reserved', 3)]), Field('0', Bits(11), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('CR', Bits(10, 8), 'Off-chip Clock Ratio. Writing this field, sets the ratio of the core    clock to the off-chip trace memory interface clock. The clock-ratio    encoding is shown in Table 8.51.${p}    Note: As the Probe interface works in double data rate (DDR) mode, a    1:2 ratio indicates one data packet sent per core clock rising edge.${p}    These bits have no function if off-chip memory is not implemented.', [Value('8:1', 0), Value('4:1', 1), Value('2:1', 2), Value('1:1', 3), Value('1:2', 4), Value('1:4', 5), Value('1:6', 6), Value('1:8', 7)]), Field('Cal', Bits(7), 'Calibrate off-chip trace interface.${p}    If set, the off-chip trace pins will produce the following     pattern in consecutive trace clock cycles. If more than 4 data     pins exist, the pattern is replicated for each set of 4 pins.     The pattern repeats from top to bottom until the Cal bit is     de-asserted.${p}    ${tab}3${tab}2${tab}1${tab}0${nl}    ${tab}_${tab}_${tab}_${tab}_${nl}    ${tab}0${tab}0${tab}0${tab}0${nl}    ${tab}1${tab}1${tab}1${tab}1${nl}    ${tab}0${tab}0${tab}0${tab}0${nl}    ${tab}0${tab}1${tab}0${tab}1${nl}    ${tab}1${tab}0${tab}1${tab}0${nl}    ${tab}1${tab}0${tab}0${tab}0${nl}    ${tab}0${tab}1${tab}0${tab}0${nl}    ${tab}0${tab}0${tab}1${tab}0${nl}    ${tab}0${tab}0${tab}0${tab}1${nl}    ${tab}1${tab}1${tab}1${tab}0${nl}    ${tab}1${tab}1${tab}0${tab}1${nl}    ${tab}1${tab}0${tab}1${tab}1${nl}    ${tab}0${tab}1${tab}1${tab}1${p}    Note: The clock source of the TCB and PIB must be running.    These bits have no function if off-chip memory is     not implemented.'), Field('Reserved', Bits(6, 2), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('OfC', Bits(1), 'If set to 1, trace is sent to off-chip memory using TR_DATA pins.    If not set, trace info is sent to on-chip memory.    This bit is read only if one of these options exists.'), Field('EN', Bits(0), 'Funnel Trace Enable. When this bit is set, the trace funnels accepts    trace information from the CM, cores, and/or system trace and writes    the information to off-chip or on-chip memory.    When this bit is cleared, the trace funnel drops all new trace information    from the those sources. The trace information already accepted by    the trace funnel is sent to the off-chip or on-chip memory, but new    trace information is dropped and not written out.')]}, '', [], 64, CPUNameMatches('1004K.*,1074K.*')),
         Register('GCR_DB_TCBCONFIG', 'gcr_db_0028', '', {'': [Field('CF1', Bits(31), 'This bit is set if a TCBCONFIG1 register exists. In this revision,    TCBCONFIG1 does not exist, and this bit reads zero.'), Field('Reserved', Bits(30, 21), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('SZ', Bits(20, 17), 'On-chip trace memory size. This field holds the encoded size of the    on-chip trace memory.${p}    The size in bytes is given by 2(SZ+8). i.e., the lowest value is 256    bytes, and the highest is 8 MB.${p}    This bit is reserved if on-chip memory is not implemented.'), Field('CRMax', Bits(16, 14), 'Off-chip Maximum Clock Ratio.${p}    This field indicates the maximum ratio of the core clock to the offchip    trace memory interface clock.${p}    This bit is reserved if off-chip trace option is not implemented.', [Value('1:20', 0), Value('1:16', 1), Value('1:12', 2), Value('1:10', 3), Value('1:2', 4), Value('1:4', 5), Value('1:6', 6), Value('1:8', 7)]), Field('CRMin', Bits(13, 11), 'Off-chip Minimum Clock Ratio.${p}    This field indicates the minimum ratio of the core clock to the offchip    trace memory interface clock.${p}    This bit is reserved if off-chip trace option is not implemented.', [Value('1:20', 0), Value('1:16', 1), Value('1:12', 2), Value('1:10', 3), Value('1:2', 4), Value('1:4', 5), Value('1:6', 6), Value('1:8', 7)]), Field('PW', Bits(10, 9), 'Probe Width: Number of bits available on the off-chip trace interface    TR_DATA pins. The number of TR_DATA pins is encoded. This field is preset     based on input signals to the TCB and the actual capability of the TCB.', [Value('4 Bits', 0), Value('8 Bits', 1), Value('16 Bits', 2), Value('Reserved', 3)]), Field('Reserved', Bits(8, 6), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('OnT', Bits(5), 'When set, this bit indicates that on-chip trace memory is present.    This bit is preset based on the selected option when the TCB is    implemented.'), Field('OfT', Bits(4), 'When set, this bit indicates that off-chip trace interface is present.    This bit is preset based on the selected option when the TCB is    implemented, and on the existence of a PIB module    (TC_PibPresent asserted).'), Field('REV', Bits(3, 0), 'Revision of TCB')]}, '', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*'), 'r'),
         Register('GCR_DB_TCBCONFIG', 'gcr_db_0028', '', {'': [Field('CF1', Bits(31), 'This bit is set if a TCBCONFIG1 register exists. In this revision,    TCBCONFIG1 does not exist, and this bit reads zero.'), Field('Reserved', Bits(30, 25), 'This field is reserved for implementations. Refer to the    processor specification for the format and definition of this   field.'), Field('Reserved', Bits(24, 21), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('SZ', Bits(20, 17), 'On-chip trace memory size. This field holds the encoded size of the    on-chip trace memory.${p}    The size in bytes is given by 2^(SZ+8). i.e., the lowest value is 256    bytes, and the highest is 8 MB.${p}    This bit is reserved if on-chip memory is not implemented.'), Field('CRMax', Bits(16, 14), 'Off-chip Maximum Clock Ratio.${p}    This field indicates the maximum ratio of the core clock to the offchip    trace memory interface clock.${p}    This bit is reserved if off-chip trace option is not implemented.', [Value('8:1', 0), Value('4:1', 1), Value('2:1', 2), Value('1:1', 3), Value('1:2', 4), Value('1:4', 5), Value('1:6', 6), Value('1:8', 7)]), Field('CRMin', Bits(13, 11), 'Off-chip Minimum Clock Ratio.${p}    This field indicates the minimum ratio of the core clock to the offchip    trace memory interface clock.${p}    This bit is reserved if off-chip trace option is not implemented.', [Value('8:1', 0), Value('4:1', 1), Value('2:1', 2), Value('1:1', 3), Value('1:2', 4), Value('1:4', 5), Value('1:6', 6), Value('1:8', 7)]), Field('PW', Bits(10, 9), 'Probe Width: Number of bits available on the off-chip trace interface    TR_DATA pins. The number of TR_DATA pins is encoded. This field is preset     based on input signals to the TCB and the actual capability of the TCB.', [Value('4 Bits', 0), Value('8 Bits', 1), Value('16 Bits', 2), Value('Reserved', 3)]), Field('Reserved', Bits(8, 6), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('OnT', Bits(5), 'When set, this bit indicates that on-chip trace memory is present.    This bit is preset based on the selected option when the TCB is    implemented.'), Field('OfT', Bits(4), 'When set, this bit indicates that off-chip trace interface is present.    This bit is preset based on the selected option when the TCB is    implemented, and on the existence of a PIB module    (TC_PibPresent asserted).'), Field('REV', Bits(3, 0), 'Revision of TCB')]}, '', [], 64, CPUNameMatches('1004K.*,1074K.*'), 'r'),
         Register('GCR_DB_PC_QUAL1_17', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31), 'Event Qualifier for CM Performance Counter 1.'), Field('Transaction ID', Bits(30, 26), 'Event Qualifier for CM Performance Counter 1.'), Field('I/O Parking', Bits(25, 22), 'Event Qualifier for CM Performance Counter 1.'), Field('CM Transaction Count', Bits(21, 17), 'Event Qualifier for CM Performance Counter 1.'), Field('BurstLength', Bits(16, 10), 'Event Qualifier for CM Performance Counter 1.'), Field('L2 Allocation', Bits(9, 7), 'Event Qualifier for CM Performance Counter 1.'), Field('Posted', Bits(6, 5), 'Event Qualifier for CM Performance Counter 1.'), Field('Cacheability', Bits(4, 2), 'Event Qualifier for CM Performance Counter 1.'), Field('Request Type', Bits(1, 0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 17))),
         Register('GCR_DB_PC_QUAL1_16', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31), 'Event Qualifier for CM Performance Counter 1.'), Field('Transaction ID', Bits(30, 26), 'Event Qualifier for CM Performance Counter 1.'), Field('I/O Parking', Bits(25, 22), 'Event Qualifier for CM Performance Counter 1.'), Field('CM Transaction Count', Bits(21, 17), 'Event Qualifier for CM Performance Counter 1.'), Field('BurstLength', Bits(16, 10), 'Event Qualifier for CM Performance Counter 1.'), Field('L2 Allocation', Bits(9, 7), 'Event Qualifier for CM Performance Counter 1.'), Field('Posted', Bits(6, 5), 'Event Qualifier for CM Performance Counter 1.'), Field('Cacheability', Bits(4, 2), 'Event Qualifier for CM Performance Counter 1.'), Field('Request Type', Bits(1, 0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 16))),
         Register('GCR_DB_PC_QUAL1_9', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31, 20), 'Event Qualifier for CM Performance Counter 1.'), Field('Allocation', Bits(19, 18), 'Event Qualifier for CM Performance Counter 1.'), Field('Hit/Miss Type', Bits(17, 8), 'Event Qualifier for CM Performance Counter 1.'), Field('Source Port', Bits(7, 0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 9))),
         Register('GCR_DB_PC_QUAL1_8', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31, 6), 'Event Qualifier for CM Performance Counter 1.'), Field('Pipeline Start Type', Bits(5, 0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 8))),
         Register('GCR_DB_PC_QUAL1_6', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31, 6), 'Event Qualifier for CM Performance Counter 1.'), Field('Response Type', Bits(5, 3), 'Event Qualifier for CM Performance Counter 1.'), Field('Port Number', Bits(2, 0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 6))),
         Register('GCR_DB_PC_QUAL1_5', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31, 15), 'Event Qualifier for CM Performance Counter 1.'), Field('Request Port', Bits(14, 7), 'Event Qualifier for CM Performance Counter 1.'), Field('Response Port', Bits(6, 0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 5))),
         Register('GCR_DB_PC_QUAL1_4', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31, 2), 'Event Qualifier for CM Performance Counter 1.'), Field('L2 Data Width', Bits(1, 0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 4))),
         Register('GCR_DB_PC_QUAL1_3', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31, 1), 'Event Qualifier for CM Performance Counter 1.'), Field('Accept State', Bits(0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 3))),
         Register('GCR_DB_PC_QUAL1_2', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31, 1), 'Event Qualifier for CM Performance Counter 1.'), Field('Accept State', Bits(0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 2))),
         Register('GCR_DB_PC_QUAL1_1', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Reserved', Bits(31, 25), 'Event Qualifier for CM Performance Counter 1.'), Field('Intervention State', Bits(24, 19), 'Event Qualifier for CM Performance Counter 1.'), Field('Speculation', Bits(18, 17), 'Event Qualifier for CM Performance Counter 1.'), Field('Intervention Cmd', Bits(16, 3), 'Event Qualifier for CM Performance Counter 1.'), Field('Store Conditional', Bits(2, 0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 1))),
         Register('GCR_DB_PC_QUAL1_0', 'gcr_db_01a0', 'GCR_DB_PC_QUAL1', {'': [Field('Request Port', Bits(31, 24), 'Event Qualifier for CM Performance Counter 1.'), Field('Request CCA', Bits(23, 19), 'Event Qualifier for CM Performance Counter 1.'), Field('Burst Length', Bits(18, 16), 'Event Qualifier for CM Performance Counter 1.'), Field('Request Command', Bits(15, 3), 'Event Qualifier for CM Performance Counter 1.'), Field('Target', Bits(2, 0), 'Event Qualifier for CM Performance Counter 1.')]}, 'CM Performance Counter 1 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 1 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P1_Event'), 0))),
         Register('GCR_DB_PC_QUAL0_17', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31), 'Event Qualifier for CM Performance Counter 0.'), Field('Transaction ID', Bits(30, 26), 'Event Qualifier for CM Performance Counter 0.'), Field('I/O Parking', Bits(25, 22), 'Event Qualifier for CM Performance Counter 0.'), Field('CM Transaction Count', Bits(21, 17), 'Event Qualifier for CM Performance Counter 0.'), Field('BurstLength', Bits(16, 10), 'Event Qualifier for CM Performance Counter 0.'), Field('L2 Allocation', Bits(9, 7), 'Event Qualifier for CM Performance Counter 0.'), Field('Posted', Bits(6, 5), 'Event Qualifier for CM Performance Counter 0.'), Field('Cacheability', Bits(4, 2), 'Event Qualifier for CM Performance Counter 0.'), Field('Request Type', Bits(1, 0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 17))),
         Register('GCR_DB_PC_QUAL0_16', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31), 'Event Qualifier for CM Performance Counter 0.'), Field('Transaction ID', Bits(30, 26), 'Event Qualifier for CM Performance Counter 0.'), Field('I/O Parking', Bits(25, 22), 'Event Qualifier for CM Performance Counter 0.'), Field('CM Transaction Count', Bits(21, 17), 'Event Qualifier for CM Performance Counter 0.'), Field('BurstLength', Bits(16, 10), 'Event Qualifier for CM Performance Counter 0.'), Field('L2 Allocation', Bits(9, 7), 'Event Qualifier for CM Performance Counter 0.'), Field('Posted', Bits(6, 5), 'Event Qualifier for CM Performance Counter 0.'), Field('Cacheability', Bits(4, 2), 'Event Qualifier for CM Performance Counter 0.'), Field('Request Type', Bits(1, 0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 16))),
         Register('GCR_DB_PC_QUAL0_9', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31, 20), 'Event Qualifier for CM Performance Counter 0.'), Field('Allocation', Bits(19, 18), 'Event Qualifier for CM Performance Counter 0.'), Field('Hit/Miss Type', Bits(17, 8), 'Event Qualifier for CM Performance Counter 0.'), Field('Source Port', Bits(7, 0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 9))),
         Register('GCR_DB_PC_QUAL0_8', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31, 6), 'Event Qualifier for CM Performance Counter 0.'), Field('Pipeline Start Type', Bits(5, 0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 8))),
         Register('GCR_DB_PC_QUAL0_6', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31, 6), 'Event Qualifier for CM Performance Counter 0.'), Field('Response Type', Bits(5, 3), 'Event Qualifier for CM Performance Counter 0.'), Field('Port Number', Bits(2, 0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 6))),
         Register('GCR_DB_PC_QUAL0_5', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31, 15), 'Event Qualifier for CM Performance Counter 0.'), Field('Request Port', Bits(14, 7), 'Event Qualifier for CM Performance Counter 0.'), Field('Response Port', Bits(6, 0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 5))),
         Register('GCR_DB_PC_QUAL0_4', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31, 2), 'Event Qualifier for CM Performance Counter 0.'), Field('L2 Data Width', Bits(1, 0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 4))),
         Register('GCR_DB_PC_QUAL0_3', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31, 1), 'Event Qualifier for CM Performance Counter 0.'), Field('Accept State', Bits(0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 3))),
         Register('GCR_DB_PC_QUAL0_2', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31, 1), 'Event Qualifier for CM Performance Counter 0.'), Field('Accept State', Bits(0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 2))),
         Register('GCR_DB_PC_QUAL0_1', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Reserved', Bits(31, 25), 'Event Qualifier for CM Performance Counter 0.'), Field('Intervention State', Bits(24, 19), 'Event Qualifier for CM Performance Counter 0.'), Field('Speculation', Bits(18, 17), 'Event Qualifier for CM Performance Counter 0.'), Field('Intervention Cmd', Bits(16, 3), 'Event Qualifier for CM Performance Counter 0.'), Field('Store Conditional', Bits(2, 0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 1))),
         Register('GCR_DB_PC_QUAL0_0', 'gcr_db_0190', 'GCR_DB_PC_QUAL0', {'': [Field('Request Port', Bits(31, 24), 'Event Qualifier for CM Performance Counter 0.'), Field('Request CCA', Bits(23, 19), 'Event Qualifier for CM Performance Counter 0.'), Field('Burst Length', Bits(18, 16), 'Event Qualifier for CM Performance Counter 0.'), Field('Request Command', Bits(15, 3), 'Event Qualifier for CM Performance Counter 0.'), Field('Target', Bits(2, 0), 'Event Qualifier for CM Performance Counter 0.')]}, 'CM Performance Counter 0 Event Qualifier. The qualifier   corresponds to the event configured through the   Performance Counter 0 Event Select Register.', [], 64, And(CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*'), Op('==', Reg('GCR_DB_PC_EVENT::P0_Event'), 0))),
         Register('GCR_DB_PC_OV', 'gcr_db_0120', '', {'': [Field('Reserved', Bits(31, 3), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('P1_OF', Bits(2), 'If this bit is set to 1, CM Performance Counter 1 has overflowed    i.e., the counter has reached 0xFFFF_FFFF. Write 1 to clear'), Field('P0_OF', Bits(1), 'If this bit is set to 1, CM Performance Counter 0 has overflowed    i.e., the counter has reached 0xFFFF_FFFF. Write 1 to clear'), Field('Cycl_Cnt_OF', Bits(0), 'If this bit is set to 1, the CM Cycle Counter Register has    overflowed. Write 1 to clear')]}, 'Performance Counter Overflow Status Register', [], 64, CPUNameMatches('proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_PC_EVENT', 'gcr_db_0130', '', {'': [Field('Reserved', Bits(31, 16), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('P1_Event', Bits(15, 8), 'Event Selection for CM Performance Counter 1. Event qualifiers are defined in the core SUM', [Value('Request_Count', 0), Value('Coh_Req_Resp', 1), Value('L2_WR_Data_Util', 2), Value('L2_Cmd_Util', 3), Value('L2_RD_Data_Util', 4), Value('Sharing_Miss', 5), Value('RSU_Util', 6), Value('L2_Util', 8), Value('L2_Hit', 9), Value('IOCU_Request', 16), Value('IOCU1_Request', 17)]), Field('P0_Event', Bits(7, 0), 'Event Selection for CM Performance Counter 0. Event qualifiers are defined in the core SUM', [Value('Request_Count', 0), Value('Coh_Req_Resp', 1), Value('L2_WR_Data_Util', 2), Value('L2_Cmd_Util', 3), Value('L2_RD_Data_Util', 4), Value('Sharing_Miss', 5), Value('RSU_Util', 6), Value('L2_Util', 8), Value('L2_Hit', 9), Value('IOCU_Request', 16), Value('IOCU1_Request', 17)])]}, 'Performance Counter Overflow Status Register', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_PC_CYCLE', 'gcr_db_0180', '', {}, 'The CM Cycle Count Register is a 32-bit register that keeps count    of CM clock cycles. It is controlled through the Cycl_Cnt_CountOn and    Cycl_Cnt_Reset bits in the CM Performance Counter Control Register. An    overflow of the cycle counter is indicated by a 1 in the Cycl_Cnt_Overflow    bit in the CM Performance Counter Overflow Status Register.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_PC_CTL', 'gcr_db_0100', '', {'': [Field('Reserved', Bits(31), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('Perf_Int_En', Bits(30), 'Enable Interrupt on counter overflow. If set to 1, a CM2 performance    counter interrupt is generated when any enabled    CM2 performance counter overflows.'), Field('Perf_Ovf_Stop', Bits(29), 'Stop Counting on overflow. If set to 1, all CM2 Performance    counters stop counting when any enabled CM2 performance    counter overflows i.e., the counter has reached    0xFFFF_FFFF.'), Field('Reserved', Bits(28, 10), 'Reads as 0x0. Must be written with a value of 0x0.'), Field('P1_Reset', Bits(9), 'If set to 1, CM2 Performance Counter 1 and P1_Overflow    bit is reset before counting is started. If set to 0 counting is    resumed from previous value. This bit is automatically set to    0 when the counter is reset, so P1_Reset is always read as 0.'), Field('P1_CountOn', Bits(8), 'Start Counting. If this bit is set to 1 then CM2 Performance    Counter 1 and the P1_Overflow bit starts counting the specified    event. If this bit is set to 0 then CM2 Performance Counter    1 is disabled. This bit is automatically set to 0 if any    counter overflows and Perf_Ovf_Stop is set to 1.'), Field('P0_Reset', Bits(7), 'If set to 1, CM2 Performance Counter 0 and P0_Overflow    bit is reset before counting is started. If set to 0 counting is    resumed from previous value. This bit is automatically set to    0 when the counter is reset, so P0_Reset is always read as 0.'), Field('P0_CountOn', Bits(6), 'Start/Stop Counting. If this bit is set to 1 then CM2 Performance    Counter 0 starts counting the specified event. If this    bit is set to 0 then CM2 Performance Counter 0 is disabled.    This bit is automatically set to 0 if any counter overflows and    Perf_Ovf_Stop is set to 1.'), Field('Cycl_Cnt_Reset', Bits(5), 'If set to 1, the CM2 Cycle Counter Register and the    Cycl_Cnt_Overflow bit is reset before counting is started. If    set to 0 counting is resumed from previous value. This bit is    automatically set to 0 when the counter is reset, so    Cycl_Cnt_Reset is always read as 0.'), Field('Cycl_Cnt_CountOn', Bits(4), 'Start/Stop the Cycle Counter. If this bit is set to 1 then CM2    Cycle Counter starts counting. If this bit is set to 0 then CM2    Cycle Counter is disabled. This bit is automatically set to 0 if    any Counter Overflows and Perf_Ovf_Stop is set to 1.'), Field('Perf_Num_Cnt', Bits(3, 0), 'The number of performance counters implemented (not    including the cycle counter). The CM2 has 2 performance    counters.')]}, '', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_PC_CNT1', 'gcr_db_01a8', '', {}, '32-bit Performance Counter. The event counted is specified in   the CM Performance Counter 1 Event Select Register and   by the corresponding Qualifier Register.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('GCR_DB_PC_CNT0', 'gcr_db_0198', '', {}, '32-bit Performance Counter. The event counted is specified in   the CM Performance Counter 0 Event Select Register and   by the corresponding Qualifier Register.', [], 64, CPUNameMatches('1004K.*,1074K.*,proAptiv.*,P5600.*,interAptiv.*')),
         Register('CPC_CL_STAT_CONF_REG', 'cpc_cl_0008', '', 'STAT_CONF_REG_FIELDS', 'Individual domain power status and domain configuration register. Reflects domain micro-sequencer execution. Initiates microsequencer after status register programming. Reflects command execution status.', [], 32, Condition('CPC_PRESENT_AND_ENABLED')),
         Register('CPC_CL_OTHER_REG', 'cpc_cl_0010', '', {'': [Field('Reserved', Bits(31, 24)), Field('CORENUM', Bits(23, 16), 'CoreNum of the register set to be accessed in the Core Other address space.'), Field('Reserved', Bits(15, 0))]}, 'Used to access local registers of another core.', [], 32, Op('==', Condition('CPC_PRESENT_AND_ENABLED'), True)),
         Register('CPC_CL_CMD_REG', 'cpc_cl_0000', '', 'CMD_REG_FIELDS', 'Requests a new power sequence execution for this domain. Read value is the last executed command.', [], 32, Condition('CPC_PRESENT_AND_ENABLED')),
         Register('CPC_REVISION_REG', 'cpc_0020', '', {'': [Field('RESERVED', Bits(31, 16)), Field('MAJOR_REV', Bits(15, 8), 'This field reflects the major revision of the CPC block. A major revision might reflect the changes from one product generation to another.'), Field('MINOR_REV', Bits(7, 0), 'This field reflects the minor revision of the CPC block. A minor revision might reflect the changes from one release to another.')]}, '', [], 32, Condition('CPC_PRESENT_AND_ENABLED')),
         Register('CPC_RESETLEN_REG', 'cpc_0018', '', {'': [Field('RESERVED', Bits(31, 10)), Field('RESETLEN', Bits(9, 0), '10-bit counter value to extend reset duration beyond PB_Reset_N feedback. The domain behavior after reset is determined by    the domain local setup register.')]}, '', [], 32, Condition('CPC_PRESENT_AND_ENABLED')),
         Register('CPC_RAIL_REG', 'cpc_0010', '', {'': [Field('RESERVED', Bits(31, 10)), Field('RAILDELAY', Bits(9, 0), '10-bit counter value to delay power-up sequence per domain after RailStable and VddOK signals became active. The power-up    micro-sequence starts after RAILDELAY has been loaded into the internal counter and a counted down to zero has concluded.')]}, '', [], 32, Condition('CPC_PRESENT_AND_ENABLED')),
         Register('CPC_SEQDEL_REG', 'cpc_0008', '', {'': [Field('RESERVED', Bits(31, 10)), Field('MICROSTEP', Bits(9, 0), 'This field reflects the delay in clock cycles, taken by each power domain micro-sequencer to advance between atomic micro steps.')]}, '', [], 32, Condition('CPC_PRESENT_AND_ENABLED')),
         Register('CPC_ACCESS_REG', 'cpc_0000', '', {'': [Field('RESERVED', Bits(31, 8)), Field('CM_ACCESS_EN', Bits(7, 0), 'Each bit in this field represents a power domain CPU. If the bit is set, that requester is able to write to the CPC registers    (this includes all registers within the Global, Core-Local and Core-Other blocks. If the bit is clear, any write request from that    requestor to the CPC registers (Global, Core-Local, Core-Other) will be dropped.')]}, '', [], 32, Condition('CPC_PRESENT_AND_ENABLED')),
         Register('D31', 'd31', '', '64bit_FPU', 'Floating point register F31', [], 64, Condition('FPU_Present')),
         Register('D30', 'd30', '', '64bit_FPU', 'Floating point register F30', [], 64, Condition('FPU_Present')),
         Register('D29', 'd29', '', '64bit_FPU', 'Floating point register F29', [], 64, Condition('FPU_Present')),
         Register('D28', 'd28', '', '64bit_FPU', 'Floating point register F28', [], 64, Condition('FPU_Present')),
         Register('D27', 'd27', '', '64bit_FPU', 'Floating point register F27', [], 64, Condition('FPU_Present')),
         Register('D26', 'd26', '', '64bit_FPU', 'Floating point register F26', [], 64, Condition('FPU_Present')),
         Register('D25', 'd25', '', '64bit_FPU', 'Floating point register F25', [], 64, Condition('FPU_Present')),
         Register('D24', 'd24', '', '64bit_FPU', 'Floating point register F24', [], 64, Condition('FPU_Present')),
         Register('D23', 'd23', '', '64bit_FPU', 'Floating point register F23', [], 64, Condition('FPU_Present')),
         Register('D22', 'd22', '', '64bit_FPU', 'Floating point register F22', [], 64, Condition('FPU_Present')),
         Register('D21', 'd21', '', '64bit_FPU', 'Floating point register F21', [], 64, Condition('FPU_Present')),
         Register('D20', 'd20', '', '64bit_FPU', 'Floating point register F20', [], 64, Condition('FPU_Present')),
         Register('D19', 'd19', '', '64bit_FPU', 'Floating point register F19', [], 64, Condition('FPU_Present')),
         Register('D18', 'd18', '', '64bit_FPU', 'Floating point register F18', [], 64, Condition('FPU_Present')),
         Register('D17', 'd17', '', '64bit_FPU', 'Floating point register F17', [], 64, Condition('FPU_Present')),
         Register('D16', 'd16', '', '64bit_FPU', 'Floating point register F16', [], 64, Condition('FPU_Present')),
         Register('D15', 'd15', '', '64bit_FPU', 'Floating point register F15', [], 64, Condition('FPU_Present')),
         Register('D14', 'd14', '', '64bit_FPU', 'Floating point register F14', [], 64, Condition('FPU_Present')),
         Register('D13', 'd13', '', '64bit_FPU', 'Floating point register F13', [], 64, Condition('FPU_Present')),
         Register('D12', 'd12', '', '64bit_FPU', 'Floating point register F12', [], 64, Condition('FPU_Present')),
         Register('D11', 'd11', '', '64bit_FPU', 'Floating point register F11', [], 64, Condition('FPU_Present')),
         Register('D10', 'd10', '', '64bit_FPU', 'Floating point register F10', [], 64, Condition('FPU_Present')),
         Register('D9', 'd9', '', '64bit_FPU', 'Floating point register F9', [], 64, Condition('FPU_Present')),
         Register('D8', 'd8', '', '64bit_FPU', 'Floating point register F8', [], 64, Condition('FPU_Present')),
         Register('D7', 'd7', '', '64bit_FPU', 'Floating point register F7', [], 64, Condition('FPU_Present')),
         Register('D6', 'd6', '', '64bit_FPU', 'Floating point register F6', [], 64, Condition('FPU_Present')),
         Register('D5', 'd5', '', '64bit_FPU', 'Floating point register F5', [], 64, Condition('FPU_Present')),
         Register('D4', 'd4', '', '64bit_FPU', 'Floating point register F4', [], 64, Condition('FPU_Present')),
         Register('D3', 'd3', '', '64bit_FPU', 'Floating point register F3', [], 64, Condition('FPU_Present')),
         Register('D2', 'd2', '', '64bit_FPU', 'Floating point register F2', [], 64, Condition('FPU_Present')),
         Register('D1', 'd1', '', '64bit_FPU', 'Floating point register F1', [], 64, Condition('FPU_Present')),
         Register('D0', 'd0', '', '64bit_FPU', 'Floating point register F0', [], 64, Condition('FPU_Present')),
         Register('F31', 'f31', '', '32bit_FPU', 'Floating point register F31', [], 32, Condition('FPU_Present')),
         Register('F30', 'f30', '', '32bit_FPU', 'Floating point register F30', [], 32, Condition('FPU_Present')),
         Register('F29', 'f29', '', '32bit_FPU', 'Floating point register F29', [], 32, Condition('FPU_Present')),
         Register('F28', 'f28', '', '32bit_FPU', 'Floating point register F28', [], 32, Condition('FPU_Present')),
         Register('F27', 'f27', '', '32bit_FPU', 'Floating point register F27', [], 32, Condition('FPU_Present')),
         Register('F26', 'f26', '', '32bit_FPU', 'Floating point register F26', [], 32, Condition('FPU_Present')),
         Register('F25', 'f25', '', '32bit_FPU', 'Floating point register F25', [], 32, Condition('FPU_Present')),
         Register('F24', 'f24', '', '32bit_FPU', 'Floating point register F24', [], 32, Condition('FPU_Present')),
         Register('F23', 'f23', '', '32bit_FPU', 'Floating point register F23', [], 32, Condition('FPU_Present')),
         Register('F22', 'f22', '', '32bit_FPU', 'Floating point register F22', [], 32, Condition('FPU_Present')),
         Register('F21', 'f21', '', '32bit_FPU', 'Floating point register F21', [], 32, Condition('FPU_Present')),
         Register('F20', 'f20', '', '32bit_FPU', 'Floating point register F20', [], 32, Condition('FPU_Present')),
         Register('F19', 'f19', '', '32bit_FPU', 'Floating point register F19', [], 32, Condition('FPU_Present')),
         Register('F18', 'f18', '', '32bit_FPU', 'Floating point register F18', [], 32, Condition('FPU_Present')),
         Register('F17', 'f17', '', '32bit_FPU', 'Floating point register F17', [], 32, Condition('FPU_Present')),
         Register('F16', 'f16', '', '32bit_FPU', 'Floating point register F16', [], 32, Condition('FPU_Present')),
         Register('F15', 'f15', '', '32bit_FPU', 'Floating point register F15', [], 32, Condition('FPU_Present')),
         Register('F14', 'f14', '', '32bit_FPU', 'Floating point register F14', [], 32, Condition('FPU_Present')),
         Register('F13', 'f13', '', '32bit_FPU', 'Floating point register F13', [], 32, Condition('FPU_Present')),
         Register('F12', 'f12', '', '32bit_FPU', 'Floating point register F12', [], 32, Condition('FPU_Present')),
         Register('F11', 'f11', '', '32bit_FPU', 'Floating point register F11', [], 32, Condition('FPU_Present')),
         Register('F10', 'f10', '', '32bit_FPU', 'Floating point register F10', [], 32, Condition('FPU_Present')),
         Register('F9', 'f9', '', '32bit_FPU', 'Floating point register F9', [], 32, Condition('FPU_Present')),
         Register('F8', 'f8', '', '32bit_FPU', 'Floating point register F8', [], 32, Condition('FPU_Present')),
         Register('F7', 'f7', '', '32bit_FPU', 'Floating point register F7', [], 32, Condition('FPU_Present')),
         Register('F6', 'f6', '', '32bit_FPU', 'Floating point register F6', [], 32, Condition('FPU_Present')),
         Register('F5', 'f5', '', '32bit_FPU', 'Floating point register F5', [], 32, Condition('FPU_Present')),
         Register('F4', 'f4', '', '32bit_FPU', 'Floating point register F4', [], 32, Condition('FPU_Present')),
         Register('F3', 'f3', '', '32bit_FPU', 'Floating point register F3', [], 32, Condition('FPU_Present')),
         Register('F2', 'f2', '', '32bit_FPU', 'Floating point register F2', [], 32, Condition('FPU_Present')),
         Register('F1', 'f1', '', '32bit_FPU', 'Floating point register F1', [], 32, Condition('FPU_Present')),
         Register('F0', 'f0', '', '32bit_FPU', 'Floating point register F0', [], 32, Condition('FPU_Present')),
         Register('FIR', 'fir', '', {'': [Field('Reserved', Bits(31, 28), 'Reserved for future use; reads as zero.'), Field('Impl', Bits(27, 24), 'These bits are implementation dependent and are not defined by the architecture, other than the fact that they are read-only. This bits are explicitly not intended to be used for mode control functions.'), Field('Has2008', Bits(23), 'Indicates that one or more IEEE-754-2008 features are implemented. If this bit is set, the MAC2008, ABS2008, NAN2008 fields within the FCSR register also exist'), Field('F64', Bits(22), 'Indicates that the floating point unit has registers and data paths that are 64-bits wide. This bit was added in Release 2 of the Architecture, and is a one on either any processors with a 64-bit floating point unit, and a zero on any processors with a 32-bit floating point unit. A value of one in this bit indicates that StatusFR is implemented.', [Value('FPU is 32 bits', 0), Value('FPU is 64 bits', 1)]), Field('L', Bits(21), 'Indicates that the longword fixed point (L) data type and instructions are implemented.', [Value('L fixed point not implemented', 0), Value('L fixed point implemented', 1)]), Field('W', Bits(20), 'Indicates that the word fixed point (W) data type and instructions are implemented.', [Value('W fixed point not implemented', 0), Value('W fixed point implemented', 1)]), Field('3D', Bits(19), 'In Release 1 of the Architecture, this bit is used by MIPS64 processors to indicate that the MIPS-3D ASE is implemented. It is not used by MIPS32 processors and reads as zero. In Release 2 of the Architecture and subsequent releases, the MIPS-3D ASE is supported on any processors with a 64-bit floating point unit, and this bit indicates that the MIPS-3D ASE is implemented.', [Value('MIPS-3D ASE not implemented', 0), Value('MIPS-3D ASE implemented', 1)]), Field('PS', Bits(18), 'In Release 1 of the Architecture, this bit is used by MIPS64 processors to indicate that the paired single floating point data type is implemented. It is not used by MIPS32 Release 1 processors and reads as zero. In Release 2 of the Architecture and subsequent releases, this bit indicates that the paired single floating point data type is implemented.', [Value('PS floating point not implemented', 0), Value('PS floating point implemented', 1)]), Field('D', Bits(17), 'Indicates that the double-precision (D) floating point data type and instructions are implemented.', [Value('D floating point not implemented', 0), Value('D floating point implemented', 1)]), Field('S', Bits(16), 'Indicates that the single-precision (S) floating point data type and instructions are implemented.', [Value('S floating point not implemented', 0), Value('S floating point implemented', 1)]), Field('ProcessorID', Bits(15, 8), 'Identifies the floating point processor. This value should normally match the corresponding field of the PRId CP0 register unless there are different floating point implementations used by a single CPU.'), Field('Revision', Bits(7, 0), 'Specifies the revision number of the floating point unit. This field allows software to distinguish between one revision and another of the same floating point processor type. If this field is not implemented, it must read as zero.')], 'P5600.*': [Field('Reserved', Bits(31, 29), 'Reserved for future use; reads as zero.'), Field('UFRP', Bits(28), 'User mode FR switching.', [Value('User mode FR switching instructions not supported.', 0), Value('User mode FR switching instructions supported.', 1)]), Field('Impl', Bits(27, 24), 'These bits are implementation dependent and are not defined by the architecture, other than the fact that they are read-only. This bits are explicitly not intended to be used for mode control functions.'), Field('Has2008', Bits(23), 'Indicates that one or more IEEE-754-2008 features are implemented. If this bit is set, the MAC2008, ABS2008, NAN2008 fields within the FCSR register also exist'), Field('F64', Bits(22), 'Indicates that the floating point unit has registers and data paths that are 64-bits wide. This bit was added in Release 2 of the Architecture, and is a one on either any processors with a 64-bit floating point unit, and a zero on any processors with a 32-bit floating point unit. A value of one in this bit indicates that StatusFR is implemented.', [Value('FPU is 32 bits', 0), Value('FPU is 64 bits', 1)]), Field('L', Bits(21), 'Indicates that the longword fixed point (L) data type and instructions are implemented.', [Value('L fixed point not implemented', 0), Value('L fixed point implemented', 1)]), Field('W', Bits(20), 'Indicates that the word fixed point (W) data type and instructions are implemented.', [Value('W fixed point not implemented', 0), Value('W fixed point implemented', 1)]), Field('3D', Bits(19), 'In Release 1 of the Architecture, this bit is used by MIPS64 processors to indicate that the MIPS-3D ASE is implemented. It is not used by MIPS32 processors and reads as zero. In Release 2 of the Architecture and subsequent releases, the MIPS-3D ASE is supported on any processors with a 64-bit floating point unit, and this bit indicates that the MIPS-3D ASE is implemented.', [Value('MIPS-3D ASE not implemented', 0), Value('MIPS-3D ASE implemented', 1)]), Field('PS', Bits(18), 'In Release 1 of the Architecture, this bit is used by MIPS64 processors to indicate that the paired single floating point data type is implemented. It is not used by MIPS32 Release 1 processors and reads as zero. In Release 2 of the Architecture and subsequent releases, this bit indicates that the paired single floating point data type is implemented.', [Value('PS floating point not implemented', 0), Value('PS floating point implemented', 1)]), Field('D', Bits(17), 'Indicates that the double-precision (D) floating point data type and instructions are implemented.', [Value('D floating point not implemented', 0), Value('D floating point implemented', 1)]), Field('S', Bits(16), 'Indicates that the single-precision (S) floating point data type and instructions are implemented.', [Value('S floating point not implemented', 0), Value('S floating point implemented', 1)]), Field('ProcessorID', Bits(15, 8), 'Identifies the floating point processor. This value should normally match the corresponding field of the PRId CP0 register unless there are different floating point implementations used by a single CPU.'), Field('Revision', Bits(7, 0), 'Specifies the revision number of the floating point unit. This field allows software to distinguish between one revision and another of the same floating point processor type. If this field is not implemented, it must read as zero.')]}, 'The Floating Point Implementation Register (FIR) is a 32-bit read-only register that contains information identifying the capabilities of the floating point unit, the floating point processor identification, and the revision level of the floating point unit.', [], 32, Op('==', Condition('FPU_Present'), True), 'r'),
         Register('FEXR', 'fexr', '', {'': [Field('Reserved', Bits(31, 18)), Field('CauseE', Bits(17), 'Exception caused by Unimplemented Operation'), Field('CauseV', Bits(16), 'Exception caused by Invalid Operation'), Field('CauseZ', Bits(15), 'Exception caused by Divide by Zero'), Field('CauseO', Bits(14), 'Exception caused by Overflow'), Field('CauseU', Bits(13), 'Exception caused by Underflow'), Field('CauseI', Bits(12), 'Exception caused by Inexact'), Field('Reserved', Bits(11, 7)), Field('FlagsV', Bits(6), 'Exception occurred on Invalid Operation'), Field('FlagsZ', Bits(5), 'Exception occurred on Divide by Zero'), Field('FlagsO', Bits(4), 'Exception occurred on Overflow'), Field('FlagsU', Bits(3), 'Exception occurred on Underflow'), Field('FlagsI', Bits(2), 'Exception occurred on Inexact'), Field('Reserved', Bits(1, 0))]}, 'The Floating Point Exceptions Register (FEXR) is an alternative way to read and write the Cause and Flags fields that also appear in FCSR.', [], 32, Op('==', Condition('FPU_Present'), True)),
         Register('FENR', 'fenr', '', {'': [Field('Reserved', Bits(31, 12)), Field('ExcEnV', Bits(11), 'Enable exception on Invalid Operation'), Field('ExcEnZ', Bits(10), 'Enable exception on Divide by Zero'), Field('ExcEnO', Bits(9), 'Enable exception on Overflow'), Field('ExcEnU', Bits(8), 'Enable exception on Underflow'), Field('ExcEnI', Bits(7), 'Enable exception on Inexact'), Field('Reserved', Bits(6, 3)), Field('FS', Bits(2), 'Flush to Zero. When FS is one, denormalized results are flushed to zero instead of causing an Unimplemented Operation exception. It is implementation dependent whether denormalized operand values are flushed to zero before the operation is carried out.'), Field('RM', Bits(1, 0), 'Rounding mode. This field indicates the rounding mode used for most floating point operations (some operations use a specific rounding mode).', [Value('RN - Round to Nearest', 0), Value('RZ - Round Toward Zero', 1), Value('RP - Round Towards Plus Infinity', 2), Value('RM - Round Towards Minus Infinity', 3)])]}, 'The Floating Point Enables Register (FENR) is an alternative way to read and write the Enables, FS, and RM fields that also appear in FCSR.', [], 32, Op('==', Condition('FPU_Present'), True)),
         Register('FCSR', 'fcsr', '', {'': [Field('FCC1-7', Bits(31, 25), 'Floating point condition codes. These bits record the result of floating point compares and are tested for floating point conditional branches and conditional moves. The FCC bit to use is specified in the compare, branch, or conditional move instruction. For backward compatibility with previous MIPS ISAs, the FCC bits are separated into two, non-contiguous fields.'), Field('FS', Bits(24), 'Flush to Zero. When FS is one, denormalized results are flushed to zero instead of causing an Unimplemented Operation exception. It is implementation dependent whether denormalized operand values are flushed to zero before the operation is carried out.'), Field('FCC0', Bits(23), 'See field FCC1-7'), Field('Impl', Bits(22, 21), 'Available to control implementation dependent features of the floating point unit. If these bits are not implemented, they must be ignored on write and read as zero. If used by a processor to control floating point behavior, these bits should be defined in such a way that correct behavior is preserved if software, with no knowledge of these bits, reads FCSR, modifies another field, and writes the updated value back to FCSR.'), Field('MAC2008', Bits(20), 'Fused multiply-add mode compliant with IEEE Standard 754-2008.The fused multiply-add operation multiplies and adds as if with unbounded range and precision, rounding only once to the destination format. MIPS legacy FPU implements non-fused multiply-add, which rounds the intermediary multiplication result to the destination format. This field applies to the MADD.fmt, NMADD.fmt, MSUB.fmt and NMSUB.fmt instructions. This fields exists if FIRHas2008 is set. Implementations are allowed to implement only one multiply-add rounding behavior. In that case, this field is preset by hardware.', [Value('Non-fused multiply-add', 0), Value('IEEE 754-2008 fused multiply-add', 1)]), Field('ABS2008', Bits(19), 'ABS.fmt and NEG.fmt instructions compliant with IEEE Standard 754-2008. The IEEE 754-2008 standard requires that the ABS and NEG functions are non-arithmetic and accept NAN inputs without trapping. This fields exists if FIRHas2008 is set. Implementations are allowed to implement only one ABS/NEG NAN behavior. In that case, this field is preset by hardware.', [Value('ABS and NEG instructions are arithmetic and trap for NAN input. MIPS legacy behavior.', 0), Value('ABS and NEG instructions are non-arithmetic and accept NAN input without trapping. IEEE 754-2008 behavior', 1)]), Field('NAN2008', Bits(18), 'Quiet and signaling NaN encodings recommended by the IEEE Standard 754-2008, i.e. a quiet NaN is encoded with the first bit of the fraction being 1 and a signaling NaN is encoded with the first bit of the fraction field being 0. MIPS legacy FPU encodes NaN values with the opposite polarity, i.e. a quiet NaN is encoded with the first bit of the fraction being 0 and a signaling NaN is encoded with the first bit of the fraction field being 1. Refer to Table 5.3 for the quiet NaN encoding values. This fields exists if FIRHas2008 is set. Implementations are allowed to implement only one QNAN encoding. In that case, this field is preset by hardware.', [Value('MIPS legacy NaN encoding', 0), Value('IEEE 754-2008 NaN encoding', 1)]), Field('CauseE', Bits(17), 'Exception caused by Unimplemented Operation'), Field('CauseV', Bits(16), 'Exception caused by Invalid Operation'), Field('CauseZ', Bits(15), 'Exception caused by Divide by Zero'), Field('CauseO', Bits(14), 'Exception caused by Overflow'), Field('CauseU', Bits(13), 'Exception caused by Underflow'), Field('CauseI', Bits(12), 'Exception caused by Inexact'), Field('ExcEnV', Bits(11), 'Enable exception on Invalid Operation'), Field('ExcEnZ', Bits(10), 'Enable exception on Divide by Zero'), Field('ExcEnO', Bits(9), 'Enable exception on Overflow'), Field('ExcEnU', Bits(8), 'Enable exception on Underflow'), Field('ExcEnI', Bits(7), 'Enable exception on Inexact'), Field('FlagV', Bits(6), 'Exception occurred on Invalid Operation'), Field('FlagZ', Bits(5), 'Exception occurred on Divide by Zero'), Field('FlagO', Bits(4), 'Exception occurred on Overflow'), Field('FlagU', Bits(3), 'Exception occurred on Underflow'), Field('FlagI', Bits(2), 'Exception occurred on Inexact'), Field('RM', Bits(1, 0), 'Rounding mode. This field indicates the rounding mode used for most floating point operations (some operations use a specific rounding mode).', [Value('RN - Round to Nearest', 0), Value('RZ - Round Toward Zero', 1), Value('RP - Round Towards Plus Infinity', 2), Value('RM - Round Towards Minus Infinity', 3)])]}, 'The Floating-Point-Control-and-Status-Register (FCSR) is a 32-bit register that controls the operation of the floating point unit, and shows the following status information: (1) selects the default rounding mode for FPU arithmetic operations; (2) selectively enables traps of FPU exception conditions; (3) controls some denormalized number handling options; (4) reports any IEEE exceptions that arose during the most recently executed instruction; (5) reports IEEE exceptions that arose, cumulatively, in completed instructions; (6) indicates the condition code result of FP compare instructions; Access to FCSR is not privileged; it can be read or written by any program that has access to the floating point unit (via the coprocessor enables in the Status register).', [], 32, Op('==', Condition('FPU_Present'), True)),
         Register('FCCR', 'fccr', '', {'': [Field('FCC', Bits(7, 0), 'Floating point condition codes. These bits record the result of floating point compares and are tested for floating point conditional branches and conditional moves. The FCC bit to use is specified in the compare, branch, or conditional move instruction.')]}, 'The Floating Point Condition Codes Register (FCCR) is an alternative way to read and write the floating point condition code values that also appear in FCSR. Unlike FCSR, all eight FCC bits are contiguous in FCCR.', [], 32, Op('==', Condition('FPU_Present'), True)),
         Register('TCBConfigOCI32', 'ejtag_tcbconfig', 'TCBConfig', {'': [Field('REV', Bits(3, 0), 'Revision of TCB.{p}                                 Indicates the revision of the PDTrace Specification (this document) that                                 an implementation conforms to. This field must be set to the                                 corresponding integer value given in the table below..', [Value('revision_4_xx', 1), Value('revision_5_xx', 2), Value('revision_6_xx', 3), Value('revision_8_xx', 4), Value('revision_9_xx', 5), Value('revision_10_xx', 6)])]}, 'The TCBCONFIG register holds hardware configuration information in the TCB.', [], 32, And(Op('==', Condition('oci64_present'), False), Op('==', Condition('PDtrace'), True))),
         Register('TCBConfigOCI64', 'drseg_tcbconfig', 'TCBConfig', {'': [Field('REV', Bits(3, 0), 'Revision of TCB.{p}                                 Indicates the revision of the PDTrace Specification (this document) that                                  an implementation conforms to. This field must be set to the                                  corresponding integer value given in the table below..', [Value('revision_4_xx', 1), Value('revision_5_xx', 2), Value('revision_6_xx', 3), Value('revision_8_xx', 4), Value('revision_9_xx', 5), Value('revision_10_xx', 6)])]}, 'The TCBCONFIG register holds hardware configuration information in the TCB.', [], 32, And(Op('==', Condition('oci64_present'), True), Op('==', Condition('PDtrace'), True))),
         Register('DCR', 'ejtag_dcr', '', {'': [Field('EJTAG_Brk_Override', Bits(31), 'Override EjtagBrk and DINT disable. Please refer to     Secure Debug Chapter.${p}     Re-enable EjtagBrk and DINT signal during boot.${p}     Allows EjtagBrk to be asserted by a EJTAG probe (or     assertion of DINT signal) , resulting in a request for a     Debug Interrupt exception from the processor. This provides     a means of recovering the cpu from crash, hang,     loop or low-power mode.${p}     This feature can allow a Debug Executive to communicate     with the probe over the Fast Debug Channel (FDC)     and provides a host-based debugger the ability to query     the target processor via Debug Executive commands,     useful for determining cause of hang.${p}     Software can write this bit and read back to determine if     the Secure Debug feature is implemented.'), Field('ENM', Bits(29), 'Endianess in which the processor is running in kernel     and Debug Mode', [Value('Little Endian', 0), Value('Big Endian', 1)]), Field('PCnoGID', Bits(28), 'Controls whether PC Sampling includes or omits the     GuestID when the VZE module is implemented', [Value('GuestID included', 0), Value('GuestID omitted', 1)]), Field('PCnoTCID', Bits(27), 'Controls whether PC Sampling includes or omits the TC     identity field when the MT Module is implemented', [Value('TC field included', 0), Value('TC field omitted', 1)]), Field('PCIM', Bits(26), 'Configures PC Sampling to capture all executed     addresses or only those that miss in the instruction     cache', [Value(u'All PC\u2019s captured', 0), Value('Only i-cache misses', 1)]), Field('PCnoASID', Bits(25), 'Controls whether the PCSAMPLE scan chain includes     or omits the ASID field', [Value('ASID included', 0), Value('ASID omitted', 1)]), Field('DASQ', Bits(24), 'Qualifies Data Address Sampling using a data breakpoint', [Value('All data addresses samples', 0), Value('Only data breakpoint 0 samples', 1)]), Field('DASe', Bits(23), 'Enables Data Address Sampling', [Value('Sampling disabled', 0), Value('Sampling enabled', 1)]), Field('DAS', Bits(22), 'Indicates if the Data Address Sampling feature is implemented', [Value('Not Implemented', 0), Value('Implemented', 1)]), Field('FDCImpl', Bits(18), 'Indicates if the fast debug channel is implemented', [Value('Implemented', 0), Value('Implemented', 1)]), Field('DataBrk', Bits(17), 'Indicates if data hardware breakpoint is implemented', [Value('Not implemented', 0), Value('Implemented', 1)]), Field('InstBrk', Bits(16), 'Indicates if instruction hardware breakpoint is implemented', [Value('Not implemented', 0), Value('Implemented', 1)]), Field('IVM', Bits(15), 'Indicates if inverted data value match on data hardware     breakpoints is implemented', [Value('Not implemented', 0), Value('Implemented', 1)]), Field('DVM', Bits(15), 'Indicates if a data value store on a data value breakpoint     match is implemented', [Value('Not implemented', 0), Value('Implemented', 1)]), Field('RDVec', Bits(11), 'Enables relocation of the debug exception vector. The     value in the DebugVectorAddr register is used for     EJTAG exceptions when ProbTrap=0 and RDVec=1.'), Field('CBT', Bits(10), 'Indicates if complex breakpoint block is implemented', [Value('Not implemented', 0), Value('Implemented', 1)]), Field('PCS', Bits(9), 'Indicates if the PC Sampling feature is implemented', [Value('Not implemented', 0), Value('Implemented', 1)]), Field('PCR', Bits(8, 6), 'PC Sampling rate. Values 0 to 7 map to values 25 to 212     cycles, respectively. That is, a PC sample is written out     every 32, 64, 128, 256, 512, 1024, 2048, or 4096 cycles     respectively. The external probe or software is allowed to     set this value to the desired sample rate.'), Field('PCSe', Bits(5), 'If the PC sampling feature is implemented, then indicates     whether PC sampling is initiated or not. That is, a     value of 0 indicates that PC sampling is not enabled, and     a bit value of 1 indicates PC sampling is enabled and the     counters are operational.'), Field('IntE', Bits(4), 'Hardware and software interrupt enable for Non-Debug     Mode, in conjunction with other disable mechanisms', [Value('Interrupt disabled', 0), Value('Interrupt enabled', 1)]), Field('NMIE', Bits(3), 'Non-Maskable Interrupt (NMI) enable for Non-Debug     Mode', [Value('NMI disabled', 0), Value('NMI enabled', 1)]), Field('NMIpend', Bits(2), 'Indication for pending NMI', [Value('No NMI pending', 0), Value('NMI pending', 1)]), Field('SRstE', Bits(1), 'Controls soft reset enable. When 0, Soft reset masked for soft reset sources     dependent on implementation.  When 1, Soft reset is fully enabled.', [Value('Soft Reset Masked', 0), Value('Soft Reset Fully Enabled', 1)]), Field('ProbEn', Bits(0), 'Indicates value of the ProbEn value in the DCR register.     Bit is read-only (R) and reads as zero if not implemented.', [Value('No access to dmseg should occur', 0), Value('Accesses to dmseg serviced by probe', 1)])]}, 'The Debug Control Register (DCR) controls and provides information about debug issues.', [], 32, Or(Op('==', Condition('ejtag_present'), True), Op('==', Condition('oci32_present'), True))),
         Register('NestedExc', 'cp0.13.5', '', {'M51[05]0': [Field('0', Bits(31, 3), 'Reserved.  Must be written as zero; returns zero on read.'), Field('ERL', Bits(2), 'Value of Status[ERL] prior to acceptance of current exception.'), Field('EXL', Bits(1), 'Value of Status[EXL] prior to acceptance of current exception.'), Field('0', Bits(0), 'Reserved.  Must be written as zero; returns zero on read.')]}, 'The Nested Exception (NestedExc) register is an optional read-only register containing the values of StatusEXL and StatusERL prior to acceptance of the current exception.', [], 32, Op('==', Reg('config5::NFExists'), 1), 'r'),
         Register('NestedEPC', 'cp0.14.2', '', {'M51[05]0': []}, 'The Nested Exception Program Counter (NestedEPC) is an optional read/write register with the same behavior as the EPC register, except that:${p}         The NestedEPC register ignores the value of StatusEXL and is therefore updated on the occurrence ${nl}         of any exception, including nested exceptions. ${p}         The NestedEPC register is not used by the ERET/DERET/IRET instructions. To return to the address ${nl}         stored in NestedEPC, software must copy the value of the NestedEPC register to the EPC register.', [], 32, Op('==', Reg('config5::NFExists'), 1), 'r'),
         Register('GuestCtl3', 'cp0.10.6', '', {'M51[05]0': [Field('0', Bits(31, 4), 'Reserved.  Must be written as zero; returns zero on read.'), Field('GLSS', Bits(3, 0), 'Guest Lowest Shadow Set number.')]}, 'The GuestCtl3 register is required only if Shadow GPR sets are supported, and the Shadow Sets used by a guest are virtual and require mapping to physical Shadow Sets.', [], 32, And(Op('==', Reg('Config3::VZ'), 1), Op('gte', Reg('SRSCtl::HSS'), 1))),
         Register('GuestCtl2', 'cp0.10.5', '', {'P6600.*,I6[45]00.*': [Field('ASE0', Bits(31, 30), 'MCU Module extension for VIP. Must be written as zero; returns zero on read.', [], None, 'P6600.*'), Field('HC', Bits(29, 24), 'Hardware Clear for GuestCtl2.VIP This set of bits maps one to one to GuestCtl2.VIP.     HC may be bit-wise Read-only or R/W. If a bit is Read-only, then it may be preset to 0 or 1. Similarly, if a bit is      R/W, then it may be reset to 0 or 1. The interpretation of 0 or 1 state follows. Encoding: (0) The deassertion of      related external interrupt (IRQ[n]) has no effect on GuestCtl2.VIP[n]. Root software must write zero to      GuestCtl2.VIP[n] to clear the virtual interrupt. (1) The deassertion of related external interrupt (IRQ[n]) causes      GuestCtl2.VIP[n] to be cleared by h/w. In the case of HC=0, Guest.Cause.IP[n+2] could continue to be asserted due to an     external interrupt when GuestCtl2.VIP[n] is cleared by software. Source of external     interrupt must be serviced appropriately.'), Field('ASE1', Bits(17, 16), 'MCU Module extension for VIP. Must be written as zero; returns zero on read.', [], None, 'P6600.*'), Field('VIP', Bits(15, 10), 'Virtual Interrupt Pending. The VIP field is used by root to inject virtual interrupts into     Guest context. VIP[5..0] maps to Guest.Status.IP[7..2]. VIP effects Guest.Status.IP in the the following manner: (0)      Guest.Status.IP[n+2] cannot be asserted due to VIP[n], though it may be asserted by an external interrupt IRQ[n]. n = 5..0      (1) Guest.Status.IP[n+2] must at least be asserted due to VIP[n]. It may also be asserted by a concurrent external      interrupt. n=5..0')], 'P5600': [Field('ASE_HC', Bits(31, 30), 'MCU Module extension for HC. Must be written as zero; returns zero on read.'), Field('HC', Bits(29, 24), 'Hardware Clear for GuestCtl2[VIP]. This set of bits maps one to one to GuestCtl2[VIP].           HC may be bit-wise Read-only or R/W. If a bit is Read-only, then it may be           preset to 0 or 1. Similarly, if a bit is R/W, then it may be reset to 0 or 1. The           interpretation of 0 or 1 state follows:${nl}        0: The deassertion of related external interrupt (IRQ[n]) has no effect on GuestCtl2VIP[n].         Root software must write zero to GuestCtl2VIP[n] to clear the virtual interrupt.${nl}        1: The deassertion of related external interrupt (IRQ[n]) causes GuestCtl2VIP[n] to be cleared by h/w.', [Value('(IRQ[n]) has no effect on GuestCtl2VIP[n].', 0), Value('(IRQ[n]) causes GuestCtl2VIP[n] to be cleared by h/w.', 1)]), Field('ASE_VIP', Bits(17, 16), 'MCU Module extension for VIP. Must be written as zero; returns zero on read.'), Field('VIP', Bits(15, 10), 'Virtual Interrupt Pending. The VIP field is used by the root to inject virtual interrupts into the Guest context.${nl}    0: Guest.StatusIP[n+2] cannot be asserted due to VIP[n], though it may be asserted by an external interrupt IRQ[n]. n = 5..0.${nl}    1: Guest.StatusIP[n+2] must at least be asserted due to VIP[n]. It may also be asserted by a concurrent external interrupt. n=5..0', [Value('Guest.StatusIP[n+2] cannot be asserted due to VIP[n].', 0), Value('Guest.StatusIP[n+2] must at least be asserted due to VIP[n].', 1)])], 'M51[05]0': [Field('HC', Bits(31, 24), 'Hardware Clear for GuestCtl2[VIP]. This set of bits maps one to one to GuestCtl2[VIP].'), Field('VIP', Bits(17, 10), 'Virtual Interrupt Pending. The VIP field is used by the root to inject virtual interrupts into the Guest context.'), Field('Impl', Bits(4, 0), 'These bits are implementation-dependent and are not defined by the architecture.')]}, 'The GuestCtl2 register is only required if support for virtual interrupts in non-EIC mode is included in an implementation.', [], 32, And(Op('==', Reg('GuestCtl0::G2'), 1), Op('==', Reg('Config3::VEIC'), 0))),
         Register('GuestCtl2_EIC', 'cp0.10.5', '', {'P5600.*,P6600.*,I6[45]00.*': [Field('GRIPL', Bits(29, 24), 'Guest RIPL: This field is written only when an interrupt received on the root interrupt bus           for a guest is taken. The RIPL(Requested Interrupt Priority Level) sent by EIC           on the root interrupt bus is written to this field.           ${nl}Root software can write the field if it needs to modify the EIC value before           assigning to guest. It may also clear this field to prevent a transition to guest           mode from causing an interrupt if this field was set with a non-zero value earlier.           ${nl}GRIPL is 10 bits only for an implementation that complies with the MCU           Module, otherwise it is 8 bits as in baseline architecture.'), Field('GVEC', Bits(15, 0), 'Guest Vector: This field is written only when an interrupt is received on the root interrupt           bus for a guest. The Vector Offset (or Number) sent by EIC on the root interrupt           bus is written to this field.           ${NL}GVEC is not loaded into any guest CP0 field, but is used to generate an interrupt           vector in guest mode using the root interrupt bus vector and not the guest           interrupt bus vector. This will only occur if the interrupt was first taken in root           mode.           ${NL}It is recommended that root software use write access only to restore context,           not to modify the value delivered by the EIC.')], 'M51[05]0': [Field('GRIPL', Bits(31, 24), 'Guest Requested Interrupt Priority Level (RIPL).'), Field('0', Bits(23, 22), 'Reserved.  Must be written as zero; returns zero on read.'), Field('GEICSS', Bits(21, 18), 'Guest External Interrupt Controller Shadow Set (EICSS).'), Field('0', Bits(17, 16), 'Reserved.  Must be written as zero; returns zero on read.'), Field('GVEC', Bits(15, 0), 'Guest vector.')]}, 'The GuestCtl2 register is required. These fields are written only when an interrupt received on the root interrupt bus for a guest is taken', [], 32, And(Op('==', Reg('GuestCtl0::G2'), 1), Op('==', Reg('Config3::VEIC'), 1))),
         Register('GuestCtl1', 'cp0.10.4', '', {'M51[05]0,P5600.*,P6600.*': [Field('EID', Bits(31, 24), 'External Interrupt Controller Guest ID.'), Field('RID', Bits(23, 16), 'Root control GuestID.'), Field('ID', Bits(7, 0), 'Guest control GuestID.')]}, 'The GuestCtl1 register defines GuestID control fields for Root and Guest that may be used in the context of TLB instructions, instruction and data address translation.', [], 32, Op('==', Reg('GuestCtl0::G1'), 1)),
         Register('GuestCtl0Ext', 'cp0.11.4', '', {'M51[05]0,P5600.*,P6600.*': [Field('RPW', Bits(9, 8), 'Root Page Walk configuration. Determines whether Root COP0 Page Walk registers are       used for GPA to RPA or RVA to RPA translations, or both. Support for RPW is optional.       If this field is read-only 0, it implies pagewalk is supported for both cases.$p{nl}      0: Pagewalk, if enabled, is enabled for both. Root software is responsible for restoring COP0 Page Walk related registers on context switch between root and guest.${nl}      1: Reserved${nl}      2: Pagewalk in root context is enabled for guest GPA to RPA translation. Root miss in root TLB causes an exception.${nl}      3: Pagewalk in root context is enabled for root RVA to RPA translation. Guest miss in root TLB causes a root exception.', [Value('Pagewalk, if enabled, is enabled for both.', 0), Value('Reserved', 1, '', True), Value('Pagewalk in root context is enabled for guest GPA to RPA.', 2), Value('Pagewalk in root context is enabled for root RVA to RPA.', 3)], None, 'P5600.*,P6600.*'), Field('NCC', Bits(7, 6), 'Nested Cache Coherency Attributes: Determines whether guest CCA is modified by root CCA in 2nd step of guest address translation.', [Value('Guest CCA is independent of root CCA', 0), Value('Guest CCA is modified by root CCA', 1), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True)]), Field('CGI', Bits(4), 'Related to GuestCtl0[CG]. Allows execution of CACHE Index Invalidate operations in guest mode.${nl}     0: Definition of GuestCtl0[CG] does not change.${nl}     1: If GuestCtl0CG =1 and GuestCtl0ExtCGI =1, then all CACHE, CACHEE Index Invalidate (code 0xb000) operations may execute in guest mode without causing a GPSI.', [Value('Definition of GuestCtl0[CG] does not change.', 0), Value('Invalidate operations may execute in guest mode without causing a GPSI.', 1)]), Field('FCD', Bits(3), 'Disables Guest Software/Hardware Field Change Exceptions.', [Value('GSFC or GHFC event will cause exception.', 0), Value('GSFC or GHFC event will not cause exception.', 1)]), Field('OG', Bits(2), 'Other GPSI Enable.', [Value('GPSI not enabled for these registers unless GuestCtl0CP0=0.', 0), Value('GPSI enabled for these registers.', 1)]), Field('BG', Bits(1), 'Bad register GPSI Enable.', [Value('GPSI not enabled for these registers unless GuestCtl0CP0=0.', 0), Value('GPSI enabled for these registers.', 1)]), Field('MG', Bits(0), 'MMU GPSI Enable.', [Value('GPSI not enabled for these registers unless GuestCtl0CP0=0.', 0), Value('GPSI enabled for these registers.', 1)])]}, 'The GuestCtl0 Extension register.', [], 32, Op('==', Reg('GuestCtl0::G0E'), 1)),
         Register('GuestCtl0', 'cp0.12.6', '', {'M51[05]0,P5600.*,P6600.*,I6[45]00.*': [Field('GM', Bits(31), 'In guest mode when GM=1 and Root.Status[EXL]=0 and Root.Status[ERL]==0 and Root.Debug[DM]==0.'), Field('RI', Bits(30), 'Guest Reserved Instruction Redirect.${nl}       0: Reserved Instruction exceptions during guest-mode execution are taken in guest mode.${nl}       1: Reserved Instruction exceptions during guest-mode execution result in a Guest Reserved Instruction Redirect exception, taken in root mode.', [Value('RI exceptions are taken in guest mode', 0), Value('RI exceptions are taken in root mode.', 1)]), Field('MC', Bits(29), 'Guest Mode-Change exception enable.${nl}       0: A change to Guest.Status[EXL] will NOT trigger a Guest HW Field Change Exception.$nl}       1: A change to Guest.Status[EXL] will trigger a Guest HW Field Change Exception.', [Value('Will NOT trigger a Guest HW Field Change Exception.', 0), Value('Will trigger a Guest HW Field Change Exception.', 1)]), Field('CP0', Bits(28), 'Guest access to coprocessor 0.${nl}       0: Guest-kernel use of a Guest Privileged Sensitive instruction will trigger a Guest Privileged Sensitive Instruction exception.${nl}       1: Guest-kernel use of a Guest Privileged Sensitive instruction is permitted, subject to all other exception conditions.', [Value('GPSI by Guest will trigger a GPSI exception.', 0), Value('GPSI by Guest is permitted.', 1)]), Field('AT', Bits(27, 26), 'Guest Address Translation control.${nl}       1: Guest MMU under Root control. Guest and Root MMU both implemented and active in hardware. This mode is optional.${nl}       3: Guest MMU under Guest control. Guest and Root MMU both implemented and active in hardware. This mode is required.', [Value('Reserved.', 0), Value('Guest MMU under Root control.', 1), Value('Reserved.', 2), Value('Guest MMU under Guest control.', 3)]), Field('GT', Bits(25), 'Guest Timer register access.${nl}       0: Guest-kernel access to Count or Compare registers, or a read of the CC field in the HWREna register with the RDHWR instruction will trigger a Guest Privileged Sensitive Instruction exception.${nl}       1: Guest-kernel read access from Count and guest-kernel read or write access to Compare is permitted, and guest reads from CC using RDHWR instruction are permitted in any mode.', [Value('Will trigger a GPSI exception.', 0), Value('Will NOT trigger a GPSI exception.', 1)]), Field('CG', Bits(24), "Cache Instruction Guest-mode enable.${nl}       0: Use of the CACHE instruction will cause a Guest Privileged Sensitive Instruction exception to occur.${nl}       1: Use of the CACHE instruction is permitted only when used with an Effective Address Operand type of 'Address'. All other operand types will cause a a Guest Privileged Sensitive Instruction exception.", [Value('Will trigger a GPSI exception.', 0), Value('Will NOT trigger a GPSI exception.', 1)]), Field('CF', Bits(23), 'Config register access.${nl}       0: Guest-kernel write access to Config0-7 will trigger a Guest Privileged Sensitive Instruction exception.${nl}       1: Guest-kernel access to Config0-7 is permitted.', [Value('Will trigger a GPSI exception.', 0), Value('Will NOT trigger a GPSI exception.', 1)]), Field('G1', Bits(22), 'GuestCtl1 register implementation. Set by hardware.', [Value('GuestCTL1 register is not implemented.', 0), Value('GuestCTL1 register is implemented.', 1)]), Field('Impl', Bits(21, 20), 'Implementation defined.'), Field('G0E', Bits(19), 'GuestCtl0Ext register implemented. Set by hardware.', [Value('GuestCtl0Ext register is not implemented', 0), Value('GuestCtl0Ext register is implemented', 1)]), Field('PT', Bits(18), 'Defines the Pending Interrupt Pass-through feature.${nl}       0: GuestCtl0[PIP] is not supported. GuestCtl0PIP is a reserved field. All external interrupts are processed via Root intervention.${nl}       1: GuestCtl0[PIP] is supported. Interrupts may be assigned to Root or Guest.', [Value('GuestCtl0[PIP] is not supported.', 0), Value('GuestCtl0[PIP] is supported.', 1)]), Field('ASE', Bits(17, 16), 'Reserved for MCU Module Pending Interrupt Passthrough.', [], None, 'P5600.*,P6600.*'), Field('PIP', Bits(15, 10), 'Pending Interrupt Pass-through (PIP).', [], None, 'P5600.*,P6600.*'), Field('PIP', Bits(17, 10), 'Pending Interrupt Pass-through (PIP).', [], None, 'M51[05]0'), Field('RAD', Bits(9), 'Root ASID De-alias mode.${nl}       0: GuestID is used to de-alias both Guest and Root TLB entries.${nl}       1: Root ASID is used to de-alias Root TLB entries when Guest TLB contains only one context at any given time.', [Value('GuestID is used to de-alias Guest and Root.', 0), Value('Root ASID is used to de-alias Root TLB entries.', 1)]), Field('DRG', Bits(8), 'Direct Root to Guest access.', [Value('Root software cannot access guest entries directly.', 0), Value('Root software can access guest entries directly.', 1)]), Field('G2', Bits(7), 'GuestCtl2 register implementation. Set by hardware.', [Value('GuestCTL2 register is not implemented.', 0), Value('GuestCTL2 register is implemented.', 1)]), Field('GExcCode', Bits(6, 2), 'Hypervisor exception cause code.', [Value('GPSI', 0, 'Guest Privileged Sensitive instruction.'), Value('GSFC', 1, 'Guest Software Field Change event'), Value('HC', 2, 'Hypercall'), Value('GRR', 3, 'Guest Reserved Instruction Redirect. A Reserved Instruction or MDMX Unusable      exception would be taken in guest mode. When GuestCtl0RI=1, this rootmode      exception is raised before the guest-mode exception can be taken.'), Value('', 4, 'N.A.'), Value('', 5, 'N.A.'), Value('', 6, 'N.A.'), Value('', 7, 'N.A.'), Value('', 8, 'N.A.'), Value('', 9, 'Guest Hardware Field Change event.'), Value('', 10, 'Guest mode initiated Root TLB exception has Guest PA available.')], None, 'M51[05]0,P5600.*'), Field('GExcCode', Bits(6, 2), 'Hypervisor exception cause code.', [Value('GPSI', 0, 'Guest Privileged Sensitive instruction.'), Value('GSFC', 1, 'Guest Software Field Change event'), Value('HC', 2, 'Hypercall'), Value('GRR', 3, 'Guest Reserved Instruction Redirect. A Reserved Instruction or MDMX Unusable      exception would be taken in guest mode. When GuestCtl0RI=1, this rootmode      exception is raised before the guest-mode exception can be taken.'), Value('IMP1', 4, 'Available for implementation specific use'), Value('IMP2', 5, 'Available for implementation specific use'), Value('IMP3', 6, 'Available for implementation specific use'), Value('IMP4', 7, 'Available for implementation specific use'), Value('GVA', 8, 'Guest mode initiated Root TLB exception has Guest Virtual Address available.      Set when a Guest mode initiated TLB translation results in a Root TLB related      exception occurring in Root mode and the Guest Physical Address is not available.'), Value('GHFC', 9, 'Guest Hardware Field Change event.'), Value('GPA', 10, 'Guest mode initiated Root TLB exception has Guest Physical Address available.      Set when a Guest mode initiated TLB translation results in a Root TLB related      exception occurring in Root mode and the Guest Physical Address is available.')], None, 'P6600.*,I6[45]00.*'), Field('SFC2', Bits(1), 'Guest Sw Field Change exception enable for Guest.Status:CU2.', [Value('GSFC exception taken if Status[CU2] is modified by guest.', 0), Value('GSFC exception not taken if Status[CU2] modified by guest.', 1)]), Field('SFC1', Bits(0), 'Guest Sw Field Change exception enable for Guest.Status:CU1.', [Value('GSFC exception taken if Status[CU1] is modified by guest.', 0), Value('GSFC exception not taken if Status[CU1] modified by guest.', 1)])]}, 'The GuestCtl0 register contains control bits that indicate whether the base mode of processor is guest mode or root mode, plus additional bits controlling guest mode access to privilegded resources.', [], 32, Op('==', Reg('Config3::VZ'), 1)),
         Register('GTOffset', 'cp0.12.7', '', {'M51[05]0,P5600.*,P6600.*,I6[45]00.*': []}, u'Two\u2019s complement offset from Root.Count.', [], 32, Op('==', Reg('Config3::VZ'), 1)),
         Register('YQMask', 'cp0.1.4', '', {'': [Field('Reserved', Bits(31, 16)), Field('Mask', Bits(15, 0))], 'proAptiv.*,interAptiv.*': [Field('0', Bits(31, 16), 'Must be written as zero; returns zero on read.'), Field('Mask', Bits(15, 0), 'Bit vector which determines which values may be used as external state qualifiers by YIELD instructions.')]}, 'Per-VPE register defining which YIELD qualifier bits may be used without generating an exception.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('VPEScheFBack', 'cp0.1.6', '', {}, 'Per-VPE register to provide scheduling feedback to software.', [], 32, Op('==', Condition('VPEScheduling'), True)),
         Register('VPESchedule', 'cp0.1.5', '', {}, 'Per-VPE register to manage scheduling of a VPE within a processor.', [], 32, Op('==', Condition('VPEScheduling'), True)),
         Register('VPEOpt', 'cp0.1.7', '', {'': [Field('Reserved', Bits(31, 12)), Field('IWX3-IWX0', Bits(11, 8), 'Set bit to stop this VPE allocating entries in this I-cache way.'), Field('Reserved', Bits(7, 4)), Field('DWX3-DWX0', Bits(3, 0), 'Set bit to stop this VPE allocating entries in this D-cache way.')], 'proAptiv.*,interAptiv.*': [Field('0', Bits(31, 12), 'Must be written as zero; returns zero on read.'), Field('IWX3-IWX0', Bits(11, 8), 'Instruction cache way exclusion mask.  Set bit to stop this VPE allocating entries in this I-cache way.'), Field('0', Bits(7, 4), 'Must be written as zero; returns zero on read.'), Field('DWX3-DWX0', Bits(3, 0), 'Data cache way exclusion mask.  Set bit to stop this VPE allocating entries in this D-cache way.')]}, 'Per-VPE register to provide control over optional features, such as cache partitioning control.', [], 32, Op('==', Condition('VPEScheduling'), True)),
         Register('VPEControl', 'cp0.1.1', '', {'': [Field('Reserved', Bits(31, 22)), Field('YSI', Bits(21), "1 for exception on all 'yield' instructions."), Field('GSI', Bits(20), '1 for exception on all gating storage accesses.'), Field('Reserved', Bits(19)), Field('EXCPT', Bits(18, 16), 'Cause of last thread exception.', [Value('Thread Underflow', 0), Value('Thread Overflow', 1), Value('Invalid YIELD Qualifier', 2), Value('Gating Storage Exception', 3), Value('YIELD Scheduler Exception', 4), Value('GS Scheduler Exception', 5), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('TE', Bits(15), 'When 0 only one TC in this VPE may run.'), Field('Reserved', Bits(14, 8)), Field('TargTC', Bits(7, 0), 'Remote TC# which will be accessed by mttr/mftr instructions.')], 'proAptiv.*,interAptiv.*': [Field('Reserved', Bits(31, 22), 'Must be written as zero; returns zero on read.'), Field('YSI', Bits(21), 'YIELD Scheduler Intercept.  If set, and the TCStatus DT bit is also set, valid YIELD instructions that could otherwise cause a rescheduling cause a Thread exception with a YIELD Scheduler Exception sub-code.'), Field('GSI', Bits(20), 'Gating Storage Scheduler Intercept.  If set, and the TCStatus DT bit is also set, Gating Storage load and store operations that would otherwise block the issuing TC cause a Thread exception with a GS Scheduler Exception sub-code.'), Field('Reserved', Bits(19), 'Must be written as zero; returns zero on read.'), Field('EXCPT', Bits(18, 16), 'Cause of last thread exception.', [Value('Thread Underflow', 0), Value('Thread Overflow', 1), Value('Invalid YIELD Qualifier', 2), Value('Gating Storage Exception', 3), Value('YIELD Scheduler Exception', 4), Value('GS Scheduler Exception', 5), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('TE', Bits(15), 'Threads Enabled.  Set by EMT instruction, cleared by DMT instruction. When 0, only one TC in this VPE may run.'), Field('Reserved', Bits(14, 8), 'Must be written as zero; returns zero on read.'), Field('TargTC', Bits(7, 0), 'TC number to be used on MTTR and MFTR instructions.')]}, 'Per-VPE register containing relatively volatile thread configuration data.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('VPEConf1', 'cp0.1.3', '', {'': [Field('Reserved', Bits(31, 28)), Field('NCX', Bits(27, 20), 'Counts CorExtend register sets available to this VPE.'), Field('Reserved', Bits(19, 18)), Field('NCP2', Bits(17, 10), 'Counts CP2 register sets available to this VPE.'), Field('Reserved', Bits(9, 8)), Field('NCP1', Bits(7, 0), 'Counts CP1 (FP) register sets available to this VPE.')], 'proAptiv.*,interAptiv.*': [Field('0', Bits(31, 28), 'Must be written as zero; returns zero on read.'), Field('NCX', Bits(27, 20), 'Number of CorExtend register sets available to this VPE.'), Field('0', Bits(19, 18), 'Must be written as zero; returns zero on read.'), Field('NCP2', Bits(17, 10), 'Number of CP2 register sets available to this VPE.'), Field('0', Bits(9, 8), 'Must be written as zero; returns zero on read.'), Field('NCP1', Bits(7, 0), 'Number of CP1 (FP) register sets available to this VPE.')]}, 'Per-VPE multi-thread configuration information.', [], 32, And(Op('==', Reg('Config3::MT'), 1), Op('==', Reg('VPEConf0::M'), 1))),
         Register('VPEConf0', 'cp0.1.2', '', {'': [Field('M', Bits(31), 'More VPEConf registers (always 1).'), Field('Reserved', Bits(30, 29)), Field('XTC', Bits(28, 21), 'Number of a TC which is running alone in this VPE.'), Field('Reserved', Bits(20)), Field('TCS', Bits(19), 'L3 cache shared between VPEs?'), Field('SCS', Bits(18), 'L2 cache shared between VPEs?'), Field('DCS', Bits(17), 'L1 D-cache shared between VPEs?'), Field('ICS', Bits(16), 'L1 I-cache shared between VPEs?'), Field('Reserved', Bits(15, 2)), Field('MVP', Bits(1), "1 when this VPE is 'master' and can read/write other VPE registers."), Field('VPA', Bits(0), 'Set zero to disable all the VPEs TCs.')], 'proAptiv.*,interAptiv.*': [Field('M', Bits(31), 'This bit is set to indicate that a VPEConf1 register is present.'), Field('0', Bits(30, 29), 'Must be written as zero; returns zero on read.'), Field('XTC', Bits(28, 21), 'Exclusive TC.  Number of a TC which is running alone in this VPE.'), Field('0', Bits(20), 'Must be written as zero; returns zero on read.'), Field('TCS', Bits(19), 'Tertiary Cache Shared.  When set, indicates that the tertiary cache described in the Config2 register is shared with at least one other VPE.'), Field('SCS', Bits(18), 'Secondary Cache Shared.  When set, indicates that the secondary cache described in the Config2 register is shared with at least one other VPE.'), Field('DCS', Bits(17), 'Data Cache Shared.  When set, indicates that the primary data cache described in the Config1 register is shared with at least one other VPE.'), Field('ICS', Bits(16), 'Instruction Cache Shared.  When set, indicates that the primary instruction cache described in the Config1 register is shared with at least one other VPE.'), Field('0', Bits(15, 2), 'Must be written as zero; returns zero on read.'), Field('MVP', Bits(1), "Master Virtual Processor.  If set, this VPE is 'master' and can read/write other VPE's registers."), Field('VPA', Bits(0), 'Virtual Processor Activated.  If set, the VPE will schedule threads and execute instructions so long as the EVP bit of the MVPControl register enables multi-VPE execution.')]}, 'Per-VPE multi-thread configuration information.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('MVPConf1', 'cp0.0.3', '', {'': [Field('C1M', Bits(31), 'If set, floating point unit (co-processor 1) implements the MDMX extension to the instruction set.'), Field('C1F', Bits(30), 'If set, floating point unit (co-processor 1) implements 64-bit instructions (all 24K,34K,74K family FPUs are 64 bit).'), Field('Reserved', Bits(29, 28)), Field('PCX', Bits(27, 20), 'No of CorExtend register sets.'), Field('Reserved', Bits(19, 18)), Field('PCP2', Bits(17, 10), 'No of CP2 register sets.'), Field('Reserved', Bits(9, 8)), Field('PCP1', Bits(7, 0), 'No of CP1 (floating point) register sets.')]}, 'Per-processor multi-VPE dynamic configuration information.', [], 32, Op('==', Reg('Config3::MT'), 1), 'r'),
         Register('MVPConf0', 'cp0.0.2', '', {'': [Field('M', Bits(31), 'This bit reads 1 if the MVPConf1 register is present, otherwise it reads 0.'), Field('Reserved', Bits(30)), Field('TLBS', Bits(29), 'TLB Sharable: Indicates that TLB sharing amongst all VPEs is possible.  TLB sharing is enabled by the STLB bit of the MVPControl register.'), Field('GS', Bits(28), 'Gating Storage Present.  Indicates that the processor is configured to support gating storage operations.  Externally set on reset based on the state of the IT_num_entries InterThread input.  If IT_num_entries is greater than zero, this bit is set to 1.'), Field('PCP', Bits(27), "Programmable Cache Partitioning: If set, indicates that the allocation behavior of the ways of the primary instruction and data caches can be controlled via the VPEOpt register's IWX and DWX fields."), Field('Reserved', Bits(26)), Field('PTLBE', Bits(25, 16), 'Total processor complement of allocatable TLB entry pairs.'), Field('TCA', Bits(15), 'TCs Allocatable: If set, TCs may be assigned to VPEs by writing the CurVPE field of the TCBind register of each TC while the VPC bit of MVPControl is set.'), Field('Reserved', Bits(14)), Field('PVPE', Bits(13, 10), 'Total processor complement of VPE contexts - 1.  This field reflects the number of VPEs present after subtracting the value of the static input SI_DisableVPE.'), Field('Reserved', Bits(9, 8)), Field('PTC', Bits(7, 0), 'Total processor complement of TCs - 1.  This field reflects the number of TCs present after subtracting the value of the static input SI_DisableTCs.')]}, 'Per-processor multi-VPE dynamic configuration information.', [], 32, Op('==', Reg('Config3::MT'), 1), 'r'),
         Register('HWREna', 'cp0.7.0', '', {'': [Field('Impl', Bits(31, 30), 'These bits enable access to the implementation-dependent hardware registers 31 and 30.  If a register is not implemented, the corresponding bit returns a zero and is ignored on write.  If a register is implemented, access to that register is enabled if the corresponding bit in this field is a 1 and disabled if the corresponding bit is a 0.'), Field('Mask', Bits(29, 0), 'Each bit in this field enables access by the RDHWR instruction to a particular hardware register (which may not be an actual register).')], 'I6[45]00.*,P6600.*': [Field('Impl', Bits(31, 30), 'These bits control access to implementation-dependent hardware registers.     These registers are not currently implemented in any P6600     family processor. Attempts to access these bits results in a Reserved     Instruction Exception.'), Field('UL', Bits(29), 'UserLocal register present. This register provides read access to the     coprocessor 0 UserLocal register. Set this bit to 1 to permit user programs     to obtain the value of the UserLocal CP0 register using     rdhwr 29.'), Field('XNP', Bits(5), 'Indicates support for Release 6 Double-Width LLX/SCX family of     instructions. If set to 1, then LLX/SCX family of instructions is not     present, otherwise present in the implementation.     See Config5.XNP'), Field('PerfCnt', Bits(4), 'Performance Counter Pair. Even sel selects the Control register,     while odd sel selects the Counter register in the pair.'), Field('CCRes', Bits(3), 'Resolution of the Count register. This value denotes the number of     cycles between updates of the Count register. Setting this bit allows     selected instructions to read the Count register. For example, if this     bit is set, the execution of a user-mode rdhwr 3 instruction read the     interval at which the Count register increments. This field is encoded     as follows:${p}     0: Count register increments every cycle${nl}     1: Count register increments every second cycle${nl}     2: Count register increments every third cycle${nl}     etc.'), Field('CC', Bits(2), 'Count register present. This register provides read access to the     coprocessor 0 Count Register. Set this bit to 1 so a user-mode     rdhwr 2 can read out the value of the Count register.'), Field('SYNCI_Step', Bits(1), u'L1 cache line size. Setting this bit allows hardware to read the line     size of the L1 cache. This field is used in conjunction synci     instruction. See that instruction\u2019s description for the use of this value.     In the typical implementation, this value should be zero if there are     no caches in the system that must be synchronized (either because     there are no caches, or because the instruction cache tracks writes to     the data cache). In other cases, the return value should be the smallest     line size of the caches that must be synchronized.     For the P6600 core, the SYNCI_Step value is 32 since the line size is     32 bytes.${p}     Set this bit to 1 so that a user-mode rdhwr 1 can read the cache     line size (actually, the smaller of the L1 I-cache line size and D-cache     line size). That line size determines the step between successive uses     of the synci instruction, which does the cache manipulation necessary     to ensure that the CPU can correctly execute the instructions.'), Field('CPUNum', Bits(0), 'This register provides read access to the coprocessor 0     EBaseCPUNum field. Set this bit 1 so a user-mode rdhwr 0 reads     out the CPU ID number.')], 'proAptiv.*,P5600.*,interAptiv.*': [Field('Impl', Bits(31, 30), 'These bits control access to implementation-dependent hardware registers.  These registers are not currently implemented.  Attempts to access these bits results in a Reserved Instruction Exception.'), Field('UL', Bits(29), 'UserLocal register present.  This register provides read access to the coprocessor 0 UserLocal register.  Set this bit to 1 to permit user programs to obtain the value of the UserLocal CP0 register using rdhwr 29.'), Field('0', Bits(28, 4), 'Ignored on write; returns zero on read.'), Field('CCRes', Bits(3), 'Resolution of the Count register.  This value denotes the number of cycles between updates of the Count register.  Setting this bit allows selected instructions to read the Count register.  For example, if this bit is set, the execution of a user-mode rdhwr 3 instruction read the interval at which the Count register increments'), Field('CC', Bits(2), 'Count register present.  This register provides read access to the coprocessor 0 Count Register.  Set this bit to 1 so a user-mode rdhwr 2 can read out the value of the Count register.'), Field('SYNCI_Step', Bits(1), "L1 cache line size.  Setting this bit allows hardware to read the line size of the L1 cache.  This field is used in conjunction synci instruction.  See that instruction's description for the use of this value.\\n\\nIn the typical implementation, this value should be zero if there are no caches in the system that must be synchronized (either because there are no caches, or because the instruction cache tracks writes to the data cache).  In other cases, the return value should be the smallest line size of the caches that must be synchronized.\\n\\nFor this core, the SYNCI_Step value is 32 since the line size is 32 bytes.\\n\\nSet this bit to 1 so that a user-mode rdhwr 1 can read the cache line size (actually, the smaller of the L1 I-cache line size and D-cache line size).  That line size determines the step between successive uses of the synci instruction, which does the cache manipulation necessary to ensure that the CPU can correctly execute the instructions."), Field('CPUNum', Bits(0), 'This register provides read access to the coprocessor 0 EBase[CPUNum] field.  Set this bit 1 so a user-mode rdhwr 0 reads out the CPU ID number.')], 'M51[05]0': [Field('0', Bits(31, 30), 'Ignored on write; returns zero on read.'), Field('ULR', Bits(29), 'User Local Register present.  This register provides read access to the coprocessor 0 UserLocal register.  Set this bit to 1 to permit user programs to obtain the value of the UserLocal CP0 register using rdhwr 29.'), Field('0', Bits(28, 4), 'Ignored on write; returns zero on read.'), Field('Mask', Bits(3, 0), 'Each bit in this field enables access by the RDHWR instruction to a particular hardware register (which may not be an actual register).')]}, 'The HWREna register contains a bit mask that determines which hardware registers are accessible via the rdhwr    instruction when that instruction is executed in user mode.${p}    The low-order four bits [3:0] control access to the four registers required by the architecture standard. The    two high-order bits [31:30] are available for implementation-dependent use.${p}    Using the HWREna register, privileged software may select which of the hardware registers are accessible via the    RDHWR instruction. In doing so, a register may be virtualized at the cost of handling a Reserved Instruction Exception,    interpreting the instruction, and returning the virtualized value. For example, if it is not desirable to provide    direct access to the Count register, access to that register may be individually disabled and the return value can be virtualized    by the operating system.${p}    Software may determine which registers are implemented by writing all ones to the HWREna register, then reading    the value back. If a bit reads back as a one, the processor implements that hardware register.${p}    The whole register is cleared to zero on reset,     so that no hardware register is accessible without positive OS clearance.', [], 32, Op('gte', Reg('Config::AR'), 1)),
         Register('UserTraceData2', 'cp0.24.3', '', {'': [Field('DATA', Bits(31, 0), 'Software readable/writable data.  When written, this triggers a user format trace record out of the trace interface that transmits the Data field to trace memory.')]}, 'A software write to any bits in the UserTraceData1 or UserTraceData2 registers will trigger a trace record to be written indicating a type 1 or type 2 user format respectively.  The trace output data is UNPREDICTABLE if these registers are written in consecutive cycles.', [], 32, Or(And(Op('==', Condition('PDtrace'), True), Op('gte', Reg('TCBConfig::REV'), 3)), And(Op('==', Condition('IFlowtrace'), True), Or(Op('==', Condition('IF_Ver3'), True), Op('==', Condition('IF_Ver2'), True))))),
         Register('UserTraceData1', 'cp0.23.3', '', {'': [Field('DATA', Bits(31, 0), 'Software readable/writable data.  When written, this triggers a user format trace record out of the trace interface that transmits the Data field to trace memory.')]}, 'A software write to any bits in the UserTraceData1 or UserTraceData2 registers will trigger a trace record to be written indicating a type 1 or type 2 user format respectively.  The trace output data is UNPREDICTABLE if these registers are written in consecutive cycles.', [], 32, Or(Op('==', Condition('PDtrace'), True), And(Op('==', Condition('IFlowtrace'), True), Or(Op('==', Condition('IF_Ver3'), True), Op('==', Condition('IF_Ver2'), True))))),
         Register('TraceIBPC', 'cp0.23.4', '', {'': [Field('0', Bits(31, 30), 'Reserved.  Must be written as zero; returns zero on read.'), Field('PCT', Bits(29), 'Used to specify whether a performance counter trigger signal is generated when an EJTAG instruction breakpoint match occurs.', [Value('Disabled', 0), Value('Enabled', 1)]), Field('IE', Bits(28), 'Used to specify whether or not the trigger signal from EJTAG instruction breakpoint should trigger tracing function.', [Value('Disabled', 0), Value('Enabled', 1)]), Field('IBPC3', Bits(11, 9), 'Trace/Arm control for breakpoint #3.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6)]), Field('IBPC2', Bits(8, 6), 'Trace/Arm control for breakpoint #2.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6)]), Field('IBPC1', Bits(5, 3), 'Trace/Arm control for breakpoint #1.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6)]), Field('IBPC0', Bits(2, 0), 'Trace/Arm control for breakpoint #0.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6)])], 'proAptiv.*,P5600.*,interAptiv.*': [Field('0', Bits(31, 30), 'Reserved.  Must be written as zero; returns zero on read.'), Field('PCT', Bits(29), 'Used to specify whether a performance counter trigger signal is generated when an EJTAG instruction breakpoint match occurs.', [Value('Disabled', 0), Value('Enabled', 1)]), Field('IE', Bits(28), 'Used to specify whether or not the trigger signal from EJTAG instruction breakpoint should trigger tracing function.', [Value('Disabled', 0), Value('Enabled', 1)]), Field('0', Bits(27, 12), 'Reserved.  Must be written as zero; returns zero on read.'), Field('IBPC3', Bits(11, 9), 'Trace/Arm control for breakpoint #3.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Start core and CM', 3), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6), Value('Trace Start core and CM and dump full performance counts', 7)]), Field('IBPC2', Bits(8, 6), 'Trace/Arm control for breakpoint #2.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Start core and CM', 3), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6), Value('Trace Start core and CM and dump full performance counts', 7)]), Field('IBPC1', Bits(5, 3), 'Trace/Arm control for breakpoint #1.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Start core and CM', 3), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6), Value('Trace Start core and CM and dump full performance counts', 7)]), Field('IBPC0', Bits(2, 0), 'Trace/Arm control for breakpoint #0.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Start core and CM', 3), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6), Value('Trace Start core and CM and dump full performance counts', 7)])]}, 'The TraceIBPC register is used to control start and stop of tracing using an EJTAG Instruction Hardware breakpoint.  The Instruction Hardware breakpoint would then be set as a trigger source and optionally also as a Debug exception breakpoint.', [], 32, And(Op('==', Condition('Trace_BPCProcessor'), False), Op('==', Condition('PDtrace'), True), Op('==', Reg('DCR::InstBrk'), True))),
         Register('TraceDBPC', 'cp0.23.5', '', {'': [Field('0', Bits(31, 30), 'Reserved.  Must be written as zero; returns zero on read.'), Field('PCT', Bits(29), 'Used to specify whether a performance counter trigger signal is generated when an EJTAG data breakpoint match occurs.', [Value('Disabled', 0), Value('Enabled', 1)]), Field('DE', Bits(28), 'Used to specify whether the trigger signal from EJTAG data breakpoint should trigger tracing functions.', [Value('Disabled', 0), Value('Enabled', 1)]), Field('0', Bits(27, 12), 'Reserved.  Must be written as zero; returns zero on read.'), Field('DBPC3', Bits(11, 9), 'Trace/Arm control for breakpoint #3.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6)]), Field('DBPC2', Bits(8, 6), 'Trace/Arm control for breakpoint #2.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6)]), Field('DBPC1', Bits(5, 3), 'Trace/Arm control for breakpoint #1.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6)]), Field('DBPC0', Bits(2, 0), 'Trace/Arm control for breakpoint #0.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6)])], 'proAptiv.*,P5600.*,interAptiv.*': [Field('0', Bits(31, 30), 'Reserved.  Must be written as zero; returns zero on read.'), Field('PCT', Bits(29), 'Used to specify whether a performance counter trigger signal is generated when an EJTAG data breakpoint match occurs.', [Value('Disabled', 0), Value('Enabled', 1)]), Field('DE', Bits(28), 'Used to specify whether the trigger signal from EJTAG data breakpoint should trigger tracing functions.', [Value('Disabled', 0), Value('Enabled', 1)]), Field('0', Bits(27, 6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('DBPC1', Bits(5, 3), 'Trace/Arm control for breakpoint #1.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Start core and CM', 3), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6), Value('Trace Start core and CM and dump full performance counts', 7)]), Field('DBPC0', Bits(2, 0), 'Trace/Arm control for breakpoint #0.', [Value('Trace Stop', 0), Value('Trace Start', 1), Value('None', 2), Value('Trace Start core and CM', 3), Value('Trace Stop and dump full performance counts', 4), Value('Trace Start and dump full performance counts', 5), Value('Not used', 6), Value('Trace Start core and CM and dump full performance counts', 7)])]}, 'The TraceDBPC register is used to control start and stop of tracing using an EJTAG Data Hardware breakpoint.  The Data Hardware breakpoint would then be set as a trigger source and optionally also as a Debug exception breakpoint.', [], 32, And(Op('==', Condition('Trace_BPCProcessor'), False), Op('==', Condition('PDtrace'), True), Op('==', Reg('DCR::DataBrk'), True))),
         Register('TraceControl3', 'cp0.24.2', '', {'': [Field('0', Bits(31, 14), 'Reserved.  Must be written as zeros; returns zeros on reads.'), Field('PeCOvf', Bits(13), 'Performance counter overflow.  Setting this bit enables the trace control logic to trace a performance counter overflow.'), Field('PeCFCR', Bits(12), 'Performance counter function/call return.  Setting this bit enables the trace control logic to trace a function call/return condition or an exception handler entry.'), Field('PeCBP', Bits(11), 'Performance counter hardware breakpoint.  Setting this bit enables the trace control logic to trace a hardware breakpoint condition.'), Field('PeCSync', Bits(10), 'Performance counter synchronization counter expiration.  Setting this bit enables the trace control logic to trace a synchronization counter expiration condition.'), Field('PeCE', Bits(9), 'Performance counter tracing enable.  When set to 0, the tracing out of performance counter values as specified is disabled.  To enable, this bit must be set to 1.  This bit is used under software control.  When trace is controlled by an external probe, this enabling is done via TraceControl3[PeCE].'), Field('PeC', Bits(8), 'Specifies whether or not Performance Control Tracing is implemented.  This is an optional feature that may be omitted by implementation choice.  Implemented when set to 1.'), Field('0', Bits(7, 3), 'Reserved.  Must be written as zeros; returns zeros on reads.'), Field('TrILDE', Bits(2), 'Trace Unit Idle.  This bit indicates if the trace hardware is currently idle (not processing any data).  This can be useful when switching control of trace from hardware to software and vice versa.  The bit is read-only and updated by the trace hardware.'), Field('TRPAD', Bits(1), 'Trace RAM Access Disable.  Disables program software access to the on-chip trace RAM using load/store instructions.  This bit is loaded from TCBCONTROLB[TRPAD].'), Field('FDT', Bits(0), 'Filtered Data Trace Mode Enable.  When the bit is 0, this mode is disabled.  When set to 1, this mode is enabled.', [Value('Filtered data trace mode is disabled', 0), Value('Filtered data trace mode is enabled', 1)])], 'P5600.*': [Field('0', Bits(31, 30), 'Reserved.  Must be written as zeros; returns zeros on reads.'), Field('UPR', Bits(29), 'Indicates that for 128 bit load/ stores (MSA , if tracing of 128 bit MSA ld/st is not implemented (see bit TraceControl3.MSA) and bonded 2x64) only the lower 64 bits are traced.'), Field('0', Bits(28), 'Reserved.  Must be written as zeros; returns zeros on reads.'), Field('MSA', Bits(27), '128 bit MSA load/store data trace not implemented (see the UPR bit 29).'), Field('0', Bits(26, 14), 'Reserved.  Must be written as zeros; returns zeros on reads.'), Field('PeCOvf', Bits(13), 'Performance counter overflow.  Setting this bit enables the trace control logic to trace a performance counter overflow.'), Field('PeCFCR', Bits(12), 'Performance counter function/call return.  Setting this bit enables the trace control logic to trace a function call/return condition or an exception handler entry.'), Field('PeCBP', Bits(11), 'Performance counter hardware breakpoint.  Setting this bit enables the trace control logic to trace a hardware breakpoint condition.'), Field('PeCSync', Bits(10), 'Performance counter synchronization counter expiration.  Setting this bit enables the trace control logic to trace a synchronization counter expiration condition.'), Field('PeCE', Bits(9), 'Performance counter tracing enable.  When set to 0, the tracing out of performance counter values as specified is disabled.  To enable, this bit must be set to 1.  This bit is used under software control.  When trace is controlled by an external probe, this enabling is done via TraceControl3[PeCE].'), Field('PeC', Bits(8), 'Specifies whether or not Performance Control Tracing is implemented.  This is an optional feature that may be omitted by implementation choice.  Implemented when set to 1.'), Field('0', Bits(7, 3), 'Reserved.  Must be written as zeros; returns zeros on reads.'), Field('TrILDE', Bits(2), 'Trace Unit Idle.  This bit indicates if the trace hardware is currently idle (not processing any data).  This can be useful when switching control of trace from hardware to software and vice versa.  The bit is read-only and updated by the trace hardware.'), Field('TRPAD', Bits(1), 'Trace RAM Access Disable.  Disables program software access to the on-chip trace RAM using load/store instructions.  This bit is loaded from TCBCONTROLB[TRPAD].'), Field('FDT', Bits(0), 'Filtered Data Trace Mode Enable.  When the bit is 0, this mode is disabled.  When set to 1, this mode is enabled.', [Value('Filtered data trace mode is disabled', 0), Value('Filtered data trace mode is enabled', 1)])]}, 'The TraceControl3 register provides additional control and status information.', [], 32, And(Op('==', Condition('PDtrace'), True), Op('==', Condition('oci64_present'), False), Op('gte', Reg('TCBConfig::REV'), 3))),
         Register('TraceControl2', 'cp0.23.2', '', {'': [Field('CPUIdV', Bits(29), 'Only implemented on a processor with MT or multi-core      SOC. Otherwise, this field must be written as zero and      returns zero on reads. When set, the CPUId field specifies      the number of the VPE or CPU that must be traced.      Otherwise, instructions from all VPEs are traced when      other conditions for tracing are valid. On an MT system,      this bit is ignored if TCV is set.'), Field('CPUId', Bits(28, 21), 'Only implemented on a processor with MT or multi-core      SOC. Otherwise, this field must be written as zero;      returns zero on reads. On an MT core, specifies the number      of the VPE to trace when CPUIdV is set. On a multicore      system, this is the Ebase.CPUId value. On an MT      system, this bit is ignored if TCV is set.'), Field('TCV', Bits(20), 'Only implemented on a processor with MT. Otherwise,      this field must be written as zero and returns zero on      reads. When set, the TCNum field specifies the number      of the TC that must be traced. Otherwise, instructions      from all TCs are traced when other conditions for tracing      are valid.'), Field('TCNum', Bits(19, 12), 'Only implemented on a processor with MT. Otherwise,      this field must be written as zero; returns zero on read.      Specifies the number of the TC to trace when TCV is set.      For any given MT implementation, only the appropriate      number of bits encoding the TC number are used in the      right-most position of this field; the upper bits are      ignored.'), Field('Mode', Bits(11, 7), 'These 5 bits provide the trace mode values.      It is optional for an implementation to allow PC tracing      to be turned off. This must be clearly documented by the      core implementation-specific document. When it is      optional, bit 11 is tied to a value of 1 and setting bit 11 to      0 is simply ignored by the processor. Reading this bit      always returns a value of one.${p}      ${tab}BIT${tab}Trace The Following${nl}      ${tab}---${tab}-------------------${nl}      ${tab}0${tab}${tab}PC${nl}      ${tab}1${tab}${tab}Load Address${nl}      ${tab}2${tab}${tab}Store Address${nl}      ${tab}3${tab}${tab}Load Data${nl}      ${tab}4${tab}${tab}Store Data$'), Field('Valid-Modes', Bits(6, 5), 'What can this CPU trace? (bit-map).', [Value('PC tracing only', 0), Value('PC and load and store address tracing only', 1), Value('PC, load and store address, and load and store data', 2), Value('PC, load and store address, and load and store data', 3, '', True)]), Field('TBI', Bits(4), 'This bit indicates how many trace buffers are implemented      by the TCB, as follows:${p}      ${tab}0${tab}Only one trace buffer is implemented, and the TBU bit of this register indicates${nl}      ${tab}${tab}which trace buffer is implemented${p}      ${tab}1${tab}Both on-chip and off-chip trace buffers are implemented by the TCB, and the${nl}      ${tab}${tab}TBU bit of this register indicates to which trace buffer the traces is currently${nl}      ${tab}${tab}written.${p}      This bit is loaded when the TCBCONTROLB[OfC] bit is set.', [Value('Only one trace buffer is implemented', 0), Value('Both on-chip and off-chip trace buffers are implemented', 1)]), Field('TBU', Bits(3), 'This bit denotes to which trace buffer the trace is currently       being written and is used to select the appropriate interpretation       of the TraceControl2[SyP] field.${p}      This bit is loaded from the TCBCONTROLB[OfC]${p}      ${tab}0${tab}Trace data is being sent to an on-chip trace buffer${nl}      ${tab}1${tab}Trace Data is being sent to an off-chip trace buffer${nl}', [Value('Trace data is being sent to an on-chip trace buffer', 0), Value('Trace Data is being sent to an off-chip trace buffer', 1)]), Field('SyP', Bits(2, 0), 'The period (in cycles) to which the internal synchronization      counter is reset when tracing is started or when the      synchronization counter has overflowed.${p}      This field is loaded from the TCBCONTROLB[SyP] bits.', [Value('2**5', 0), Value('2**6', 1), Value('2**7', 2), Value('2**8', 3), Value('2**9', 4), Value('2**10', 5), Value('2**11', 6), Value('2**12', 7)])], 'M51[05]0': [Field('Valid-Modes', Bits(6, 5), 'What can this CPU trace? (bit-map).', [Value('PC tracing only', 0), Value('PC and load and store address tracing only', 1), Value('PC, load and store address, and load and store data', 2), Value('PC, load and store address, and load and store data', 3, '', True)]), Field('TBI', Bits(4), 'This bit indicates how many trace buffers are implemented      by the TCB, as follows:${p}      ${tab}0${tab}Only one trace buffer is implemented, and the TBU bit of this register indicates${nl}      ${tab}${tab}which trace buffer is implemented${p}      ${tab}1${tab}Both on-chip and off-chip trace buffers are implemented by the TCB, and the${nl}      ${tab}${tab}TBU bit of this register indicates to which trace buffer the traces is currently${nl}      ${tab}${tab}written.${p}      This bit is loaded when the TCBCONTROLB[OfC] bit is set.', [Value('Only one trace buffer is implemented', 0), Value('Both on-chip and off-chip trace buffers are implemented', 1)]), Field('TBU', Bits(3), 'This bit denotes to which trace buffer the trace is currently       being written and is used to select the appropriate interpretation       of the TraceControl2[SyP] field.${p}      This bit is loaded from the TCBCONTROLB[OfC]${p}      ${tab}0${tab}Trace data is being sent to an on-chip trace buffer${nl}      ${tab}1${tab}Trace Data is being sent to an off-chip trace buffer${nl}', [Value('Trace data is being sent to an on-chip trace buffer', 0), Value('Trace Data is being sent to an off-chip trace buffer', 1)]), Field('SyP', Bits(2, 0), 'The period (in cycles) between which the periodic synchronization           information is to be sent is defined for both                  when the trace buffer is on-chip and off-chip.', [Value('2**7', 0), Value('2**8', 1), Value('2**9', 2), Value('2**10', 3), Value('2**11', 4), Value('2**12', 5), Value('2**13', 6), Value('2**14', 7)])], 'proAptiv.*,P5600.*': [Field('SyPExt', Bits(31, 30), 'This field is optional for PDtrace revisions 06.00 and      higher and preset to 0 for earlier revisions. This is used      to optionally extend the length of the synchronization      period field SyP (bits 2:0) in this register. The value of      SyP is extended by assuming that these two bits are juxtaposed      to the left of the three bits of SyP (SyPExt.SyP).      When only SyP was used to specify the synchronization      period, the value was 2x, where x was computed from      SyP by adding 5 to the actual value represented by the      bits. A similar formula applied to the 5 bits just obtained      by the juxtaposition of SyPExt and SyP. Sync period values      greater than 2^31 are UNPREDICTABLE. Since the      value of 11010 represents the value of 31 (with +5), all      values greater than 11010 are UNPREDICTABLE.      Note that with these new bits, a sync period range of 25      to 2^31 cycles can now be obtained.'), Field('CPUIdV', Bits(29), 'Only implemented on a processor with MT or multi-core      SOC. Otherwise, this field must be written as zero and      returns zero on reads. When set, the CPUId field specifies      the number of the VPE or CPU that must be traced.      Otherwise, instructions from all VPEs are traced when      other conditions for tracing are valid. On an MT system,      this bit is ignored if TCV is set.'), Field('CPUId', Bits(28, 21), 'Only implemented on a processor with MT or multi-core      SOC. Otherwise, this field must be written as zero;      returns zero on reads. On an MT core, specifies the number      of the VPE to trace when CPUIdV is set. On a multicore      system, this is the Ebase.CPUId value. On an MT      system, this bit is ignored if TCV is set.'), Field('TCV', Bits(20), 'Only implemented on a processor with MT. Otherwise,      this field must be written as zero and returns zero on      reads. When set, the TCNum field specifies the number      of the TC that must be traced. Otherwise, instructions      from all TCs are traced when other conditions for tracing      are valid.'), Field('TCNum', Bits(19, 12), 'Only implemented on a processor with MT. Otherwise,      this field must be written as zero; returns zero on read.      Specifies the number of the TC to trace when TCV is set.      For any given MT implementation, only the appropriate      number of bits encoding the TC number are used in the      right-most position of this field; the upper bits are      ignored.'), Field('Mode', Bits(11, 7), 'These 5 bits provide the trace mode values.      It is optional for an implementation to allow PC tracing      to be turned off. This must be clearly documented by the      core implementation-specific document. When it is      optional, bit 11 is tied to a value of 1 and setting bit 11 to      0 is simply ignored by the processor. Reading this bit      always returns a value of one.${p}      ${tab}BIT${tab}Trace The Following${nl}      ${tab}---${tab}-------------------${nl}      ${tab}0${tab}${tab}PC${nl}      ${tab}1${tab}${tab}Load Address${nl}      ${tab}2${tab}${tab}Store Address${nl}      ${tab}3${tab}${tab}Load Data${nl}      ${tab}4${tab}${tab}Store Data$'), Field('Valid-Modes', Bits(6, 5), 'What can this CPU trace? (bit-map).', [Value('PC tracing only', 0), Value('PC and load and store address tracing only', 1), Value('PC, load and store address, and load and store data', 2), Value('PC, load and store address, and load and store data', 3, '', True)]), Field('TBI', Bits(4), 'This bit indicates how many trace buffers are implemented      by the TCB, as follows:${p}      ${tab}0${tab}Only one trace buffer is implemented, and the TBU bit of this register indicates${nl}      ${tab}${tab}which trace buffer is implemented${p}      ${tab}1${tab}Both on-chip and off-chip trace buffers are implemented by the TCB, and the${nl}      ${tab}${tab}TBU bit of this register indicates to which trace buffer the traces is currently${nl}      ${tab}${tab}written.${p}      This bit is loaded when the TCBCONTROLB[OfC] bit is set.', [Value('Only one trace buffer is implemented', 0), Value('Both on-chip and off-chip trace buffers are implemented', 1)]), Field('TBU', Bits(3), 'This bit denotes to which trace buffer the trace is currently       being written and is used to select the appropriate interpretation       of the TraceControl2[SyP] field.${p}      This bit is loaded from the TCBCONTROLB[OfC]${p}      ${tab}0${tab}Trace data is being sent to an on-chip trace buffer${nl}      ${tab}1${tab}Trace Data is being sent to an off-chip trace buffer${nl}', [Value('Trace data is being sent to an on-chip trace buffer', 0), Value('Trace Data is being sent to an off-chip trace buffer', 1)]), Field('SyP', Bits(2, 0), 'The period (in cycles) to which the internal synchronization      counter is reset when tracing is started or when the      synchronization counter has overflowed.${p}      This field is loaded from the TCBCONTROLB[SyP] bits.', [Value('2**5', 0), Value('2**6', 1), Value('2**7', 2), Value('2**8', 3), Value('2**9', 4), Value('2**10', 5), Value('2**11', 6), Value('2**12', 7)])]}, 'The TraceControl2 register provides additional control and status information.', [], 32, Op('==', Condition('PDtrace'), True)),
         Register('TraceControl', 'cp0.23.1', '', {'': [Field('TS', Bits(31), 'The trace select bit is used to select between the hardware and the software trace control bits.  A value of zero selects the external hardware trace block signals, and a value of one selects the trace control bits in the TraceControl register.'), Field('UT', Bits(30), 'This bit is used to indicate the type of user-triggered trace record.  A value of zero implies a user type 1 and a value of one implies a user type 2.\\n\\nThe actual triggering of a user trace record happens on a write to the UserTraceData register.  This is a 32-bit register for 32-bit processors and a 64-bit register for 64-bit processors.'), Field('TB', Bits(27), 'Trace All Branch.  When set to 1, this tells the processor to trace the PC value for all taken branches, not just the ones whose branch target address is statically unpredictable.'), Field('IO', Bits(26), 'Inhibit Overflow.  This signal is used to indicate to the core trace logic that slow but complete tracing is desired.  Hence, the core tracing logic must not allow a FIFO overflow and discard trace data.  This is achieved by stalling the pipeline when the FIFO is nearly full, so that no trace records are ever lost.'), Field('D', Bits(25), 'When set to one, this enables tracing in Debug Mode.  For trace to be enabled in Debug mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in Debug Mode, irrespective of other bits.'), Field('E', Bits(24), 'When set to one, this enables tracing in Exception Mode.  For trace to be enabled in Exception mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in Exception Mode, irrespective of other bits.'), Field('K', Bits(23), 'When set to one, this enables tracing in Kernel Mode.  For trace to be enabled in Kernel mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in Kernel Mode, irrespective of other bits.'), Field('S', Bits(22), 'When set to one, this enables tracing in Supervisor Mode. For trace to be enabled in Supervisor mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in Supervisor Mode, irrespective of other bits.  If the processor does not implement Supervisor Mode, this bit is ignored on write and returns zero on read.'), Field('U', Bits(21), 'When set to one, this enables tracing in User Mode.  For trace to be enabled in User mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in User Mode, irrespective of other bits.'), Field('ASID_M', Bits(20, 13), 'This is a mask value applied to the ASID comparison (done when the G bit is zero).  A 1 in any bit in this field inhibits the corresponding ASID bit from participating in the match.  As such, a value of zero in this field compares all bits of ASID.  Note that the ability to mask the ASID value is not available in the hardware signal bit; it is only available via the software control register.  If the processor does not implement the standard TLB-based MMU, this field is ignored on write and returns zero on read.'), Field('ASID', Bits(12, 5), 'The ASID field to match when the G bit is zero.  When the G bit is one, this field is ignored.  If the processor does not implement the standard TLB-based MMU, this field is ignored on write and returns zero on read.'), Field('G', Bits(4), 'When set, this implies that tracing is to be enabled for all processes, provided that other enabling functions (like U, S, etc.,) are also true.  If the processor does not implement the standard TLB-based MMU, this field is ignored on write and returns 1 on read.  This causes all match equations to work correctly in the absence of an ASID.'), Field('TFCR', Bits(3), 'When asserted, used to trace function call and return instructions with full PC values.'), Field('TLSM', Bits(2), 'When asserted, used to trace data cache load and store misses with full PC values, and potentially the data address and value as well.'), Field('TIM', Bits(1), 'When asserted, used to trace instruction miss with full PC values.'), Field('On', Bits(0), 'This is the master trace enable switch in software control.  When zero, tracing is always disabled.  When set to one, tracing is enabled whenever the other enabling functions are also true.')], 'M51[05]0': [Field('TS', Bits(31), 'The trace select bit is used to select between the hardware and the software trace control bits.  A value of zero selects the external hardware trace block signals, and a value of one selects the trace control bits in the TraceControl register.'), Field('UT', Bits(30), 'This bit is used to indicate the type of user-triggered trace record.  A value of zero implies a user type 1 and a value of one implies a user type 2.\\n\\nThe actual triggering of a user trace record happens on a write to the UserTraceData register.  This is a 32-bit register for 32-bit processors and a 64-bit register for 64-bit processors.'), Field('TB', Bits(27), 'Trace All Branch.  When set to 1, this tells the processor to trace the PC value for all taken branches, not just the ones whose branch target address is statically unpredictable.'), Field('IO', Bits(26), 'Inhibit Overflow.  This signal is used to indicate to the core trace logic that slow but complete tracing is desired.  Hence, the core tracing logic must not allow a FIFO overflow and discard trace data.  This is achieved by stalling the pipeline when the FIFO is nearly full, so that no trace records are ever lost.'), Field('D', Bits(25), 'When set to one, this enables tracing in Debug Mode.  For trace to be enabled in Debug mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in Debug Mode, irrespective of other bits.'), Field('E', Bits(24), 'When set to one, this enables tracing in Exception Mode.  For trace to be enabled in Exception mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in Exception Mode, irrespective of other bits.'), Field('K', Bits(23), 'When set to one, this enables tracing in Kernel Mode.  For trace to be enabled in Kernel mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in Kernel Mode, irrespective of other bits.'), Field('S', Bits(22), 'When set to one, this enables tracing in Supervisor Mode. For trace to be enabled in Supervisor mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in Supervisor Mode, irrespective of other bits.  If the processor does not implement Supervisor Mode, this bit is ignored on write and returns zero on read.'), Field('U', Bits(21), 'When set to one, this enables tracing in User Mode.  For trace to be enabled in User mode, the On bit must be one, and either the G bit must be one, or the current process ASID must match the ASID field in this register.  When set to zero, trace is disabled in User Mode, irrespective of other bits.'), Field('ASID_M', Bits(20, 13), 'This is a mask value applied to the ASID comparison (done when the G bit is zero).  A 1 in any bit in this field inhibits the corresponding ASID bit from participating in the match.  As such, a value of zero in this field compares all bits of ASID.  Note that the ability to mask the ASID value is not available in the hardware signal bit; it is only available via the software control register.  If the processor does not implement the standard TLB-based MMU, this field is ignored on write and returns zero on read.'), Field('ASID', Bits(12, 5), 'The ASID field to match when the G bit is zero.  When the G bit is one, this field is ignored.  If the processor does not implement the standard TLB-based MMU, this field is ignored on write and returns zero on read.'), Field('G', Bits(4), 'When set, this implies that tracing is to be enabled for all processes, provided that other enabling functions (like U, S, etc.,) are also true.  If the processor does not implement the standard TLB-based MMU, this field is ignored on write and returns 1 on read.  This causes all match equations to work correctly in the absence of an ASID.'), Field('Mode', Bits(3, 1), 'When asserted, used to trace function call and return instructions with full PC values.'), Field('On', Bits(0), 'This is the master trace enable switch in software control.  When zero, tracing is always disabled.  When set to one, tracing is enabled whenever the other enabling functions are also true.')], 'proAptiv.*,P5600.*': [Field('TS', Bits(31), 'The trace select bit is used to select between the hardware and the      software trace control bits. A value of zero selects the external hardware      trace block signals, and a value of one selects the trace control      bits in the TraceControl register.'), Field('UT', Bits(30), 'This bit is deprecated since there are now two explicit trace registers,      UserTraceData1 and UserTraceData2. Previously this bit      indicated the type of user-triggered trace record. A value of zero      implies a user type 1, and a value of one implies a user type 2. The      actual triggering of a user trace record happens on a write to the      UserTraceData register.'), Field('0', Bits(29), 'Reserved.  Must be written as zero; returns zero on read.'), Field('Ineff', Bits(28), "When set to 1, core-specific inefficiency tracing is enabled, and      core-specific trace information is included in the trace stream. The      inefficiency code replaces an 'NI' and is interpreted in the trace      stream with an expanded InsComp (Instruction Completion Indicator).      The InsComp is expanded from 3b to 4b for all trace formats."), Field('TB', Bits(27), 'Trace All Branch. When set to 1, this tells the processor to trace the      PC value for all branches taken, not just the ones whose branch target      address is statically unpredictable.'), Field('IO', Bits(26), 'Inhibit Overflow. This signal is used to indicate to the proAptiv.*      Multiprocessing System trace logic that slow but complete tracing is      desired. Hence, the proAptiv.*Multiprocessing System tracing logic      must not allow a FIFO overflow and discard trace data. This is      achieved by stalling the pipeline when the FIFO is nearly full, so      that no trace records are ever lost.'), Field('D', Bits(25), 'Debug mode. When set to one, this enables tracing in debug mode.      For a trace to be enabled in Debug mode, the On bit must also be      set, and either the G bit must be set, or the current process ASID      must match the ASID field in this register.${nl}      When set to zero, trace is disabled in debug mode.'), Field('E', Bits(24), 'Exception mode. When set to one, tracing is enabled in Exception      mode. For a trace to be enabled in Exception mode, the On bit must      be set, and either the G bit must be set, or the current process ASID      must match the ASID field in this register.${nl}      When set to zero, trace is disabled in Exception Mode.'), Field('K', Bits(23), 'Kernel mode. When set to one, enables tracing in Kernel mode. For      a trace to be enabled in Kernel mode, the On bit must be set, and      either the G bit must be set, or the current process ASID must match      the ASID field in this register.${nl}      When set to zero, trace is disabled in Kernel Mode.'), Field('S', Bits(22), 'Supervisor mode. When set to one, tracing is enabled in Supervisor      Mode. For a trace to be enabled in Supervisor mode, the On bit must      be set, and either the G bit must be set, or the current process ASID      must match the ASID field in this register.${nl}      When set to zero, trace is disabled in Supervisor Mode, regardless of      other bits.${nl}      If the processor does not implement Supervisor Mode, this bit is      ignored on write and returns zero on read.'), Field('U', Bits(21), 'User mode. When set to one, tracing is enabled in User mode. For a      trace to be enabled in User mode, the On bit must be set, and either      the G bit must be set, or the current process ASID must match the      ASID field in this register.${nl}      When set to zero, trace is disabled in User Mode, regardless of the      setting of other bits.'), Field('ASID_M', Bits(20, 13), u'ASID mask. This is a mask value applied to the ASID comparison      (done when the G bit is zero). A \u201c1\u201d in any bit in this field inhibits      the corresponding ASID bit from participating in the match. As      such, a value of zero in this field compares all bits of ASID.      Note that the ability to mask the ASID value is not available in the      hardware signal bit; it is only available via the software control register.'), Field('ASID', Bits(12, 5), 'Address space identifier. This field stores the ASID field to match      when the G bit is zero. When the G bit is one, this field is ignored.'), Field('G', Bits(4), 'Global enable. When set, tracing is to be enabled for all processes,      provided that other enabling functions (like U, S, etc.,) are also true.'), Field('TFCR', Bits(3), 'When set, indicates to the PDtrace interface that the optional Fcr bit      must be traced in the appropriate trace formats. If PC tracing is disabled,      the full PC of the function call (or return) instruction must      also be traced. Note that function call/return information is only      traced if tracing is actually enabled for the current mode.'), Field('TLSM', Bits(2), 'Load/Store Miss trace. When set, this indicates to the PDtrace interface      that information about data cache misses should be traced. If      PC, load/store address, and data tracing are disabled (see the      TraceControl2Mode field), the full PC and load/store address are      traced for data cache misses.${nl}      If load/store data tracing is enabled, the LSM bit must be traced in      the appropriate trace format. Note that data cache miss information      is only traced if tracing is actually enabled for the current mode.'), Field('TIM', Bits(1), 'Trace IM bit. When set, this indicates to the PDtrace interface that      the optional IM bit must be traced in the appropriate trace formats. If      PC tracing is disabled, the full PC of the instruction that missed in      the I-cache must be traced. Note that instruction cache miss information      is only traced if tracing is actually enabled in the current mode.'), Field('On', Bits(0), 'This is the master trace enable switch in software control. When      zero, tracing is always disabled. When set to one, tracing is enabled      whenever the other enabling functions are also true.')]}, 'Software control of Trace.', [], 32, Op('==', Condition('PDtrace'), True)),
         Register('TraceBPC', 'cp0.23.4', '', {'': [Field('DE', Bits(31), 'Used to specify whether the trigger signal from          EJTAG data breakpoint should trigger tracing functions.', [Value('Disables trigger signals from data breakpoints', 0), Value('Enables trigger signals from data breakpoints.', 1)]), Field('0', Bits(30, 18), 'Reserved.  Must be written as zero; returns zero on read.'), Field('DBPOn', Bits(17, 16), 'Each of the 2 bits corresponds to the 2 possible           EJTAG hardware data breakpoints that may be implemented.           For example, bit 16 corresponds to the first           data breakpoint. If 2 data breakpoints are present in the           EJTAG implementation, then they correspond to bits           16 and 17. The rest are always ignored by the tracing           logic because they will never be triggered.           A value of one for each bit implies that a trigger from           the corresponding data breakpoint should start tracing.           And a value of zero implies that tracing should be           turned off with the trigger signal.'), Field('IE', Bits(15), 'Used to specify whether the trigger signal from EJTAG instruction breakpoint should trigger tracing functions.', [Value('Disables trigger signals from instruction breakpoints', 0), Value('Enables trigger signals from instruction breakpoints', 1)]), Field('0', Bits(14, 6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('IBPOn', Bits(5, 0), 'Each of the 6 bits corresponds to the 6 possible          EJTAG hardware instruction breakpoints that may be          implemented. Bit 0 corresponds to the first instruction          breakpoint, and so on. If only 2 instruction breakpoints          are present in the EJTAG implementation, then only          bits 0 and 1 are used. The rest are always ignored by          the tracing logic because they will never be triggered.          A value of one for each bit implies that a trigger from          the corresponding instruction breakpoint should start          tracing. And a value of zero implies that tracing should          be turned off with the trigger signal.')]}, 'The TraceBPC register is used to control start and stop of tracing using an EJTAG Instruction Hardware breakpoint.  The Instruction Hardware breakpoint would then be set as a trigger source and optionally also as a Debug exception breakpoint.', [], 32, And(Op('==', Condition('Trace_BPCProcessor'), True), Op('==', Condition('PDtrace'), True), Op('==', Reg('DCR::DataBrk'), True))),
         Register('Wired', 'cp0.6.0', '', {'': [Field('Reserved', Bits(31, 6)), Field('Wired', Bits(5, 0), 'Sets lower bound to Random register.')], 'I6[45]00.*': [Field('Limit', Bits(19, 16), 'TLB wired limit. Wired entries are only applicable to a variable-sized. A fixed-size     TLB does not have wired entries. Attempting to write a value greater than     Limit into the Wired field causes the write to be dropped. Encoding: 0 - The maximum number      of wired entries may be equal to the number of TLB entries. Greater than 0 - Root is always 0      - but this text applies to guest'), Field('Wired', Bits(3, 0), 'Defines the number of wired dual entries in the VTLB. A value of 0 in this field     indicates that no TLB entries are hard wired. A value of 0x1F indicates that     31 VTLB entries are hard wired.')], 'P6600.*': [Field('Limit', Bits(20, 16), 'TLB wired limit. Wired entries are only applicable to a variable-sized. A fixed-size     TLB does not have wired entries. Attempting to write a value greater than     Limit into the Wired field causes the write to be dropped. Encoding: 0 - The maximum number      of wired entries may be equal to the number of TLB entries. Greater than 0 - Root is always 0      - but this text applies to guest'), Field('Wired', Bits(5, 0), 'Defines the number of wired dual entries in the VTLB. A value of 0 in this field     indicates that no TLB entries are hard wired. A value of 0x7F indicates that     127 VTLB entries are hard wired.')], 'proAptiv.*,P5600.*,interAptiv.*,M5150.*': [Field('Wired', Bits(5, 0), 'Defines the number of wired dual entries in the TLB.${nl}For 16 and 32 entry TLBs, behavior is undefined if value is set to a value larger than last TLB entry.${p}These entries become a good place for an OS to keep translations which must never cause a TLB translation-not-present exception.', [], None, 'InterAptiv.*'), Field('Wired', Bits(5, 0), 'Defines the number of wired dual entries in the VTLB.  Up to 63 of the 64 dual entries in the VTLB can be hard wired using this register.  A value of 0 in this field indicates that no VTLB entries are hard wired.  A value of 0x3F indicates that 63 of the 64 VTLB entries are hard wired.${p}These entries become a good place for an OS to keep translations which must never cause a TLB translation-not-present exception.', [], None, 'proAptiv.*'), Field('Wired', Bits(5, 0), 'Defines the number of wired dual entries in the TLB. Up to 61 of the 64 dual           entries in the VTLB can be hard wired using this register. A value of 0 in this           field indicates that no VTLB entries are hard wired. A value of 0x3D indicates           that 61 of the 64 VTLB entries are hard wired.', [], None, 'P5600'), Field('Wired', Bits(4, 0), 'TLB wired boundary.', [], None, 'M5150')]}, 'The Wired register is a read/write register that specifies the boundary between the wired and random entries in the TLB.  The width of the Wired field is calculated in the same manner as that described for the Index register above.  Wired entries are fixed, non-replaceable entries that are not overwritten by a TLBWR instruction.  Wired entries can be overwritten by a TLBWI instruction.', [], 32, Or(Op('==', Reg('Config::MT'), 1), Op('==', Reg('Config::MT'), 4))),
         Register('Random', 'cp0.1.0', '', {}, u'Random is a free counter cycling through the range of valid TLB indexes.${p}   It is used only by the tlbwr instruction when you want a quick way of replacing a    TLB entry at random.${p}   This field cycles (randomly) through the potential indices of the TLB, so its length    varies with the TLB size. It\u2019s usually a down counter, and starts off at the largest    plausibleindex.', [], 32, Or(Op('==', Reg('Config::MT'), 1), Op('==', Reg('Config::MT'), 4)), 'r'),
         Register('PWCtl', 'cp0.6.6', '', {'': [Field('PWEn', Bits(31), 'Hardware Page Table walker enable If this bit is set, then the Hardware Page Table is enabled.'), Field('0', Bits(30, 8), 'This field must be written as zero; returns zero on read.'), Field('DPH', Bits(7), 'Dual Page format of Huge Page support. This bit is only used when HugePg = 1.           ${nl}If DPH bit is set, then a Huge Page PTE can represent a power-of-4 memory           region or a 2x power-of-4 memory region. For the first case, one PTE is used           for even TLB page and the adjacent PTE is used for the odd PTE. For the latter           case, the Hardware will synthesize the physical addresses for both the even and           odd TLB pages from the single PTE entry.           ${nl}If DPH bit is clear, then a Huge Page PTE can only represent a region that is 2 x           power-of-4 in size. For this case, the Hardware will synthesize the physical           addresses for both the even and odd TLB pages from the single PTE entry.'), Field('HugePg', Bits(6), 'Huge Page PTE supported in Directory levels. If this bit is set, then Huge Page           PTE in non-leaf table (i.e., directory level) is supported.'), Field('Psn', Bits(5, 0), 'Bit position of PTEvld in Huge Page PTE. Only used when HugePg field is           set.')], 'P6600.*': [Field('PWEn', Bits(31), 'Hardware Page Table walker enable If this bit is set, then the Hardware Page Table is enabled.'), Field('PWDirExt', Bits(30), 'PW Indices - PWField and PWSize - extended for 4th directory level - the Base level.'), Field('0', Bits(29)), Field('XK', Bits(28), 'XKSEG kernel address space management. This bit is encoded as follows:{$p}     ${tab}0: xkseg misses generate a TLB miss exception. The hardware page walk is not initiated.     ${tab}1: The page table walker handles xkseg.', [Value('xkseg miss generates TLB Miss Exception', 0), Value('Page Walker Handles xkseg', 1)]), Field('XS', Bits(27), 'XSSEG supervisor address space management. This bit is encoded as follows:{$p}     ${tab}0: xsseg misses generate a TLB miss exception. The hardware page walk is not initiated.     ${tab}1: The page table walker handles xsseg.', [Value('xsseg miss generates TLB Miss Exception', 0), Value('Page Walker Handles xsseg', 1)]), Field('XU', Bits(26), 'XUSEG user address space management. This bit is encoded as follows:{$p}     ${tab}0: xuseg misses generate a TLB miss exception. The hardware page walk is not initiated.     ${tab}1: The page table walker handles xuseg.', [Value('xuseg miss generates TLB Miss Exception', 0), Value('Page Walker Handles xuseg', 1)]), Field('0', Bits(25, 8)), Field('DPH', Bits(7), 'Dual Page format of Huge Page support. This bit is only used when HugePg = 1.           ${nl}If DPH bit is set, then a Huge Page PTE can represent a power-of-4 memory           region or a 2x power-of-4 memory region. For the first case, one PTE is used           for even TLB page and the adjacent PTE is used for the odd PTE. For the latter           case, the Hardware will synthesize the physical addresses for both the even and           odd TLB pages from the single PTE entry.           ${nl}If DPH bit is clear, then a Huge Page PTE can only represent a region that is 2 x           power-of-4 in size. For this case, the Hardware will synthesize the physical           addresses for both the even and odd TLB pages from the single PTE entry.'), Field('HugePg', Bits(6), 'Huge Page PTE supported in Directory levels. If this bit is set, then Huge Page           PTE in non-leaf table (i.e., directory level) is supported.'), Field('Psn', Bits(5, 0), 'Bit position of PTEvld in Huge Page PTE. Only used when HugePg field is           set.')]}, 'The PWCtl register configures hardware page table walking for TLB refills. It is used in combination with the         PWBase, PWField and PWSize registers. Hardware page table walking is disabled when PWCtlPWEn = 0.         ${nl}The hardware page walker feature supports multi-level page tables - up to four directory levels plus one page table         level. The lowest level of any page table system is an array of Page Table Entries (PTEs). This array is known as a         Page Table (PT) and is indexed using bits from the faulting address. A single-level page table system contains only a         single Page Table.         ${nl}A multi-level page table system supports multiple levels, the lowest of which are Page Table Entries. Levels above         the lowest Page Table level are known as Directories. A directory consists of an array of pointers. Each pointer in a         directory is either to another directory or to a Page Table.         ${nl}The Page Table and the Directories are indexed by bits extracted from the faulting address BadVAddr. The PWBase         register contains the base address of the first Directory or Page Table which will be accessed. The PWSize register         specifies the number of index bits to be used for each level. The PWField register specifies the location of the index         fields in BadVAddr.', [], 32, Op('==', Reg('Config3::PW'), 1)),
         Register('PageGrain', 'cp0.5.1', '', {'': [], 'I6[45]00.*': [Field('RIE', Bits(31), 'Read inhibit enable. This bit is always 1 to indicate that the RI bit of the Entry0     and Entry1 registers is enabled.'), Field('XIE', Bits(30), 'Execute inhibit enable. This bit is always 1 to indicate that the XI bit of the     Entry0 and Entry1 registers is enabled.'), Field('ELPA', Bits(29), 'Enables support for large physical addresses. If this bit is a 1, the following changes occur to coprocessor 0 registers:${p}     ${tab}1. The PFNX field of the EntryLo0 and EntryLo1 registers is writable and concatenated     with the PFN field to form the full page frame number.${nl}     ${tab}2. Access to optional COP0 registers with PA extension, LLAddr, TagLo is     defined.${p}     If this bit is a 0 and Config3LPA=1, then writes to above registers or fields are     ignored and reads return 0.', [Value('Large physical address support is disabled.', 0), Value('Large physical address support is enabled (XPA).', 1)]), Field('ESP', Bits(28), 'This bit is always 0 as 1K pages are not supported.  This bit must be written with 0.'), Field('IEC', Bits(27), 'Enables unique exception codes for the Read-Inhibit and Execute-Inhibit exceptions.${p}     0: Read-Inhibit and Execute-Inhibit exceptions both use the TLBL exception code.${nl}     1: Read-Inhibit exceptions use the TLBRI exception code.  Execute-Inhibit exceptions use the TLBXI exception code.', [Value('Read-Inhibit and Execute-Inhibit exceptions both use the TLBL exception code', 0), Value('Read-Inhibit exceptions use the TLBRI exception code.  Execute-Inhibit exceptions use the TLBXI exception code', 1)]), Field('MCAUSE', Bits(4, 0), 'Machine Check Cause. Only valid after a Machine Check Exception. This field           indicates the cause of the machine check exception.', [Value('No Machine Check Reported.', 0), Value('Multiple Hit in TLB(s).', 1), Value('Multiple Hits in TLB(s) for speculative accesses. The value in EPC might not point to the faulting instruction.', 2), Value('For Dual VTLB and FTLB. A page with EntryHiEHINV=0 is written into FTLB and PageMask is not set to a page size that is supported by the FTLB.', 3), Value('For Dual VTLB and FTLB. A page with EntryHiEHINV=0 is written into FTLB but the VPN2 field is not consistent with the TLB set seletected by the Index register.', 4)])], 'proAptiv.*,P5600.*,interAptiv.*,M5150.*,P6600.*': [Field('RIE', Bits(31), 'Read inhibit enable.${p}0: RI bit of the Entry0 and Entry1 registers is disabled and not writeable by software.${nl}1: RI bit of the Entry0 and Entry1 registers is enabled.', [Value('RI bit of the Entry0 and Entry1 registers is disabled and not writeable by software', 0), Value('RI bit of the Entry0 and Entry1 registers is enabled', 1)]), Field('XIE', Bits(30), 'Execute inhibit enable.${p}0: XI bit of the Entry0 and Entry1 registers is disabled and not writeable by software.${nl}1: XI bit of the Entry0 and Entry1 registers is enabled.', [Value('XI bit of the Entry0 and Entry1 registers is disabled and not writeable by software', 0), Value('XI bit of the Entry0 and Entry1 registers is enabled', 1)]), Field('ELPA', Bits(29), 'Enables support for large physical addresses.', [Value('Large physical address support is disabled.', 0), Value('Large physical address support is enabled (XPA).', 1)], None, 'P5600,P6600.*'), Field('ESP', Bits(28), 'This bit is always 0 as 1K pages are not supported.  This bit must be written with 0.'), Field('IEC', Bits(27), 'Enables unique exception codes for the Read-Inhibit and Execute-Inhibit exceptions.${p}0: Read-Inhibit and Execute-Inhibit exceptions both use the TLBL exception code.${nl}1: Read-Inhibit exceptions use the TLBRI exception code.  Execute-Inhibit exceptions use the TLBXI exception code.', [Value('Read-Inhibit and Execute-Inhibit exceptions both use the TLBL exception code', 0), Value('Read-Inhibit exceptions use the TLBRI exception code.  Execute-Inhibit exceptions use the TLBXI exception code', 1)]), Field('0', Bits(26, 13), 'Ignored on write; returns zero on read.'), Field('ASE', Bits(12, 8), 'Ignored on write; returns zero on read.', [], None, 'proAptiv.*,P5600.*,interAptiv.*,P6600.*'), Field('0', Bits(7, 0), 'Ignored on write; returns zero on read.'), Field('MCAUSE', Bits(4, 0), 'Machine Check Cause. Only valid after a Machine Check Exception. This field           indicates the cause of the machine check exception.', [Value('No Machine Check Reported.', 0), Value('Multiple Hit in TLB(s).', 1), Value('Multiple Hits in TLB(s) for speculative accesses. The value in EPC might not point to the faulting instruction.', 2), Value('For Dual VTLB and FTLB. A page with EntryHiEHINV=0 is written into FTLB and PageMask is not set to a page size that is supported by the FTLB.', 3), Value('For Dual VTLB and FTLB. A page with EntryHiEHINV=0 is written into FTLB but the VPN2 field is not consistent with the TLB set seletected by the Index register.', 4), Value('For Hardware Page Table Walker and Dual Page Mode of Directory Level PTEs - first PTE accessed from memory has PTEVld bit set but second PTE accessed from memory does not have PTEVld bit set.', 5), Value('For Hardware Page Table Walker and derived Huge Page size is power-of-4 but Dual Page mode not implemented.', 6)], None, 'P5600'), Field('MCAUSE', Bits(4, 0), 'Machine Check Cause. Only valid after a Machine Check Exception. This field           indicates the cause of the machine check exception.', [Value('No Machine Check Reported.', 0), Value('Multiple Hit in TLB(s).', 1), Value('Multiple Hits in TLB(s) for speculative accesses. The value in EPC might not point to the faulting instruction.', 2), Value('For Dual VTLB and FTLB. A page with EntryHiEHINV=0 is written into FTLB and PageMask is not set to a page size that is supported by the FTLB.', 3), Value('For Dual VTLB and FTLB. A page with EntryHiEHINV=0 is written into FTLB but the VPN2 field is not consistent with the TLB set seletected by the Index register.', 4), Value('For Hardware Page Table Walker and Dual Page Mode of Directory Level PTEs - first PTE accessed from memory has PTEVld bit set but second PTE accessed from memory does not have PTEVld bit set.', 5), Value('For Hardware Page Table Walker and derived Huge Page size is power-of-4 but Dual Page mode not implemented.', 6)], None, 'P6600.*')]}, 'Page Granularity', [], 32, And(Or(Op('==', Reg('Config3::SM'), 1), And(Op('gte', Reg('Config::AR'), 1), Or(Op('==', Reg('Config::MT'), 1), Op('==', Reg('Config::MT'), 4)))), Or(Op('==', Reg('Config3::SP'), 1), Op('==', Reg('Config3::RXI'), 1)))),
         Register('MVPControl', 'cp0.0.1', '', {'': [Field('Reserved', Bits(31, 4)), Field('CPA', Bits(3), '1 to permit per-VPE assignment of cache ways.'), Field('STLB', Bits(2), '1 to enable TLB sharing between VPEs.'), Field('VPC', Bits(1), '1 for MT configuration mode.'), Field('EVP', Bits(0), 'The dvpe/evpe bit: 0 disables multithreading, even other VPE.')], 'interAptiv.*': [Field('0', Bits(31, 4), 'Must be written as zero; returns zero on read.'), Field('CPA', Bits(3), 'Cache Partitioning Active.  If set, the IWX and DWX fields of the VPEOpt register control the allocation of cache lines. If clear, IWX and DWX are ignored.'), Field('STLB', Bits(2), 'The shared TLB function is not supported in the interAptiv architecture.'), Field('VPC', Bits(1), 'VPE Configuration State.  Set to 1 for MT configuration mode. Writable by software only if the VPEConf0.MVP bit is set for the VPE issuing the modifying instruction.'), Field('EVP', Bits(0), 'Enable Virtual Processors.  Modifiable only if the VPEConf0.MVP bit is set for the VPE issuing the modifying instruction. Set by EVPE instruction and cleared by DVPE instruction. If set, all activated VPEs on a processor fetch and execute independently. If cleared, only a single instruction stream on a single VPE can run.')]}, 'The MVPControl register is instantiated per-processor, and provides an interface for global control and configuration of a multi-VPE MIPS MT Core.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('Index', 'cp0.0.0', '', {'': [Field('P', Bits(31), 'Probe Failure.CRLF;Set to 1 by hardware when the previous TLBProbe (TLBP) instruction failed to find a match in the TLB.', [Value('Match', 0), Value('No match', 1)]), Field('Reserved', Bits(30, 6)), Field('Index', Bits(5, 0), 'Index to the TLB entry affected by the TLBRead and TLBWrite instructions.')], 'proAptiv.*,P5600.*,interAptiv.*,M5150.*,I6[45]00.*,P6600.*': [Field('P', Bits(31), 'Probe Failure.  This bit is automatically set when a TLBP search of the TLB fails to find a matching entry.', [Value('Match', 0), Value('No match', 1)]), Field('Index', Bits(9, 0), 'An index into the TLB used for TLBR, TLBWI, TLBINV and TLBINVF instructions.  This field is set by the TLBP instruction when it finds a matching entry.', [], None, 'proAptiv.*,P5600.*,P6600.*,I6[45]00.*'), Field('Index', Bits(5, 0), 'Index to the TLB entry affected by the TLBRead and TLBWrite instructions.${nl}For 16 or 32 entry TLBs, behavior is undefined if index points to a non-existent entry.', [], None, 'interAptiv.*'), Field('Index', Bits(4, 0), 'Index to the TLB entry affected by the TLBRead and TLBWrite instructions.${nl}For 16 or 32 entry TLBs, behavior is undefined if index points to a non-existent entry.', [], None, 'M5150.*')]}, 'The Index register is a 32-bit read/write register that contains the index used to access the TLB for TLBP, TLBR, and TLBWI instructions. The width of the index field is implementation-dependent as a function of the number of TLB entries that are implemented. The minimum value for TLB-based MMUs is Ceiling(Log2(TLBEntries)).${p}The operation of the processor is UNDEFINED if a value greater than or equal to the number of TLB entries is written to the Index register.${p}This register is only valid with the TLB. It is reserved if the FM is implemented.', [], 32, Or(Op('==', Reg('Config::MT'), 1), Op('==', Reg('Config::MT'), 4))),
         Register('ContextConfig', 'cp0.4.1', '', {'proAptiv.*,P5600.*,interAptiv.*,P6600.*': [Field('0', Bits(31, 23), 'Must be written as zero; returns zero on read.'), Field('VirtualIndex', Bits(22, 2), 'A mask of 0 to 21 contiguous 1 bits in this field causes the corresponding bits of the Context register to be written with the high order bits of the virtual address causing a TLB exception.${p}Behavior of the processor is UNDEFINED if non-contiguous 1 bits are written into the register field.  Note that it is the responsibility of software to ensure that this field is written with contiguous ones because if non-contiguous 1 bits are written, no exception will be taken.'), Field('0', Bits(1, 0), 'Must be written as zero; returns zero on read.')]}, '', [], 32, Or(Op('==', Reg('Config3::CTXTC'), 1), Op('==', Reg('Config3::SM'), 1))),
         Register('BadInstrP', 'cp0.8.2', '', {'M51[05]0,P5600,I6[45]00.*,P6600.*': []}, 'The BadInstrP register contains the prior branch instruction when the faulting instruction is in a branch delay slot.', [], 32, Op('==', Reg('Config3::BP'), 1), 'r'),
         Register('BadInstr', 'cp0.8.1', '', {'M51[05]0,P5600,I6[45]00.*,P6600.*': []}, 'The BadInstr register is a read-only register that captures the most recent instruction that caused one of the following exceptions:  Instruction Validity, Execution Exception or Addressing Error.', [], 32, Op('==', Reg('Config3::BI'), 1), 'r'),
         Register('Count', 'cp0.9.0', '', {'': []}, 'The Count register acts as a timer, incrementing at a constant rate, whether or not an instruction is executed, retired, or any forward progress is made through the pipeline.  The rate at which the counter increments is implementation dependent, and is a function of the pipeline clock of the processor, not the issue width of the processor.'),
         Register('Compare', 'cp0.11.0', '', {'': []}, 'The Compare register acts in conjunction with the Count register to implement a timer and timer interrupt function.  The Compare register maintains a stable value and does not change on its own.'),
         Register('TCStatus', 'cp0.2.1', '', {'': [Field('TCU', Bits(31, 28), 'Per-TC view of Status[CU3-0] (CP enables).'), Field('TMX', Bits(27), 'Per-TC view of Status[MX] (DSP instructions enable).'), Field('Reserved', Bits(26, 25)), Field('RNST', Bits(24, 23), 'TC Run State.', [Value('Running', 0), Value('Blocked on WAIT', 1), Value('Blocked on YIELD', 2), Value('Blocked on Gating Storage', 3)]), Field('Reserved', Bits(22)), Field('TDS', Bits(21), '1 when halted on an instruction in branch delay slot.'), Field('DT', Bits(20), "TC is 'dirty' -- has run code, may have changed state."), Field('TCEE', Bits(17), 'Per-TC view of Status[CEE] (CorExtend) enable.'), Field('DA', Bits(15), "TC available for 'fork'."), Field('Reserved', Bits(14)), Field('A', Bits(13), 'TC allocated -- set by fork, TC cannot run unless set.'), Field('TKSU', Bits(12, 11), 'Per-TC view of Status[UM,SM] (privilege level).'), Field('IXMT', Bits(10), 'TC is Interrupt-eXeMpt.'), Field('Reserved', Bits(9, 8)), Field('TASID', Bits(7, 0), 'Per-TC view of EntryHi[ASID].')], 'proAptiv.*,interAptiv.*': [Field('TCU', Bits(31, 28), 'Per-TC view of Status[CU3-0] (CP enables).'), Field('TMX', Bits(27), 'Per-TC view of Status[MX] (DSP instructions enable).'), Field('TFR', Bits(26), 'This bit is used to control the floating point register mode for 64-bit floating point units.\\n\\nStatus bit FR is identical to TCStatus bit TFR of the thread referencing that Status with an MFC0 operation.\\n\\nThe modification of either must be visible in both.'), Field('Reserved', Bits(25)), Field('RNST', Bits(24, 23), 'TC Run State.', [Value('Running', 0), Value('Blocked on WAIT', 1), Value('Blocked on YIELD', 2), Value('Blocked on Gating Storage', 3)]), Field('Reserved', Bits(22)), Field('TDS', Bits(21), '1 when halted on an instruction in branch delay slot.'), Field('DT', Bits(20), "TC is 'dirty' -- has run code, may have changed state."), Field('TCEE', Bits(17), 'Per-TC view of Status[CEE] (CorExtend) enable.'), Field('DA', Bits(15), "TC available for 'fork'."), Field('Reserved', Bits(14)), Field('A', Bits(13), 'TC allocated -- set by fork, TC cannot run unless set.'), Field('TKSU', Bits(12, 11), 'Per-TC view of Status[UM,SM] (privilege level).'), Field('IXMT', Bits(10), 'TC is Interrupt-eXeMpt.'), Field('Reserved', Bits(9, 8)), Field('TASID', Bits(7, 0), 'Per-TC view of EntryHi[ASID].')]}, 'Per-TC status information, including copies of thread-specific bits of Status and EntryHi registers.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('TCScheFBack', 'cp0.2.7', '', {}, 'The Scheduler Feedback is a per-TC feedback value from scheduler hardware to software, whose interpretation is scheduler implementation-dependent.  For example, it might encode the number of instructions retired in the instruction stream corresponding to the TC since the last time the value was cleared by software.', [], 32, Op('==', Condition('VPEScheduling'), True)),
         Register('TCSchedule', 'cp0.2.6', '', {}, 'The Scheduler Hint is a per-TC value whose interpretation is scheduler implementation-dependent.  For example, it could encode a description of the requested issue bandwidth for the associated thread, as in the VPESchedule register, or it could encode a priority level.', [], 32, Op('==', Condition('VPEScheduling'), True)),
         Register('TCRestart', 'cp0.2.3', '', {}, 'When a TC is in a Halted state, a read of the TCRestart register returns the instruction address at which the TC will start execution when it is restarted.  The TCRestart register can be written while the associated TC is in a Halted state to change the address at which the TC will restart.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('TCOpt', 'cp0.3.7', '', {'': [Field('0', Bits(31, 4), 'Reserved.  Should be ignored on writes; returns zero on reads.'), Field('C', Bits(3, 0), 'Data cache way exclusion mask.  If programmable cache allocation is enabled via the CPA bit in the MVPControl register, this field excludes ways of the primary data cache from allocation by the cache controller for any given TC.\\n\\n  bit 3 DWX0  If set, D-cache way 3 will not be allocated for the TC\\n  bit 2 DWX2  If set, D-cache way 2 will not be allocated for the TC\\n  bit 1 DWX1  If set, D-cache way 1 will not be allocated for the TC\\n  bit 0 DWX0  If set, D-cache way 0 will not be allocated for the TC')]}, "The TCOpt register is instantiated per-TC.  If way exclusion is enabled via the MVPControlCPA bit, the fields in this register will control which ways should be excluded from the replacement scheme for this TC.  \\n\\nThe Prefetch instruction with a hint of 'Streamed' will always allocate in way0 regardless of TCOpt.  Similarly, PREF/Retained will never allocate in way0 even if TCOpt restricts all other ways.\\n\\nNOTE: If a way is scheduled for eviction and a store hits to it, that way will be reallocated.  This re-allocation will always be to the original way the line was in even if this way is restricted by TCOpt.", [], 32, Op('==', Condition('VPEScheduling'), True)),
         Register('TCHalt', 'cp0.2.4', '', {'': [Field('Reserved', Bits(31, 1)), Field('H', Bits(0), 'Writing a one to the Halted bit of an activated TC causes the associated thread to cease fetching instructions and to set its Restart Address in the TCRestart register (see section 7.2.15) to the address of the next instruction to be issued.')], 'proAptiv.*,interAptiv.*': [Field('0', Bits(31, 1), 'Must be written as zero; returns zero on read.'), Field('H', Bits(0), 'Writing a one to the Halted bit of an activated TC causes the associated thread to cease fetching instructions and to set its Restart Address in the TCRestart register to the address of the next instruction to be issued.')]}, 'Writing a one to the Halted bit of an activated TC causes the associated thread to cease fetching instructions and to set its Restart Address in the TCRestart register to the address of the next instruction to be issued.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('TCContext', 'cp0.2.5', '', {}, 'TCContext is purely a software read/write register, usable by the operating system as a pointer to thread-specific storage, e.g.  a thread context save area.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('TCBind', 'cp0.2.2', '', {'': [Field('Reserved', Bits(31, 29)), Field('CurTC', Bits(28, 21), 'The number of the TC which owns this register.'), Field('Reserved', Bits(20, 18)), Field('TBE', Bits(17), 'Thread Bus Error: A load instruction from this TC caused an error.'), Field('Reserved', Bits(16, 4)), Field('CurVPE', Bits(3, 0), 'The number of the VPE to which this TC is affiliated.')], 'proAptiv.*,interAptiv.*': [Field('0', Bits(31, 29), 'Must be written as zero; returns zero on read.'), Field('CurTC', Bits(28, 21), 'The number of the TC which owns this register.'), Field('0', Bits(20, 18), 'Must be written as zero; returns zero on read.'), Field('TBE', Bits(17), 'Thread Bus Error: A load instruction from this TC caused an error.'), Field('0', Bits(16, 4), 'Must be written as zero; returns zero on read.'), Field('CurVPE', Bits(3, 0), 'The ID number of the VPE affiliation of this TC. Externally set on reset based on SI_Vpe0MaxTC. In a two VPE system, all TCs between 0 and SI_Vpe0MaxTC inclusive are bound to VPE0 on reset and remaining ones are bound to VPE1. Writable when MVPControlVPC is set')]}, 'The TCBind register is instantiated per-TC as part of the system co-processor.  It defines the VPE affiliation and identification number of this TC.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('SRSMap2', 'cp0.12.5', '', {'': [Field('0', Bits(31, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('SSV9', Bits(7, 4), 'Shadow set to use for Interrupt 9 (vectored int mode only).'), Field('SSV8', Bits(3, 0), 'Shadow set to use for Interrupt 8 (vectored int mode only).')]}, '', [], 32, And(Op('==', Reg('SRSCtl::HSS'), 1), Op('==', Reg('Config3::VInt'), 1), Op('==', Reg('Config3::MCU'), 1))),
         Register('SRSMap', 'cp0.12.3', '', {'': [Field('SSV7', Bits(31, 28), 'Shadow set to use for Interrupt 7 (vectored int mode only).'), Field('SSV6', Bits(27, 24), 'Shadow set to use for Interrupt 6 (vectored int mode only).'), Field('SSV5', Bits(23, 20), 'Shadow set to use for Interrupt 5 (vectored int mode only).'), Field('SSV4', Bits(19, 16), 'Shadow set to use for Interrupt 4 (vectored int mode only).'), Field('SSV3', Bits(15, 12), 'Shadow set to use for Interrupt 3 (vectored int mode only).'), Field('SSV2', Bits(11, 8), 'Shadow set to use for Interrupt 2 (vectored int mode only).'), Field('SSV1', Bits(7, 4), 'Shadow set to use for Interrupt 1 (vectored int mode only).'), Field('SSV0', Bits(3, 0), 'Shadow set to use for Interrupt 0 (vectored int mode only).')]}, 'The SRSMap register contains 8 4-bit fields that provide the mapping from an vector number to the shadow set number to use when servicing such an interrupt.', [], 32, Or(Op('==', Reg('SRSCtl::HSS'), 1), And(Op('==', Reg('Config::MT'), 1), Op('!=', Reg('SRSConf0::SRS1'), 1023)))),
         Register('SRSCtl', 'cp0.12.2', '', {'': [Field('HSS', Bits(29, 26), 'Highest-numbered shadow set on this VPE/CPU controls the operation of GPR shadow sets in the processor.'), Field('EICSS', Bits(21, 18), 'Shadow set number proposed by EIC-mode interrupt controller.'), Field('ESS', Bits(15, 12), 'Write shadow set to be used by non-interrupt exceptions.'), Field('PSS', Bits(9, 6), 'Previous register set (to return to on ERET).'), Field('CSS', Bits(3, 0), 'Currently active register set.')], 'P5600.*': [Field('HSS', Bits(29, 26), 'Highest-numbered shadow set on this VPE/CPU controls the operation of GPR shadow sets in the processor.')], 'P6600.*': [Field('HSS', Bits(29, 26), 'P6600 does not implement thread contexts or shadow registers.  This value is 0 to indicate this to software.')]}, 'Controls the operation of GPR shadow sets in the processor.', [], 32, Op('gte', Reg('Config::AR'), 1)),
         Register('SRSConf4', 'cp0.6.5', '', {'': [Field('M', Bits(31), 'More-registers bit.'), Field('Reserved', Bits(30)), Field('SRS15', Bits(29, 20), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS14', Bits(19, 10), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS13', Bits(9, 0), 'Set to TC# to use TCs registers as shadow set.')]}, 'Shadow registers.', [], 32, And(Op('==', Reg('Config3::MT'), 1), Op('==', Reg('SRSConf3::M'), 1))),
         Register('SRSConf3', 'cp0.6.4', '', {'': [Field('M', Bits(31), 'More-registers bit.'), Field('Reserved', Bits(30)), Field('SRS12', Bits(29, 20), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS11', Bits(19, 10), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS10', Bits(9, 0), 'Set to TC# to use TCs registers as shadow set.')]}, 'Shadow registers.', [], 32, And(Op('==', Reg('Config3::MT'), 1), Op('==', Reg('SRSConf2::M'), 1))),
         Register('SRSConf2', 'cp0.6.3', '', {'': [Field('M', Bits(31), 'More-registers bit.'), Field('Reserved', Bits(30)), Field('SRS9', Bits(29, 20), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS8', Bits(19, 10), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS7', Bits(9, 0), 'Set to TC# to use TCs registers as shadow set.')]}, 'Shadow registers.', [], 32, And(Op('==', Reg('Config3::MT'), 1), Op('==', Reg('SRSConf1::M'), 1))),
         Register('SRSConf1', 'cp0.6.2', '', {'': [Field('M', Bits(31), 'More-registers bit.'), Field('Reserved', Bits(30)), Field('SRS6', Bits(29, 20), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS5', Bits(19, 10), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS4', Bits(9, 0), 'Set to TC# to use TCs registers as shadow set.')]}, 'Shadow registers.', [], 32, And(Op('==', Reg('Config3::MT'), 1), Op('==', Reg('SRSConf0::M'), 1))),
         Register('SRSConf0', 'cp0.6.1', '', {'': [Field('M', Bits(31), 'More-registers bit.'), Field('Reserved', Bits(30)), Field('SRS3', Bits(29, 20), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS2', Bits(19, 10), 'Set to TC# to use TCs registers as shadow set.'), Field('SRS1', Bits(9, 0), 'Set to TC# to use TCs registers as shadow set.')], 'proAptiv.*,interAptiv.*': [Field('M', Bits(31), 'Continuation indication.  Since there is no SRSConf1 in the interAptiv core, it will read zero.'), Field('0', Bits(30), 'Must be written as zero; returns zero on read.'), Field('SRS3', Bits(29, 20), 'If set to 0x3ff indicates this SRS is not supported.'), Field('SRS2', Bits(19, 10), 'If set to 0x3ff indicates this SRS is not supported.'), Field('SRS1', Bits(9, 0), 'If set to 0x3ff indicates this SRS is not supported.')], 'P5600': []}, 'The SRSConf0 register is instantiated per-VPE.  It indicates the binding of TCs or other GPR resources to Shadow Register Sets 1 through 3.', [], 32, Op('==', Reg('Config3::MT'), 1)),
         Register('SecurityScrambling', 'cp0.22.3', '', {'': []}, 'Configuration bits for the external cache scrambling unit. Reads from this register returns an undefined value which does not depend on previous writes to the register.', [], 32, Or(And(Op('==', Reg('Config3::SM'), 1), Op('==', Reg('PRId::CoID'), 1), CPUNameMatches('4KSc')), CPUNameMatches('M5150'))),
         Register('SecurityHwPRNG', 'cp0.22.2', '', {'': []}, 'A value written to this register will function as a seed value for the pseudo random number generator, which is used for random slip generation.', [], 32, Or(And(Op('==', Reg('Config3::SM'), 1), Op('==', Reg('PRId::CoID'), 1), CPUNameMatches('4KSc')), CPUNameMatches('M51[05]0'))),
         Register('SecuritySwPRNG', 'cp0.22.1', '', {'': [Field('Random', Bits(31, 0), 'Each read returns the next number in a pseudo random      number sequence. A value written to the register will be      used as a seed value by the PRNG.')]}, 'A value written to the register will be used as a seed value by the generator.', [], 32, Or(And(Op('==', Reg('Config3::SM'), 1), Op('==', Reg('PRId::CoID'), 1), CPUNameMatches('4KSc')), CPUNameMatches('M51[05]0'))),
         Register('SecurityCtrl', 'cp0.22.0', '', {'': [], 'M51[05]0': [Field('SEL', Bits(23, 16), 'Address selector for data written to SecurityHwPRNG.'), Field('RSI', Bits(2, 0), 'Random slip interval. This field determines the average interval between random slips.')]}, 'This register controls the security features in the core: random slip generation and random cache line refill order.', [], 32, Or(And(Op('==', Reg('Config3::SM'), 1), Op('==', Reg('PRId::CoID'), 1), CPUNameMatches('4KSc')), CPUNameMatches('M51[05]0'))),
         Register('PerfCtl3', 'cp0.25.6', '', 'Perf_control_odd', 'Performance counter 3 control register', [], 32, Op('==', Reg('PerfCtl2::M'), 1)),
         Register('PerfCtl2', 'cp0.25.4', '', 'Perf_control_even', 'Performance counter 2 control register', [], 32, Op('==', Reg('PerfCtl1::M'), 1)),
         Register('PerfCtl1', 'cp0.25.2', '', 'Perf_control_odd', 'Performance counter 1 control register', [], 32, Op('==', Reg('PerfCtl0::M'), 1)),
         Register('PerfCtl0', 'cp0.25.0', '', 'Perf_control_even', 'Performance counter 0 control register', [], 32, Op('==', Reg('Config1::PC'), 1)),
         Register('PerfCnt3', 'cp0.25.7', '', {}, 'Performance counter 3', [], 32, Op('==', Reg('PerfCtl2::M'), 1)),
         Register('PerfCnt2', 'cp0.25.5', '', {}, 'Performance counter 2', [], 32, Op('==', Reg('PerfCtl1::M'), 1)),
         Register('PerfCnt1', 'cp0.25.3', '', {}, 'Performance counter 1.', [], 32, Op('==', Reg('PerfCtl0::M'), 1)),
         Register('PerfCnt0', 'cp0.25.1', '', {}, 'Performance counter 0', [], 32, Op('==', Reg('Config1::PC'), 1)),
         Register('SegCtl2', 'cp0.5.4', '', {'': [Field('CFG5_PA', Bits(31, 25), 'Physical address bits 31:29 for segment 5. For use when     unmapped. Bits 27:25 correspond to physical address bits 31:29      for segment 5. Bits 31:28 are reserved for future expansion.'), Field('Reserved', Bits(24, 23)), Field('CFG5_AM', Bits(22, 20), 'Access control mode.', [Value('UK', 0, 'Kernel-only unmapped region, e.g. kseg0, kseg1'), Value('MK', 1, 'Kernel-only mapped region, e.g. kseg3'), Value('MSK', 2, 'Supervisor and kernel mapped region, e.g. ksseg, sseg'), Value('MUSK', 3, 'User, supervisor and kernel mapped region, e.g. useg, kuseg, suseg'), Value('MUSUK', 4, 'Used to implement a fully-mapped flat address space in user and supervisor modes, with unmapped regions which appear in kernel mode'), Value('USK', 5, 'Supervisor and kernel unmapped region e.g. sseg in a fixed mapping TLB'), Value('Reserved', 6, '', True), Value('UUSK', 7, 'Unrestricted unmapped region')]), Field('CFG5_EU', Bits(19), 'Error condition behavior.  Segment becomes unmapped and uncached when Status[ERL] = 1.'), Field('CFG5_C', Bits(18, 16), 'Cache coherence attribute, for use when unmapped.  As defined by the base architecture.', [Value('Reserved', 0), Value('Reserved', 1), Value('UC', 2, 'Uncached, non-coherent'), Value('WB', 3, 'Cacheable, noncoherent, write-back, write allocate'), Value('CWBE', 4, 'Cacheable, coherent, write-back, write-allocate, read misses request Exclusive'), Value('CWB', 5, 'Cacheable, coherent, write-back, write-allocate, read misses request Shared'), Value('Reserved', 6), Value('UCA', 7, 'Uncached Accelerated, non-coherent')]), Field('CFG4_PA', Bits(15, 9), 'Physical address bits 31:29 for segment 4. For use when     unmapped. Bits 11:9 correspond to physical address bits 31:29 for     segment 6. Bits 15:12 are reserved for future expansion.'), Field('Reserved', Bits(8, 7)), Field('CFG4_AM', Bits(6, 4), 'Access control mode.', [Value('UK', 0, 'Kernel-only unmapped region, e.g. kseg0, kseg1'), Value('MK', 1, 'Kernel-only mapped region, e.g. kseg3'), Value('MSK', 2, 'Supervisor and kernel mapped region, e.g. ksseg, sseg'), Value('MUSK', 3, 'User, supervisor and kernel mapped region, e.g. useg, kuseg, suseg'), Value('MUSUK', 4, 'Used to implement a fully-mapped flat address space in user and supervisor modes, with unmapped regions which appear in kernel mode'), Value('USK', 5, 'Supervisor and kernel unmapped region e.g. sseg in a fixed mapping TLB'), Value('Reserved', 6, '', True), Value('UUSK', 7, 'Unrestricted unmapped region')]), Field('CFG4_EU', Bits(3), 'Error condition behavior.  Segment becomes unmapped and uncached when Status[ERL] = 1.'), Field('CFG4_C', Bits(2, 0), 'Cache coherence attribute, for use when unmapped.  As defined by the base architecture.', [Value('Reserved', 0), Value('Reserved', 1), Value('UC', 2, 'Uncached, non-coherent'), Value('WB', 3, 'Cacheable, noncoherent, write-back, write allocate'), Value('CWBE', 4, 'Cacheable, coherent, write-back, write-allocate, read misses request Exclusive'), Value('CWB', 5, 'Cacheable, coherent, write-back, write-allocate, read misses request Shared'), Value('Reserved', 6), Value('UCA', 7, 'Uncached Accelerated, non-coherent')])]}, 'The SegCtl2 register works in conjunction with the SegCtl0 and SegCtl1    registers to allow for configuration of the memory segmentation system.  The    address is split into six segments.${p}The behavior of each region is controlled    by a segment configuration.${p}Segmentation Control allows address-specific    behaviors defined by the Privileged Resource Architecture to be modified or    disabled.  The Segmentation Control registers are instantiated per-VPE in a MT    ASE processor.', [], 32, Op('==', Reg('Config5::EVA'), 1)),
         Register('SegCtl1', 'cp0.5.3', '', {'': [Field('CFG3_PA', Bits(31, 25), 'Physical address bits 31:29 for segment 3. For use when     unmapped. Bits 27:25 correspond to physical address bits 31:29 for      segment 3. Bits 31:28 are reserved for future expansion.', [], Bits(31, 29)), Field('Reserved', Bits(24, 23)), Field('CFG3_AM', Bits(22, 20), 'Access control mode.  Bits 6:4 correspond to segments 0, 2, and 4.  Bits 22:20 correspond to segments 1, 2, and 5.', [Value('UK', 0, 'Kernel-only unmapped region, e.g. kseg0, kseg1'), Value('MK', 1, 'Kernel-only mapped region, e.g. kseg3'), Value('MSK', 2, 'Supervisor and kernel mapped region, e.g. ksseg, sseg'), Value('MUSK', 3, 'User, supervisor and kernel mapped region, e.g. useg, kuseg, suseg'), Value('MUSUK', 4, 'Used to implement a fully-mapped flat address space in user and supervisor modes, with unmapped regions which appear in kernel mode'), Value('USK', 5, 'Supervisor and kernel unmapped region e.g. sseg in a fixed mapping TLB'), Value('Reserved', 6, '', True), Value('UUSK', 7, 'Unrestricted unmapped region')]), Field('CFG3_EU', Bits(19), 'Error condition behavior.  Segment becomes unmapped and uncached when Status[ERL] = 1.  Bit 3corresponds to segments 0, 2, and 4.  Bit 19 corresponds to segments 1, 2, and 5.'), Field('CFG3_C', Bits(18, 16), 'Cache coherence attribute, for use when unmapped.  As defined by the base architecture.  Bits 2:0 correspond to segments 0, 2, and 4.  Bits 18:16 correspond to segments 1, 2, and 5.', [Value('Reserved', 0), Value('Reserved', 1), Value('UC', 2, 'Uncached, non-coherent'), Value('WB', 3, 'Cacheable, noncoherent, write-back, write allocate'), Value('CWBE', 4, 'Cacheable, coherent, write-back, write-allocate, read misses request Exclusive'), Value('CWB', 5, 'Cacheable, coherent, write-back, write-allocate, read misses request Shared'), Value('Reserved', 6), Value('UCA', 7, 'Uncached Accelerated, non-coherent')]), Field('CFG2_PA', Bits(15, 9), 'Physical address bits 31:29 for segment 2. For use when     unmapped. Bits 11:9 correspond to physical address bits 31:29 for     segment 2. Bits 15:12 are reserved for future expansion.', [], Bits(31, 29)), Field('Reserved', Bits(8, 7)), Field('CFG2_AM', Bits(6, 4), 'Access control mode.  Bits 6:4 correspond to segments 0, 2, and 4.  Bits 22:20 correspond to segments 1, 2, and 5.', [Value('UK', 0, 'Kernel-only unmapped region, e.g. kseg0, kseg1'), Value('MK', 1, 'Kernel-only mapped region, e.g. kseg3'), Value('MSK', 2, 'Supervisor and kernel mapped region, e.g. ksseg, sseg'), Value('MUSK', 3, 'User, supervisor and kernel mapped region, e.g. useg, kuseg, suseg'), Value('MUSUK', 4, 'Used to implement a fully-mapped flat address space in user and supervisor modes, with unmapped regions which appear in kernel mode'), Value('USK', 5, 'Supervisor and kernel unmapped region e.g. sseg in a fixed mapping TLB'), Value('Reserved', 6, '', True), Value('UUSK', 7, 'Unrestricted unmapped region')]), Field('CFG2_EU', Bits(3), 'Error condition behavior.  Segment becomes unmapped and uncached when Status[ERL] = 1.  Bit 3corresponds to segments 0, 2, and 4.  Bit 19 corresponds to segments 1, 2, and 5.'), Field('CFG2_C', Bits(2, 0), 'Cache coherence attribute, for use when unmapped.  As defined by the base architecture.  Bits 2:0 correspond to segments 0, 2, and 4.  Bits 18:16 correspond to segments 1, 2, and 5.', [Value('Reserved', 0), Value('Reserved', 1), Value('UC', 2, 'Uncached, non-coherent'), Value('WB', 3, 'Cacheable, noncoherent, write-back, write allocate'), Value('CWBE', 4, 'Cacheable, coherent, write-back, write-allocate, read misses request Exclusive'), Value('CWB', 5, 'Cacheable, coherent, write-back, write-allocate, read misses request Shared'), Value('Reserved', 6), Value('UCA', 7, 'Uncached Accelerated, non-coherent')])]}, 'The SegCtl1 register works in conjunction with the SegCtl0 and SegCtl2    registers to allow for configuration of the memory segmentation system.  The    address is split into six segments.${p}The behavior of each region is controlled    by a Segment Configuration.${p}Segmentation Control allows address-specific    behaviors defined by the Privileged Resource Architecture to be modified or    disabled.  The Segmentation Control registers are instantiated per-VPE in a MT    ASE processor.', [], 32, Op('==', Reg('Config5::EVA'), 1)),
         Register('SegCtl0', 'cp0.5.2', '', {'': [Field('CFG1_PA', Bits(31, 25), 'Physical address bits 31:29 for segment 1. For use when     unmapped. Bits 27:25 correspond to physical address bits 31:29      for segment 1. Bits 31:28 are reserved for future expansion.', [], Bits(31, 29)), Field('Reserved', Bits(24, 23)), Field('CFG1_AM', Bits(22, 20), 'Access control mode.', [Value('UK', 0, 'Kernel-only unmapped region, e.g. kseg0, kseg1'), Value('MK', 1, 'Kernel-only mapped region, e.g. kseg3'), Value('MSK', 2, 'Supervisor and kernel mapped region, e.g. ksseg, sseg'), Value('MUSK', 3, 'User, supervisor and kernel mapped region, e.g. useg, kuseg, suseg'), Value('MUSUK', 4, 'Used to implement a fully-mapped flat address space in user and supervisor modes, with unmapped regions which appear in kernel mode'), Value('USK', 5, 'Supervisor and kernel unmapped region e.g. sseg in a fixed mapping TLB'), Value('Reserved', 6, '', True), Value('UUSK', 7, 'Unrestricted unmapped region')]), Field('CFG1_EU', Bits(19), 'Error condition behavior.  Segment becomes unmapped and uncached when Status[ERL] = 1.'), Field('CFG1_C', Bits(18, 16), 'Cache coherence attribute, for use when unmapped.  As defined by the base architecture.', [Value('Reserved', 0), Value('Reserved', 1), Value('UC', 2, 'Uncached, non-coherent'), Value('WB', 3, 'Cacheable, noncoherent, write-back, write allocate'), Value('CWBE', 4, 'Cacheable, coherent, write-back, write-allocate, read misses request Exclusive'), Value('CWB', 5, 'Cacheable, coherent, write-back, write-allocate, read misses request Shared'), Value('Reserved', 6), Value('UCA', 7, 'Uncached Accelerated, non-coherent')]), Field('CFG0_PA', Bits(15, 9), 'Physical address bits 31:29 for segment 0. For use when     unmapped. Bits 11:9 correspond to physical address bits 31:29 for     segment 0. Bits 15:12 are reserved for future expansion.', [], Bits(31, 29)), Field('Reserved', Bits(8, 7)), Field('CFG0_AM', Bits(6, 4), 'Access control mode.', [Value('UK', 0, 'Kernel-only unmapped region, e.g. kseg0, kseg1'), Value('MK', 1, 'Kernel-only mapped region, e.g. kseg3'), Value('MSK', 2, 'Supervisor and kernel mapped region, e.g. ksseg, sseg'), Value('MUSK', 3, 'User, supervisor and kernel mapped region, e.g. useg, kuseg, suseg'), Value('MUSUK', 4, 'Used to implement a fully-mapped flat address space in user and supervisor modes, with unmapped regions which appear in kernel mode'), Value('USK', 5, 'Supervisor and kernel unmapped region e.g. sseg in a fixed mapping TLB'), Value('Reserved', 6, '', True), Value('UUSK', 7, 'Unrestricted unmapped region')]), Field('CFG0_EU', Bits(3), 'Error condition behavior.  Segment becomes unmapped and uncached when Status[ERL] = 1.'), Field('CFG0_C', Bits(2, 0), 'Cache coherence attribute, for use when unmapped.  As defined by the base architecture.', [Value('Reserved', 0), Value('Reserved', 1), Value('UC', 2, 'Uncached, non-coherent'), Value('WB', 3, 'Cacheable, noncoherent, write-back, write allocate'), Value('CWBE', 4, 'Cacheable, coherent, write-back, write-allocate, read misses request Exclusive'), Value('CWB', 5, 'Cacheable, coherent, write-back, write-allocate, read misses request Shared'), Value('Reserved', 6), Value('UCA', 7, 'Uncached Accelerated, non-coherent')])]}, 'The SegCtl0 register works in conjunction with the SegCtl1 and SegCtl2 registers to allow    for configuration of the memory segmentation system.  The address is split into six segments.${p}   The behavior of each region is controlled by a Segment Configuration.${p}   Segmentation Control allows address-specific behaviors defined by the Privileged Resource Architecture to be    modified or disabled.${p}The Segmentation Control registers are instantiated per-VPE in a MT ASE    processor.', [], 32, Op('==', Reg('Config5::EVA'), True)),
         Register('View_RIPL', 'cp0.13.4', '', {'': [Field('0', Bits(31, 10), 'Reserved.  Must be written as zero; returns zero on read.'), Field('IP9-IP2', Bits(9, 2), 'HW Interrupt Pending.'), Field('RIPL', Bits(9, 2), 'Interrupt Priority Level. If EIC interrupt mode is enabled, this field indicates the Requested Priority Level of the pending interrupt.'), Field('IP1-IP0', Bits(1, 0), 'SW Interrupt Pending. If EIC interrupt mode is not enabled, controls which SW interrupts are pending.')]}, 'This register gives read access to the IP or RIPL field that is also available in the Cause Register', [], 32, Op('==', Reg('Config3::MCU'), 1)),
         Register('View_IPL', 'cp0.12.4', '', {'': [Field('0', Bits(31, 10), 'Reserved.  Must be written as zero; returns zero on read.'), Field('IM', Bits(9, 0), 'Interrupt Mask. If EIC interrupt mode is not enabled, controls which interrupts are enabled.Nested Cache Coherency Attributes: Determines whether guest CCA is modified by root CCA in 2nd step of guest address translation.'), Field('IPL', Bits(9, 2), 'Interrupt Priority Level. If EIC interrupt mode is enabled, this field is the encoded value of the current IPL.'), Field('0', Bits(1, 0), 'Reserved.  Must be written as zero; returns zero on read.')]}, 'This register gives read and write access to the IM or IPL field that is also available in the Status Register.', [], 32, Op('==', Reg('Config3::MCU'), 1)),
         Register('MAARI', 'cp0.17.2', '', {'P?600.*,I6[45]00.*': [Field('INDEX', Bits(5, 0), 'MAAR Index. If the number of MAAR registers is greater than    1 INDEX specifies the MAAR register to access.${p}    MAAR registers are paired. The least-significant bit of INDEX    is encoded as follows to indicate which register of the pair is    being accessed:${p}    0: This register specifies the upper address bound of the MAAR    register pair.${p}    1: This register specifies the lower address bound of the MAAR    register pair.${p}    Software may write all ones to INDEX to determine the maximum    value supported. Other than the all ones, if the value written    is not supported, then INDEX is unchanged from its    previous value since the write is dropped. The register range is    always contiguous and starts at value 0.')]}, u'The MAAR Index register is used in conjunction with MAAR registers (CP0 Register 17, Select 1). Multiple MAAR   registers may be implemented - MAAR Index is used to specify a MAAR register number that may be accessed by software   with an MTC0 or MFC0 instruction. Prior to access by MTC0 or MFC0, software must set MAARIINDEX to the   appropriate value.${p}   General Information:${p}   The 64-bit Memory Accessibility Attribute registers (MAAR) and the 64-bit Memory Accessibility Attribute register   Index (MAARI) define the accessibility attributes of memory regions.${p}   The MAAR register defines whether an instruction fetch or data load/store can speculatively access a memory region   within the address bounds specified by MAAR. The MAARI register is used to specify a MAAR register number that   may be accessed by software with an MTC0 or MFC0 instruction. Prior to access by MTC0 or MFC0, software must   set the MAARIINDEX field to the appropriate value.${p}   MAAR Register Pairs${p}   This core contains three pairs of MAAR registers, each of which are indexed using the MAAR Index (MAARI)   register located at CP0 Register 17, Sel 2. Each MAAR register pair consists of a 64-bit even and an odd register. The   three MAAR register pairs are as follows, where \u2018O\u2019 indicates the odd register of the pair and \u2018E\u2019 indicates the even   register; MAAR0O / MAAR0E, MAAR1O / MAAR1E, and MAAR2O / MAAR2E.${p}   The MAARI register must be initialized with the appropriate MAAR register number before the MAAR can be   accessed with an MTC0 or MFC0 instruction. An EHB instruction is required to be placed in between the write to   MAARI and the subsequent execution of a MTC0 or MFC0 instruction that specifies the MAAR.   The P6600 core implements three pairs of MAAR registers. The presence of a MAAR register pair can be detected by   software through Config5MRP.${p}   3-Pair MAAR Implementation${p}   The following pseudo-code shows a 3-pair MAAR implementation to determine speculation. Software must set the   logical valid to 1 of each register in the pair to enable a MAAR pair. It may however, clear any one logical valid of the   pair to invalidate the whole MAAR pair. Once both logical values are set to 1, hardware factors in the speculate attribute   of only the upper MAAR register with even index.${p}   Programming the State of the MAAR / MAARI Register Pair${p}   Software must follow the described method for reprogramming the state of a MAAR pair.${p}   * Disable the MAAR pair by clearing MAAR.VL and MAAR.VH. Accesses to the MAAR region become nonspeculative.${nl}   * Program PageGrainELPA as needed.${nl}   * Set MAAR.VL along with other fields in MAAR[63:0]', [], 64, Op('==', Reg('Config5::MRP'), 1)),
         Register('MAAR', 'cp0.17.1', '', {'P?600.*': [Field('ADDR', Bits(39, 12), 'Address bounds.${p}     ADDR must always specify a physical address.     MAAR regions are at least 64KB-aligned, and thus the least-significant     bit of ADDR is equal to PA[16].${p}     If the register specifies the upper bound, then any sourced     address must be less than or equal to ADDR.${p}     If the register specifies the lower bound, then any sourced     address must be greater than or equal to ADDR.${p}     See MAAR Index (CP0 Register 17, Select 2) for the method of     determining which register is upper or lower in a pair.${p}     MAAR[12] = PA[16]: This allows the MAAR register to specify     40 bits of PA, where MAAR[35] = PA[39]. The lower 16 bits of     the PA are not specified in this register since the MAAR regions     must be 64 KB aligned.'), Field('S', Bits(1), 'Speculate.${p}     If an access is qualified as non-speculative, it must be the oldest     unretired instruction in the processor before being allowed to     access memory or memory-mapped regions. This field is     encoded as follows:${p}     0: Instruction fetch or data load/store that matches MAAR register     pair address range is never allowed to speculatively access     address range.${p}     1: Instruction fetch or data load/store that matches MAAR register     pair address range may be allowed to speculate.${p}     MAAR regions are allowed to overlap. The cumulative speculative     attribute for overlapping regions is determined by ANDing     individual valid MAAR pair speculation attributes.'), Field('V', Bits(0), 'MAAR register valid. This field is encoded as follows:${p}     0: MAAR register is not valid and should not modify the behavior     of any instruction fetch or data load/store.${p}     1: MAAR register is valid and may modify behavior of any     instruction fetch or data load/store that falls within the range of     addresses specified by the MAAR register pair.${p}     If either valid bit of the MAAR register pair is set to 0, then the     pair is assumed invalid and thus will not modify the behavior of     any memory access. Software may thus invalidate one register     of the MAAR pair to invalidate the MAAR comparison.')], 'I6[45]00.*': [Field('ADDR', Bits(43, 12), 'Address bounds.${p}     ADDR must always specify a physical address. MAAR regions are at     least 64 kB-aligned, and thus the least-significant bit of ADDR is equal to PA[16]. If the     register specifies the upper bound, then any sourced address must be less than or equal     to ADDR. If the register specifies the lower bound, then any sourced address must be     greater than or equal to ADDR. See MAAR Index (CP0 Register 17, Select 2) for the     method of determining which register is upper or lower ina pair.     MAAR[12] = PA[16].${p}     This field covers ADDR[47:16].'), Field('S', Bits(1), 'Speculate.${p}     If an access is qualified as non-speculative, it must be the oldest     unretired instruction in the processor before being allowed to     access memory or memory-mapped regions. This field is     encoded as follows:${p}     0: Instruction fetch or data load/store that matches MAAR register     pair address range is never allowed to speculatively access     address range.${p}     1: Instruction fetch or data load/store that matches MAAR register     pair address range may be allowed to speculate.${p}     MAAR regions are allowed to overlap. The cumulative speculative     attribute for overlapping regions is determined by ANDing     individual valid MAAR pair speculation attributes.'), Field('VL', Bits(0), 'MAAR register valid, Low 32 bits. This field is encoded as follows:${p}     0: MAAR register is not valid and should not modify the behavior     of any instruction fetch or data load/store.${p}     1: MAAR register is valid and may modify behavior of any     instruction fetch or data load/store that falls within the range of     addresses specified by the MAAR register pair.${p}     If either valid bit of the MAAR register pair is set to 0, then the     pair is assumed invalid and thus will not modify the behavior of     any memory access. Software may thus invalidate one register     of the MAAR pair to invalidate the MAAR comparison.')]}, u'The Memory Accessibility Attribute Register (MAAR) is a read/write register defines the accessibility attributes of   memory regions. In particular, MAAR defines whether an instruction fetch or data load/store can speculatively access   a memory region within the address bounds specified by MAAR.${p}   The purpose of the MAAR register is to control speculation on load or fetch access to memory and I/O addresses. A   load is considered speculative if it accesses memory prior to its being the oldest instruction to retire. A fetch typically   always speculates on access to memory, while never speculating to I/O.${p}   If the MAAR function yields a valid attribute, it will only override any equivalent attribute determined through other   means, if it provides a more conservative outcome. For example, if the MMU yields a cacheable CCA, but MAAR   yields a speculate attribute set to 0, then the access should not speculate as determined by the MAAR result. Similarly,   if the MMU yields an uncacheable CCA, but MAAR yields a speculate attribute set to 1, then the access should not   speculate.${p}   The CCA of a memory access now defines speculation, along with MAAR. A memory access with a cacheable CCA is   allowed to speculate. A memory access with uncacheable CCA on the other hand is not allowed to speculate unless   the uncacheable CCA = 7 (UCA) is used. The final speculative attribute is a combination of the CCA and MAAR as   described above.${p}   The address range specified by a MAAR may be used to specify an attribute for any region of the address space,   whether memory (DRAM) or memory-mapped I/O.${p}   Note that the MAARI register must be initialized with the appropriate MAARI register number before the MAAR is   accessed with an MTC0 or MFC0 instruction. An EHB instruction is required to be placed between the write to   MAARI and subsequent execution of MTC0 or MFC0 that specifies the MAAR.${p}   The MAAR register has the following properties :${p}   1.If all MAAR instances are invalid, then no speculation is allowed. This allows the MAAR initialization to occur   at any point of time without the risk of execution speculative (bad path) loads or fetches from issuing to IO   addresses, with the tradeoff possibly being lower performance.${p}   2. If any MAAR region enables speculation, then accesses to physical addresses outside this MAAR region must be   non-speculative, unless the physical address of the access matches against a MAAR region with speculation   enabled. This access can then speculate.${p}   3. MAAR overlap is allowed: This allows non-speculative MAAR region to overlap a speculative MAAR region.${p}   For e.g., with this property, a non-speculative region can be overlayed on a speculative DRAM region with the   use of just two MAAR pairs.${p}   For software to enable a speculative region out of reset, it should first initialize MAARxO[63:0] and then   MAARxE[63:32].${p}   General Information:${p}   The 64-bit Memory Accessibility Attribute registers (MAAR) and the 64-bit Memory Accessibility Attribute register   Index (MAARI) define the accessibility attributes of memory regions.${p}   The MAAR register defines whether an instruction fetch or data load/store can speculatively access a memory region   within the address bounds specified by MAAR. The MAARI register is used to specify a MAAR register number that   may be accessed by software with an MTC0 or MFC0 instruction. Prior to access by MTC0 or MFC0, software must   set the MAARIINDEX field to the appropriate value.${p}   MAAR Register Pairs${p}   This core contains three pairs of MAAR registers, each of which are indexed using the MAAR Index (MAARI)   register located at CP0 Register 17, Sel 2. Each MAAR register pair consists of a 64-bit even and an odd register. The   three MAAR register pairs are as follows, where \u2018O\u2019 indicates the odd register of the pair and \u2018E\u2019 indicates the even   register; MAAR0O / MAAR0E, MAAR1O / MAAR1E, and MAAR2O / MAAR2E.${p}   The MAARI register must be initialized with the appropriate MAAR register number before the MAAR can be   accessed with an MTC0 or MFC0 instruction. An EHB instruction is required to be placed in between the write to   MAARI and the subsequent execution of a MTC0 or MFC0 instruction that specifies the MAAR.   This core implements three pairs of MAAR registers. The presence of a MAAR register pair can be detected by   software through Config5MRP.${p}   3-Pair MAAR Implementation${p}   The following pseudo-code shows a 3-pair MAAR implementation to determine speculation. Software must set the   logical valid to 1 of each register in the pair to enable a MAAR pair. It may however, clear any one logical valid of the   pair to invalidate the whole MAAR pair. Once both logical values are set to 1, hardware factors in the speculate attribute   of only the upper MAAR register with even index.${p}   Programming the State of the MAAR / MAARI Register Pair${p}   Software must follow the described method for reprogramming the state of a MAAR pair.${p}   * Disable the MAAR pair by clearing MAAR.VL and MAAR.VH. Accesses to the MAAR region become nonspeculative.${nl}   * Program PageGrainELPA as needed.${nl}   * Set MAAR.VL along with other fields in MAAR[63:0]', [], 64, Op('==', Reg('Config5::MRP'), 1)),
         Register('Cause', 'cp0.13.0', '', {'': [Field('BD', Bits(31), 'Exception in branch delay slot.', [Value('Not in delay slot', 0), Value('In delay slot', 1)]), Field('TI', Bits(30), 'CP0 counter/timer interrupted.', [Value('No timer interrupt is pending', 0), Value('Timer interrupt is pending', 1)]), Field('CE', Bits(29, 28), 'CP disabled exception.'), Field('DC', Bits(27), "Set 1 to stop Count register when CPU 'waits'.", [Value('Enable counting of Count register', 0), Value('Disable counting of Count register', 1)]), Field('PCI', Bits(26), 'Performance Counter Interrupt.', [Value('No performance counter interrupt is pending', 0), Value('Performance counter interrupt is pending', 1)]), Field('IC', Bits(25), 'Indicates if Interrupt Chaining occurred on the last IRET instruction.', [Value('Interrupt Chaining did not happen on last IRET', 0), Value('Interrupt Chaining occured during the last IRET', 1)]), Field('AP', Bits(24), 'Indicates whether an exception occurred during Interrupt Auto-Prologue.', [Value('Exception did not occur during Auto-Prologue operation', 0), Value('Exception occurred during Auto-Prologue operation', 1)]), Field('IV', Bits(23), 'Indicates whether an interrupt exception uses the general exception vector or a special interrupt vector.${p}Set 1 to give interrupts their own exception entry.', [Value('Use the general exception vector (0x180)', 0), Value('Use the special interrupt vector (0x200)', 1)]), Field('WP', Bits(22), 'Indicates that a watch exception was deferred because StatusEXL or StatusERL had a value of 1 at the ${nl}                   time the watch exception was detected. This bit indicates that the watch exception was deferred, and it${nl}                   causes the exception to be initiated when StatusEXL and StatusERL are both zero. As such, software must ${nl}                   clear this bit as part of the watch exception handler to prevent a watch exception loop.${p}                   Software should not write a 1 to this bit when its value is 0, thereby causing a 0-to-1 transition. If ${nl}                   such a transition is caused by software, it is UNPREDICTABLE whether hardware ignores the write, accepts ${nl}                   the write with no side effects, or accepts the write and initiates a watch exception when StatusEXL and ${nl}                   StatusERL are both zero.'), Field('FDCI', Bits(21), 'Fast Debug Channel Interrupt. This bit denotes whether a FDC Interrupt is pending ${nl}                 (analogous to the IP bits for other interrupt types):', [Value('No FDC interrupt is pending', 0), Value('FDC interrupt is pending', 1)]), Field('RIPL', Bits(17, 10), 'Requested Interrupt Priority Level.'), Field('IP9-IP2', Bits(17, 10), 'Indicates an interrupt is pending:', [Value('No interrupt is pending', 0), Value('Hw Interrupt 0', 1), Value('Hw Interrupt 1', 2), Value('Hw Interrupt 2', 4), Value('Hw Interrupt 3', 8), Value('Hw Interrupt 4', 16), Value('Hw Interrupt 5', 32), Value('Hw Interrupt 6', 64), Value('Hw Interrupt 7', 128)]), Field('IP1', Bits(9), 'Controls the request for software interrupt.${p}These bits are exported to an external interrupt controller for prioritization in EIC interrupt mode with other interrupt sources.  The state of these bits are driven onto the external SI_SWInt[1:0] bus.', [Value('No interrupt is requested', 0), Value('Request software interrupt 1', 1)]), Field('IP0', Bits(8), 'Controls the request for software interrupt.${p}These bits are exported to an external interrupt controller for prioritization in EIC interrupt mode with other interrupt sources.  The state of these bits are driven onto the external SI_SWInt[1:0] bus.', [Value('No interrupt is requested', 0), Value('Request software interrupt 0', 1)]), Field('ExcCode', Bits(6, 2), 'Exception code.', [Value('Interrupt', 0), Value('TLB modified exception', 1), Value('TLB exception (load/fetch)', 2), Value('TLB exception (store)', 3), Value('Address error exception (load/fetch)', 4), Value('Address error exception (store)', 5), Value('Bus error exception (fetch)', 6), Value('Bus error exception (load/store)', 7), Value('Syscall exception', 8), Value('Breakpoint exception', 9), Value('Reserved instruction exception', 10), Value('Coprocessor Unusable exception', 11), Value('Arithmetic Overflow exception', 12), Value('Trap exception', 13), Value('Reserved', 14, '', True), Value('Floating-point exception', 15), Value('Implementation-Specific Exception 1 (COP2)', 16), Value('CorExtend Unusable', 17), Value('Coprocessor 2 exceptions', 18), Value('TLB Read-Inhibit', 19), Value('TLB Execute-Inhibit', 20), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Reference to WatchHi/WatchLo address', 23), Value('Machine check', 24, '', True), Value('Reserved', 25, '', True), Value('DSP Module State Disabled exception', 26), Value('Hypervisor Exception (Guest Exit).', 27), Value('Reserved', 28, '', True), Value('Reserved', 29, '', True), Value('Parity Error', 30), Value('Reserved', 31, '', True)])], 'proAptiv.*,P5600.*,interAptiv.*,I6[45]00.*,P6600.*': [Field('BD', Bits(31), 'Indicates whether the last exception taken occurred in a branch delay slot.${p}The processor updates BD only if the EXL bit in the Status register was zero when the exception occurred.${p}If the exception occurred in a branch delay slot, the exception program counter (EPC) is set to restart execution at the branch.  Software should read this bit to determine if the exception was taken in a delay slot.', [Value('Not in delay slot', 0), Value('In delay slot', 1)]), Field('TI', Bits(30), 'Timer Interrupt.  Denotes whether a timer interrupt is pending (analogous to the IP bits for other interrupt types).${p}Hardware sets this bit based on the state of the external SI_TimerInt signal.  See also the descriptions of the Count and Compare registers.', [Value('No timer interrupt is pending', 0), Value('Timer interrupt is pending', 1)]), Field('CE', Bits(29, 28), 'Coprocessor unit number referenced when a Coprocessor Unusable exception is taken.  This field is loaded by hardware on every exception, but is UNPREDICTABLE for all exceptions except Coprocessor Unusable.', [Value('Coprocessor 0', 0), Value('Coprocessor 1', 1), Value('Coprocessor 2', 2), Value('Coprocessor 3', 3)]), Field('DC', Bits(27), 'Disable Count register.  In some power-sensitive applications, the Count register is not used but may still be the source of some noticeable power dissipation.  This bit allows the Count register to be stopped in such situations.  For example, this can be useful during low-power operation following a wait instruction.', [Value('Enable counting of Count register', 0), Value('Disable counting of Count register', 1)]), Field('PCI', Bits(26), 'Performance Counter Interrupt.  Indicates whether a performance counter interrupt is pending (analogous to the IP bits for other interrupt types).', [Value('No performance counter interrupt is pending', 0), Value('Performance counter interrupt is pending', 1)]), Field('IV', Bits(23), 'Indicates whether an interrupt exception uses the general exception vector or a special interrupt vector.${p}When the IV bit in the Cause register is 1 and the BEV bit in the Status register is 0, the special interrupt vector represents the base of the vector interrupt table.', [Value('Use the general exception vector (0x180)', 0), Value('Use the special interrupt vector (0x200)', 1)]), Field('WP', Bits(22), 'Indicates that a watch exception was deferred because either the Status[EXL] bit or the Status[ERL] bit was a logic 1 at the time the watch exception wasdetected.  This bit both indicates that the watch exception was deferred, and causes the exception to be initiated when Status[EXL] and Status[ERL] are both zero.  As such, software must clear this bit as part of the watch exception handler to prevent a watch exception loop.${p}Software should never write a 1 to this bit when its value is a 0, thereby causing a 0-to-1 transition.  If such a transition is caused by software, it is UNPREDICTABLE whether hardware ignores the write, accepts the write with no side effects, or accepts the write and initiates a watch exception once Status[EXL] and Status[ERL] are both zero.  Software should clear this bit, but never set it.  It is set by hardware.'), Field('FDCI', Bits(21), 'Fast Debug Channel Interrupt. This bit denotes whether an FDC interrupt is pending (analogous to the IP bits for other interrupt types).${p}The state of the FDCI bit is available on the external CPU interface as the SI_FDCInt signal.', [Value('No FDC interrupt is pending', 0), Value('FDC interrupt is pending', 1)]), Field('IP7 RIPL', Bits(15), 'Indicates an interrupt is pending.${p}If External Interrupt Controller (EIC) mode is disabled (Config3[VEIC] = 0), timer interrupts are combined in a system-dependent way with any hardware interrupt.${p}If EIC interrupt mode is enabled (Config3[VEIC] = 1), these bits take on a different meaning and are interpreted as the Requested Interrupt Priority Level (RIPL) field.${p}When EIC interrupt mode is enabled, this field contains the encoded (0 - 63) value of the requested interrupt.  A value of zero indicates that no interrupt is requested.', [Value('No interrupt is pending', 0), Value('IP7 Hardware interrupt 5 pending', 1)]), Field('IP6 RIPL', Bits(14), 'Indicates an interrupt is pending.${p}If External Interrupt Controller (EIC) mode is disabled (Config3[VEIC] = 0), timer interrupts are combined in a system-dependent way with any hardware interrupt.${p}If EIC interrupt mode is enabled (Config3[VEIC] = 1), these bits take on a different meaning and are interpreted as the Requested Interrupt Priority Level (RIPL) field.${p}When EIC interrupt mode is enabled, this field contains the encoded (0 - 63) value of the requested interrupt.  A value of zero indicates that no interrupt is requested.', [Value('No interrupt is pending', 0), Value('IP6 Hardware interrupt 4 pending', 1)]), Field('IP5 RIPL', Bits(13), 'Indicates an interrupt is pending.${p}If External Interrupt Controller (EIC) mode is disabled (Config3[VEIC] = 0), timer interrupts are combined in a system-dependent way with any hardware interrupt.${p}If EIC interrupt mode is enabled (Config3[VEIC] = 1), these bits take on a different meaning and are interpreted as the Requested Interrupt Priority Level (RIPL) field.${p}When EIC interrupt mode is enabled, this field contains the encoded (0 - 63) value of the requested interrupt.  A value of zero indicates that no interrupt is requested.', [Value('No interrupt is pending', 0), Value('IP5 Hardware interrupt 3 pending', 1)]), Field('IP4 RIPL', Bits(12), 'Indicates an interrupt is pending.${p}If External Interrupt Controller (EIC) mode is disabled (Config3[VEIC] = 0), timer interrupts are combined in a system-dependent way with any hardware interrupt.${p}If EIC interrupt mode is enabled (Config3[VEIC] = 1), these bits take on a different meaning and are interpreted as the Requested Interrupt Priority Level (RIPL) field.${p}When EIC interrupt mode is enabled, this field contains the encoded (0 - 63) value of the requested interrupt.  A value of zero indicates that no interrupt is requested.', [Value('No interrupt is pending', 0), Value('IP4 Hardware interrupt 2 pending', 1)]), Field('IP3 RIPL', Bits(11), 'Indicates an interrupt is pending.${p}If External Interrupt Controller (EIC) mode is disabled (Config3[VEIC] = 0), timer interrupts are combined in a system-dependent way with any hardware interrupt.${p}If EIC interrupt mode is enabled (Config3[VEIC] = 1), these bits take on a different meaning and are interpreted as the Requested Interrupt Priority Level (RIPL) field.${p}When EIC interrupt mode is enabled, this field contains the encoded (0 - 63) value of the requested interrupt.  A value of zero indicates that no interrupt is requested.', [Value('No interrupt is pending', 0), Value('IP3 Hardware interrupt 1 pending', 1)]), Field('IP2 RIPL', Bits(10), 'Indicates an interrupt is pending.${p}If External Interrupt Controller (EIC) mode is disabled (Config3[VEIC] = 0), timer interrupts are combined in a system-dependent way with any hardware interrupt.${p}If EIC interrupt mode is enabled (Config3[VEIC] = 1), these bits take on a different meaning and are interpreted as the Requested Interrupt Priority Level (RIPL) field.${p}When EIC interrupt mode is enabled, this field contains the encoded (0 - 63) value of the requested interrupt.  A value of zero indicates that no interrupt is requested.', [Value('No interrupt is pending', 0), Value('IP2 Hardware interrupt 0 pending', 1)]), Field('IP1', Bits(9), 'Controls the request for software interrupt.${p}These bits are exported to an external interrupt controller for prioritization in EIC interrupt mode with other interrupt sources.  The state of these bits are driven onto the external SI_SWInt[1:0] bus.', [Value('No interrupt is requested', 0), Value('Request software interrupt 1', 1)]), Field('IP0', Bits(8), 'Controls the request for software interrupt.${p}These bits are exported to an external interrupt controller for prioritization in EIC interrupt mode with other interrupt sources.  The state of these bits are driven onto the external SI_SWInt[1:0] bus.', [Value('No interrupt is requested', 0), Value('Request software interrupt 0', 1)]), Field('ExcCode', Bits(6, 2), 'Exception code.', [Value('Int  Interrupt', 0), Value('Mod  TLB modification exception', 1), Value('TLBL  TLB exception (load or instruction fetch)', 2), Value('TLBS  TLB exception (store)', 3), Value('AdEL  Address error exception (load or instruction fetch)', 4), Value('AdES  Address error exception (store)', 5), Value('IBE  Bus error exception (instruction fetch)', 6), Value('DBE  Bus error exception (data reference: load or store)', 7), Value('Sys  Syscall exception', 8), Value('Bp  Breakpoint exception', 9), Value('RI  Reserved instruction exception', 10), Value('CpU  Coprocessor Unusable exception see Status[CU3-0]', 11), Value('Ov  Arithmetic Overflow exception', 12), Value('Tr  Trap exception', 13), Value(u'FPE  Floating point unit exception \u2014 more details in the FPU control/status registers.', 15), Value('IS1  Coprocessor 2 implementation specific exception', 16), Value('CEU  CorExtend Unusable', 17), Value('C2E  Precise Coprocessor 2 exception', 18), Value('WATCH  Reference to WatchHi/WatchLo address', 23), Value('MCheck  Machine check - will not happen on interAptiv core', 24, '', True), Value('Thread  Thread exception. VPEControl[EXCPT] specifies the type', 25, '', True), Value('DSPDis  DSP ASE State Disabled exception', 26), Value('CacheErr  Does not occur in normal operation', 30, '', True)], None, 'InterAptiv.*'), Field('ExcCode', Bits(6, 2), 'Exception code.', [Value('Int  Interrupt', 0), Value('Mod  Store, but page marked as read-only in the TLB', 1), Value('TLBL  Load or fetch, but page marked as invalid in the TLB', 2), Value('TLBS  Store, but page marked as invalid in the TLB', 3), Value('AdEL  Address error on load/fetch', 4), Value('AdES  Address error on store', 5), Value('IBE  Bus error signaled on instruction fetch', 6), Value('DBE  Bus error signaled on load/store (imprecise)', 7), Value('Sys  System call, i.e.  syscall instruction executed', 8), Value('Bp  Breakpoint, i.e.  break instruction executed', 9), Value('RI  Instruction code not recognized (or not legal)', 10), Value('CpU  Instruction code was for a co-processor not enabled', 11), Value('Ov  Overflow from a trapping integer arithmetic instruction', 12), Value('Tr  Condition met on conditional trap instruction', 13), Value('FPE  Floating point unit exception', 15), Value('TLBPAR  TLB parity error exception', 16), Value('Available for implementation-dependent use', 17), Value('Available for implementation-dependent use', 18), Value('TLBRI  TLB read inhibit exception', 19), Value('TLBXI  TLB execute inhibit exception', 20), Value('WATCH  Instruction or data reference matched a watchpoint', 23), Value('MCheck  Machine check exception', 24, '', True), Value('DSPDis  DSP ASE not enabled or not present exception', 26), Value('CacheErr  Does not occur in normal operation', 30, '', True)], None, 'proAptiv.*,P5600'), Field('ExcCode', Bits(6, 2), 'Exception code.', [Value('Int', 0, 'Interrupt'), Value('Mod', 1, 'TLB modification exception'), Value('TLBL', 2, 'TLB exception (load or instruction fetch)'), Value('TLBS', 3, 'TLB exception (store)'), Value('AdEL', 4, 'Address error exception (load or instruction fetch)'), Value('AdES', 5, 'Address error exception (store)'), Value('IBE', 6, 'Bus error exception (instruction fetch)'), Value('DBE', 7, 'Bus error exception (data reference: load or store)'), Value('Sys', 8, 'Syscall exception'), Value('Bp', 9, 'Breakpoint exception. If OCI      debug is implemented and an SDBBP instruction is executed while the processor is      running in Debug Mode, this value is written to the DebugDExcCode field to denote      an SDBBP in Debug Mode.'), Value('RI', 10, 'Reserved instruction exception'), Value('CpU', 11, 'Coprocessor Unusable exception'), Value('Ov', 12, 'Arithmetic Overflow exception'), Value('Tr', 13, 'Trap exception'), Value('MSAFPE', 14, 'MSA Floating-Point exception'), Value('FPE', 15, 'Floating-Point exception'), Value('IDU1', 16, 'Available for implementation-dependent use'), Value('IDU2', 17, 'Available for implementation-dependent use'), Value('C2E', 18, 'Reserved for precise Coprocessor 2 exceptions'), Value('TLBRI', 19, 'TLB Read-Inhibit exception'), Value('TLBXI', 20, 'TLB Execute-Inhibit exception'), Value('MSADis', 21, 'MSA Disabled exception'), Value('MDMX', 22, 'Previously MDMX Unusable exception (MDMX ASE). MDMX deprecated'), Value('WATCH', 23, 'Reference to WatchHi/WatchLo address'), Value('MCheck', 24, 'Machine check exception', True), Value('Thread', 25, u'Thread Allocation, Deallocation, or Scheduling Exceptions (MIPS\xae MT Module)'), Value('DSPDis', 26, 'DSP ASE not enabled or not present exception'), Value('GE', 27, 'Virtualized Guest Exception /      Hypervisor Exception (Guest Exit). GE is set to 1 in following cases: - Hypervisorintervention      exception occurred during guest mode execution. - Hypercall executed in      root mode GuestCtl0.GExcCode contains additional cause information.'), Value('CacheErr', 30, 'Cache error. In normal      mode, a cache error exception has a dedicated vector and the Cause register is not      updated. A cache error occurs while in Debug Mode, this code is written to the Debug-      DExcCode field to indicate that re-entry to Debug Mode was caused by a cache error.', True)], None, 'I6[45]00.*'), Field('ExcCode', Bits(6, 2), 'Exception code.', [Value('Int', 0, 'Interrupt'), Value('Mod', 1, 'TLB modification exception'), Value('TLBL', 2, 'TLB exception (load or instruction fetch)'), Value('TLBS', 3, 'TLB exception (store)'), Value('AdEL', 4, 'Address error exception (load or instruction fetch)'), Value('AdES', 5, 'Address error exception (store)'), Value('IBE', 6, 'Bus error exception (instruction fetch)'), Value('DBE', 7, 'Bus error exception (data reference: load or store)'), Value('Sys', 8, 'Syscall exception'), Value('Bp', 9, 'Breakpoint exception. If OCI      debug is implemented and an SDBBP instruction is executed while the processor is      running in Debug Mode, this value is written to the DebugDExcCode field to denote      an SDBBP in Debug Mode.'), Value('RI', 10, 'Reserved instruction exception'), Value('CpU', 11, 'Coprocessor Unusable exception'), Value('Ov', 12, 'Arithmetic Overflow exception'), Value('Tr', 13, 'Trap exception'), Value('MSAFPE', 14, 'MSA Floating-Point exception'), Value('FPE', 15, 'Floating-Point exception'), Value('TLBPAR', 16, 'TLB parity error exception'), Value('IDU1', 17, 'Available for implementation-dependent use'), Value('IDU2', 18, 'Available for implementation-dependent use'), Value('TLBRI', 19, 'TLB Read-Inhibit exception'), Value('TLBXI', 20, 'TLB Execute-Inhibit exception'), Value('MSADis', 21, 'MSA Disabled exception'), Value('WATCH', 23, 'Reference to WatchHi/WatchLo address'), Value('MCheck', 24, 'Machine check exception', True), Value('DSPDis', 26, 'DSP ASE not enabled or not present exception'), Value('GE', 27, 'Virtualized Guest Exception /      Hypervisor Exception (Guest Exit). GE is set to 1 in following cases: - Hypervisorintervention      exception occurred during guest mode execution. - Hypercall executed in      root mode GuestCtl0.GExcCode contains additional cause information.'), Value('CacheErr', 30, 'Cache error. In normal      mode, a cache error exception has a dedicated vector and the Cause register is not      updated. A cache error occurs while in Debug Mode, this code is written to the Debug-      DExcCode field to indicate that re-entry to Debug Mode was caused by a cache error.', True)], None, 'P6600.*')]}, 'This register records information about the last exception, and is used by low-level exception handler code to decide what to do next.'),
         Register('WatchHi7', 'cp0.19.7', '', 'WatchHiFields', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi6::M'), 1)),
         Register('WatchHi6', 'cp0.19.6', '', 'WatchHiFields', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi5::M'), 1)),
         Register('WatchHi5', 'cp0.19.5', '', 'WatchHiFields', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi4::M'), 1)),
         Register('WatchHi4', 'cp0.19.4', '', 'WatchHiFields', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi3::M'), 1)),
         Register('WatchHi3', 'cp0.19.3', '', 'WatchHiFields', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi2::M'), 1)),
         Register('WatchHi2', 'cp0.19.2', '', 'WatchHiFields', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi1::M'), 1)),
         Register('WatchHi1', 'cp0.19.1', '', 'WatchHiFields', 'The WatchLo and WatchHi registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.', [], 32, Op('==', Reg('WatchHi0::M'), 1)),
         Register('WatchHi0', 'cp0.19.0', '', 'WatchHiFields', 'The WatchLoX and WatchHiX registers together provide the interface to a watchpoint debug facility which initiates a watch exception if an instruction or data access matches the address specified in the registers.  This register is also called WatchLo on processors that only have a single Watch pair.', [], 32, And(Op('==', Reg('Config1::WR'), 1))),
         Register('Debug2', 'cp0.23.6', '', {'': [Field('Reserved', Bits(31, 4)), Field('Prm', Bits(3), 'Primed - indicates whether a complex breakpoint with an active priming condition was seen on the last debug exception.'), Field('DQ', Bits(2), 'Data Qualified - indicates whether a complex breakpoint with an active data qualifier was seen on the last debug exception.'), Field('Tup', Bits(1), 'Tuple - indicates whether a tuple breakpoint was seen on the last debug exception.'), Field('PaCo', Bits(0), 'Pass Counter - indicates whether a complex breakpoint with an active pass counter was seen on the last debug exception.')]}, 'This register holds additional information about Complex Breakpoint exceptions.', [], 32, And(Or(Op('==', Condition('ejtag_present'), True), Op('==', Condition('oci32_present'), True)), Op('==', Reg('DCR::CBT'), True)), 'r'),
         Register('Debug', 'cp0.23.0', '', {'': [Field('DBD', Bits(31), 'Debug exception occurred in branch delay slot.', [Value('Not in delay slot', 0), Value('In delay slot', 1)]), Field('DM', Bits(30), '1 if the processor is operating in debug mode.', [Value('non-debug mode', 0), Value('debug mode', 1)]), Field('NoDCR', Bits(29), 'Reads 1 if this CPU does not have a dseg.', [Value('dseg is present', 0), Value('No dseg present', 1)]), Field('LSNM', Bits(28), "Set 1 to access kseg3 values 'behind' dseg addresses.", [Value('Load/stores in dseg address range goes to dseg', 0), Value('Load/stores in dseg address range goes to main memory', 1)]), Field('Doze', Bits(27), 'CPU was in a reduced power mode before debug exception.', [Value('Processor not in low power mode when debug exception occurred', 0), Value('Processor in low power mode when debug exception occurred', 1)]), Field('Halt', Bits(26), "CPU was 'asleep' before debug exception.", [Value('Internal system bus clock running', 0), Value('Internal system bus clock stopped', 1)]), Field('CountDM', Bits(25), 'Reads 1 if onchip counter continues to run in debug mode.', [Value('Count register stopped in debug mode', 0), Value('Count register is running in debug mode', 1)]), Field('IBusEP', Bits(24), 'Bus error on I-fetch while in debug mode.'), Field('MCheckP', Bits(23), "Invalid duplicate write into TLB ('machine check') while in debug mode."), Field('CacheEP', Bits(22), 'Cache parity error while in debug mode.'), Field('DBusEP', Bits(21), 'Bus error on D-fetch while in debug mode.'), Field('IEXI', Bits(20), 'Write 0 to notice imprecise exceptions in debug mode.'), Field('DDBSImpr', Bits(19), 'Imprecise store breakpoint.'), Field('DDBLImpr', Bits(18), 'Imprecise load breakpoint.'), Field('EJTAGver', Bits(17, 15), 'Version of EJTAG specification to which this implementation conforms.'), Field('DExcCode', Bits(14, 10), 'Cause of ordinary exception handled within debug mode.'), Field('NoSST', Bits(9), 'Reads 1 if single-step is not available in this implementation.'), Field('SSt', Bits(8), 'Set 1 to enable single-step.'), Field('Offline', Bits(7), 'Prevent TC from running in non-debug mode (for debugger). (MT only, zero otherwise)'), Field('DINT', Bits(5), 'Debug exception from probe (input pin or JTAG).', [Value('No debug interrupt exception', 0), Value('Debug interrupt exception', 1)]), Field('DIB', Bits(4), 'Hardware breakpoint on I-fetch.', [Value('No debug exception breakpoint', 0), Value('Debug exception breakpoint occurred', 1)]), Field('DDBS', Bits(3), '(Precise) hardware breakpoint on store.', [Value('No debug data exception on a store', 0), Value('Debug instruction exception on a store', 1)]), Field('DDBL', Bits(2), '(Precise) hardware breakpoint on load.', [Value('No debug data exception on a load', 0), Value('Debug instruction exception on a load', 1)]), Field('DBp', Bits(1), 'Debug exception from sddp or breakpoint.', [Value('No debug software breakpoint exception', 0), Value('Debug software breakpoint exception', 1)]), Field('DSS', Bits(0), 'Debug exception from single-step.', [Value('No debug single-step exception', 0), Value('Debug single-step exception', 1)])], 'M51[05]0': [Field('DBD', Bits(31), 'Debug exception occurred in branch delay slot.', [Value('Not in delay slot', 0), Value('In delay slot', 1)]), Field('DM', Bits(30), '1 if the processor is operating in debug mode.', [Value('non-debug mode', 0), Value('debug mode', 1)]), Field('NoDCR', Bits(29), 'Reads 1 if this CPU does not have a dseg.', [Value('dseg is present', 0), Value('No dseg present', 1)]), Field('LSNM', Bits(28), "Set 1 to access kseg3 values 'behind' dseg addresses.", [Value('Load/stores in dseg address range goes to dseg', 0), Value('Load/stores in dseg address range goes to main memory', 1)]), Field('Doze', Bits(27), 'CPU was in a reduced power mode before debug exception.', [Value('Processor not in low power mode when debug exception occurred', 0), Value('Processor in low power mode when debug exception occurred', 1)]), Field('Halt', Bits(26), "CPU was 'asleep' before debug exception.", [Value('Internal system bus clock running', 0), Value('Internal system bus clock stopped', 1)]), Field('CountDM', Bits(25), 'Reads 1 if onchip counter continues to run in debug mode.', [Value('Count register stopped in debug mode', 0), Value('Count register is running in debug mode', 1)]), Field('IBusEP', Bits(24), 'Bus error on I-fetch while in debug mode.'), Field('MCheckP', Bits(23), "Invalid duplicate write into TLB ('machine check') while in debug mode."), Field('CacheEP', Bits(22), 'Cache parity error while in debug mode.'), Field('DBusEP', Bits(21), 'Bus error on D-fetch while in debug mode.'), Field('IEXI', Bits(20), 'Write 0 to notice imprecise exceptions in debug mode.'), Field('DDBSImpr', Bits(19), 'Imprecise store breakpoint.'), Field('DDBLImpr', Bits(18), 'Imprecise load breakpoint.'), Field('EJTAGver', Bits(17, 15), 'Version of EJTAG specification to which this implementation conforms.'), Field('DExcCode', Bits(14, 10), 'Cause of ordinary exception handled within debug mode.'), Field('NoSST', Bits(9), 'Reads 1 if single-step is not available in this implementation.', [Value('Single-step feature available', 0), Value('No single-step feature available', 1)]), Field('SSt', Bits(8), 'Set 1 to enable single-step.', [Value('No debug single-step exception enabled', 0), Value('Debug single step exception enabled', 1)]), Field('DIBImpr', Bits(6), 'Indicates that an Imprecise debug instruction break exception occurred (due to a complex breakpoint). Cleared on exception in debug mode.'), Field('DINT', Bits(5), 'Debug exception from probe (input pin or JTAG).', [Value('No debug interrupt exception', 0), Value('Debug interrupt exception', 1)]), Field('DIB', Bits(4), 'Hardware breakpoint on I-fetch.', [Value('No debug exception breakpoint', 0), Value('Debug exception breakpoint occurred', 1)]), Field('DDBS', Bits(3), '(Precise) hardware breakpoint on store.', [Value('No debug data exception on a store', 0), Value('Debug instruction exception on a store', 1)]), Field('DDBL', Bits(2), '(Precise) hardware breakpoint on load.', [Value('No debug data exception on a load', 0), Value('Debug instruction exception on a load', 1)]), Field('DBp', Bits(1), 'Debug exception from sddp or breakpoint.', [Value('No debug software breakpoint exception', 0), Value('Debug software breakpoint exception', 1)]), Field('DSS', Bits(0), 'Debug exception from single-step.', [Value('No debug single-step exception', 0), Value('Debug single-step exception', 1)])]}, 'The Debug register is used to control the debug exception and provide information about the cause of the debug exception and when re-entering at the debug exception vector due to a normal exception in debug mode.  The read only information bits are updated every time the debug exception is taken or when a normal exception is taken when already in debug mode.', [], 32, Op('==', Reg('Config1::EP'), 1)),
         Register('Status', 'cp0.12.0', '', {'': [Field('CU3', Bits(31), 'Controls access to coprocessor 3.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU2', Bits(30), 'Controls access to coprocessor 2.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU1', Bits(29), 'Controls access to coprocessor 1.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU0', Bits(28), 'Controls access to coprocessor 0 in User Mode.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('RP', Bits(27), 'Enables reduced power mode.'), Field('FR', Bits(26), 'Floating Register. This bit is used to control the floating-point register mode for     64-bit floating point units:${p}     ${tab}0${tab}Floating point registers can contain any 32-bit data type. 64-bit data types are stored in even-odd pairs of registers.${nl}     ${tab}1${tab}Floating point registers can contain any datatype.${p}     This bit must be ignored on writes and read as zero under the following conditions:${p}     ${tab}*${tab}No floating point unit is implemented${nl}     ${tab}*${tab}64-bit floating point unit is not implemented${p}     If the core is equipped with an optional FPU, set this bit to 0 for     MIPS I compatibility mode, which allows for 16 real FP registers, with 16 odd     FP register numbers reserved for access to the high-order bits of double-precision     values.'), Field('RE', Bits(25), 'Used to enable reverse-endian memory references while the processor is running in user mode.'), Field('MX', Bits(24), 'DSP ASE Enable.  If DSP ASE hardware is present, this field is read/write.  If DSP ASE hardware is not present, this field is read-only.${p}Enables access to DSP ASE resources.  An attempt to execute any DSP ASE instruction before when this bit is 0 will cause a DSP State Disabled exception.'), Field('Reserved', Bits(23), 'Reserved.  This field is ignored on writes and reads as 0.'), Field('BEV', Bits(22), 'Controls the location of exception vectors.', [Value('Normal', 0), Value('Bootstrap', 1)]), Field('TS', Bits(21), 'TLB shutdown.'), Field('SR', Bits(20), 'Indicates that the entry through the reset exception vector was due to a Soft Reset.'), Field('NMI', Bits(19), 'Indicates that the entry through the reset exception vector was due to an NMI.', [Value('Not NMI (Reset, write to clear)', 0), Value('NMI (cannot write this value)', 1)]), Field('Reserved', Bits(18), 'Reserved.  Ignored on writes and reads as zero.'), Field('CEE', Bits(17), 'CorExtend Enable.'), Field('Reserved', Bits(16), 'Reserved.  Ignored on writes and reads as zero.'), Field('IM7-IM2', Bits(15, 10), 'Interrupt Mask (release 1).'), Field('IPL', Bits(15, 10), 'Interrupt Priority Level (release 2).'), Field('IM1-IM0', Bits(9, 8), 'Interrupt Mask (release 1).'), Field('Reserved', Bits(7, 5), 'Reserved.  This field is ignored on writes and reads as 0.'), Field('KSU', Bits(4, 3), 'If Supervisor Mode is implemented, the encoding of this field denotes the base operating mode of the processor.', [Value('Kernel Mode', 0), Value('Supervisor Mode', 1), Value('User Mode', 2), Value('Reserved', 3, '', True)]), Field('ERL', Bits(2), 'Error Level; Set by the processor when a Reset, Soft Reset, NMI or Cache Error exception are taken.', [Value('Normal Level', 0), Value('Error Level', 1)]), Field('EXL', Bits(1), 'Exception Level; Set by the processor when any exception other than Reset, Soft Reset, or NMI exceptions is taken.', [Value('Normal Level', 0), Value('Exception Level', 1)]), Field('IE', Bits(0), 'Interrupt Enable: Acts as the master enable for software and hardware interrupts.', [Value('Interrupts disabled', 0), Value('Interrupts enabled', 1)])], 'P6600.*,I6[45]00.*': [Field('CU3', Bits(31), 'Coprocessor 3 Usable.  Because no Multiprocessing System family core has a coprocessor 3, Status[CU3] is hardwired to zero.'), Field('CU2', Bits(30), "Controls access to coprocessor 2.  CU2 is reserved for a customer's coprocessor.  Currently the Multiprocessing System family of cores does not support Coprocessor 2, so this bit is read-only and reads zero.", [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU1', Bits(29), 'Controls access to coprocessor 1.  CU1 is most often used for a floating-point unit.  When no coprocessor 1 is present, this bit is read-only and reads zero.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('RW', Bits(28), 'Read/write field. This bit can be written by software without side-effects. A use      case is for the kernel to set this bit to signify that the exception condition is due      to user code, prior to saving Status to the stack in memory. This bit is not used in      the I6400/I6500 core.'), Field('FR', Bits(26), 'Floating Register.  This bit must be 1 to indicate that floating-point registers can contain any datatype.', [Value('Floating point registers can contain any datatype', 1)]), Field('MX', Bits(24), 'MIPS DSP Extension.  Enables access to DSP ASE resources.  An attempt to execute any DSP ASE instruction before this bit has been set to 1 will cause a DSP State Disabled exception.  The state of this bit is reflected in Config3[DSPP].', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('PX', Bits(23), 'Enables access to 64-bit operations in User mode without enabling 64-bit addressing.', [Value('64-bit operations are not enabled in User Mode', 0), Value('64-bit operations are enabled in User Mode', 1)]), Field('BEV', Bits(22), 'Boot Exception Vector.  Controls the location of exception vectors.${p}When set to 1, all exception entry points are relocated to near the reset start address.', [Value('Normal', 0), Value('Bootstrap', 1)]), Field('SR', Bits(20), 'Soft Reset.  The Multiprocessing System core only supports a full external reset, so this bit always reads zero.'), Field('NMI', Bits(19), 'Indicates that the entry through the reset exception vector was due to an NMI. Software can only write a 0 to this bit to clear it and cannot force a 0 to 1 transition.', [Value('Not NMI (Reset, write to clear)', 0), Value('NMI (cannot write this value)', 1)]), Field('IM7-IM0/IPL', Bits(15, 10), 'Hardware Interrupt Mask: Controls the enabling of each of the hardware interrupts in nonEIC      mode. An interrupt is taken if interrupts are enabled and the corresponding      bits are set in both the Interrupt Mask field of the Status register and the Interrupt      Pending field of the Cause register and the IE bit is set in the Status register.      This field is encoded as follows. Note that bit 10 of this field corresponds to      hardware interrupt 0, and bit 15 corresponds to hardware interrupt 5.${nl}${nl}      0: Interrupt requests are disabled.${nl}      1: Interrupt requests are enabled.${nl}${nl}      If EIC interrupt mode is enabled (Config3VEIC = 1), these bits take on a different      meaning and are interpreted as the IPL field, described below.${nl}${nl}      Interrupt Priority Level: When EIC mode is enabled, this field is the encoded      (0:63) value of the current IPL. An interrupt will be signaled only if the      requested IPL is higher than this value.      If EIC interrupt mode is not enabled (Config3VEIC = 0), these bits take on a different      meaning and are interpreted as the IM7:IM2 bits, described above.'), Field('IM1-IM0', Bits(9, 8), 'Interrupt Mask: Controls the enabling of each of the software interrupts. This      field is encoded as follows:${nl}${nl}      0: Interrupt request disabled.${nl}      1: Interrupt request enabled.${nl}${nl}      In EIC interrupt mode, the processor sends the state of the software interrupt      requests (CauseIP1:IP0) to the external interrupt controller, where it prioritizes      these interrupts in a system-dependent way with other hardware interrupts. This      allows the interrupt controller to be more specific or more general as a function      of the system environment and needs.      When EIC interrupt mode is enabled (Config3VEIC = 1), these bits are writable,      but have no effect on the interrupt system.'), Field('KX', Bits(7), 'Setting this bit enables the following:${p}       ${tab}(1) Access to 64-bit Kernel Segments${nl}       ${tab}(2) Use of the XTLB Refill Vector for references to Kernel Segments${p}      Clearing this bit causes the following:${p}       ${tab}(1) Disabled Access to 64-bit Kernel Segments${nl}       ${tab}(2) Use of the TLB Refill Vector for references to Kernel Segments', [Value('Access to 64-bit Kernel Segments is disabled', 0), Value('Access to 64-bit Kernel Segments is enabled', 1)]), Field('SX', Bits(6), 'Setting this bit enables the following:${p}      ${tab}(1) Access to 64-bit Supervisor Segments${nl}      ${tab}(2) Use of the XTLB Refill Vector for references to Supervisor Segments${p}     Clearing this bit causes the following:${p}      ${tab}(1) Disabled Access to 64-bit Supervisor Segments${nl}      ${tab}(2) Use of the TLB Refill Vector for references to Supervisor Segments     In the P6600 core, a write of 1 to this register is ignored when KX = 0.', [Value('Access to 64-bit Supervisor Segments is disabled', 0), Value('Access to 64-bit Supervisor Segments is enabled', 1)]), Field('UX', Bits(5), 'Setting this bit enables the following:${p}      ${tab}(1) Access to 64-bit User Segments${nl}      ${tab}(2) Use of the XTLB Refill Vector for references to User Segments${p}     Clearing this bit causes the following:${p}      ${tab}(1) Disabled Access to 64-bit User Segments${nl}      ${tab}(2) Use of the TLB Refill Vector for references to User Segments     In the P6600 core, a write of 1 to this register is ignored when KX = 0 or SX = 0.', [Value('Access to 64-bit User Segments is disabled', 0), Value('Access to 64-bit User Segments is enabled', 1)]), Field('KSU', Bits(4, 3), "These bits denote the processor's operating mode.${p}Note that the processor can also be in Kernel mode if ERL or EXL is set, regardless of the state of these bits.", [Value('Kernel Mode', 0), Value('Supervisor Mode', 1), Value('User Mode', 2), Value('Reserved', 3, '', True)]), Field('ERL', Bits(2), 'Error Level.  Set by the processor when a Reset, Soft Reset, NMI or Cache Error exception are taken.${p}When ERL is set:${nl} The processor is running in kernel mode${nl} Interrupts are disabled${nl} The ERET instruction will use the return address held in ErrorEPC instead of EPC${nl} The lower 2**29 bytes of kuseg are treated as an unmapped and uncached region.  This allows main memory to be accessed for cache errors.  The operation of the processor is UNDEFINED if the ERL bit is set while the processor is executing instructions from kuseg.', [Value('Normal Level', 0), Value('Error Level', 1)]), Field('EXL', Bits(1), 'Exception Level.  Set by the processor when any exception other than Reset, Soft Reset, or NMI exception is taken.${p}When EXL is set:${nl} The processor is running in Kernel Mode.${nl} Hardware and software interrupts are disabled.${nl} TLB Refill exceptions use the general exception vector instead of the TLB Refill vector.${nl} EPC, Cause[BD] and SRSCtl are not be updated if another exception is taken.${p}When an exception occurs and EXL is set, a nested TLB Refill exception is sent to the general exception handler (rather than to its dedicated handler) and the values in EPC, Cause[BD] and SRSCtl are not overwritten.  The result is that, after returning from the second exception, the processor jumps back to the code that was executing before the first exception occurred.', [Value('Normal Level', 0), Value('Exception Level', 1)]), Field('IE', Bits(0), 'Interrupt Enable.  Acts as the master enable for software and hardware interrupts.${p}This bit can be written using the di/ei instructions.', [Value('Interrupts disabled', 0), Value('Interrupts enabled', 1)])], 'interAptiv.*': [Field('CU3', Bits(31), 'Coprocessor 3 Usable. This is a per-VPE view of the TCStatus[TCU3] per-TC field.'), Field('CU2', Bits(30), 'Controls access to coprocessor 2.  This bit can only be written when a coprocessor 2 unit is present. This bit cannot be written and will read as 0 if coprocessor 2 unit is not present This is a per-VPE view of the TCStatus[TCU2] per-TC field.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU1', Bits(29), 'Controls access to coprocessor 1.  This bit can only be written when the Floating Point Unit is present. If no FPU is present, this bit cannot be written and will read as 0 This is a per-VPE view of the TCStatus[TCU1] per-TC field.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU0', Bits(28), 'Controls access to coprocessor 0 in User Mode.  Coprocessor 0 is always usable when the processor is running in kernel mode, independent of the state of the CU0 bit. This is a per-VPE view of the TCStatus[TCU0] per-TC field.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('RP', Bits(27), "Enables reduced power mode.  The state of the RP bit is visible on the CPU's external interface signal SI_RP.", [Value('Disable reduced power mode', 0), Value('Enable reduced power mode', 1)]), Field('FR', Bits(26), 'Floating Register.  This bit is used to control the floating-point register mode for 64-bit floating point units.${p}This bit must be ignored on write and read as zero under the following conditions  ${nl} No floating point unit is implemented  ${nl} 64-bit floating point unit is not implemented.${p}This is a per-VPE view of the TCStatus[TFR] per-TC field.', [Value('64-bit datatypes are stored in even-odd pairs of registers', 0), Value('Floating point registers can contain any datatype', 1)]), Field('RE', Bits(25), 'Reverse Endian.  Enables Reverse endianness for instructions that execute in User mode.  This feature is not supported in the interAptiv core and reads 0.'), Field('MX', Bits(24), 'MIPS Extension.  Enables access to DSP ASE resources.  An attempt to execute any DSP ASE instruction when this bit is 0 will cause a DSP State Disabled exception.  This is a per-VPE view of the TCStatus[TMX] per-TC field', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('BEV', Bits(22), 'Boot Exception Vector.  Controls the location of exception vectors.${p}When set to 1, all exception entry points are relocated to near the reset start address.', [Value('Normal', 0), Value('Bootstrap', 1)]), Field('TS', Bits(21), 'TLB shutdown.  Normally this bit would indicate that a machine check exception was taken due to a TLBWI or TLBWR that would have created conflicting TLB entries. However, with the MIPS MT ASE, multiple writes are not an error condition and the conflicting TLB write instruction is silently dropped without a machine check exception. This bit will always be 0.'), Field('SR', Bits(20), 'Soft Reset.  Indicates that the entry through the reset exception vector was due to a Soft Reset. Soft Reset is not supported on this processor and this bit is not writeable and will always read as 0.'), Field('NMI', Bits(19), 'Indicates that the entry through the reset exception vector was due to an NMI.${nl}Software can only write a 0 to this bit to clear it and cannot force a 0-1 transition.', [Value('Not NMI (Reset, write to clear)', 0), Value('NMI (cannot write this value)', 1)]), Field('CEE', Bits(17), 'CorExtend Enable.  This bit is sent to the CorExtend block to be used to enable the CorExtend block. The usage of this signal by a CorExtend block is implementation dependent. This bit is reserved if CorExtend is not present. This is a per-VPE view of the TCStatus[TCEE] per-TC field.'), Field('IM7-IM2', Bits(15, 10), 'Interrupt Mask/Interrupt Priority Level.  Controls the enabling of each of the hardware interrupts.  An interrupt is taken if interrupts are enabled and the corresponding bits are set in both the Interrupt Mask field of the Status register and the Interrupt Pending field of the Cause register and the IE bit is set in the Status register.${p}When EIC is enabled (Config3[VEIC] = 1), this field is the encoded (0:63) value of the current IPL. An interrupt will be signaled only if the requested IPL is higher than this value.'), Field('IM1-IM0', Bits(9, 8), 'Interrupt Mask.  Controls the enabling of each of the software interrupts when not in EIC interrupt mode.${p}In EIC interrupt mode, the processor sends the state of the software interrupt requests (Cause[IP1:IP0]), to the external interrupt controller, where it prioritizes these interrupts in a system-dependent way with other hardware interrupts. This allows the interrupt controller to be more specific or more general as a function of the system environment and needs. When EIC interrupt mode is enabled (Config3[VEIC] = 1), these bits are writable, but have no effect on the interrupt system.'), Field('KSU', Bits(4, 3), 'This field denotes the base operating mode of the processor.${p}Note that the processor can also be in Kernel mode if ERL or EXL is set, regardless of the state of these bits.${nl}This is a per-VPE view of the TCStatus[TKSU] per-TC field.', [Value('Kernel Mode', 0), Value('Supervisor Mode', 1), Value('User Mode', 2), Value('Reserved', 3, '', True)]), Field('ERL', Bits(2), 'Error Level.  Set by the processor when a Reset, Soft Reset, NMI or Cache Error exception is taken.${p}When ERL is set:${nl} The processor is running in kernel mode${nl} Interrupts are disabled${nl} The ERET instruction will use the return address held in ErrorEPC instead of EPC${nl} The lower 2**29 bytes of kuseg are treated as an unmapped and uncached region.  This allows main memory to be accessed in the presence of cache errors.  The operation of the processor is UNDEFINED if the ERL bit is set while the processor is executing instructions from kuseg.', [Value('Normal Level', 0), Value('Error Level', 1)]), Field('EXL', Bits(1), 'Exception Level.  Set by the processor when any exception other than Reset, Soft Reset, or NMI exceptions is taken.${p}When EXL is set:${nl} The processor is running in Kernel Mode.${nl} Interrupts are disabled.${nl} TLB Refill exceptions use the general exception vector instead of the TLB Refill vector.${nl} EPC, Cause[BD] and SRSCtl will not be updated if another exception is taken.', [Value('Normal Level', 0), Value('Exception Level', 1)]), Field('IE', Bits(0), 'Interrupt Enable.  Acts as the master enable for software and hardware interrupts.${p}This bit can be written using the di/ei instructions.', [Value('Interrupts disabled', 0), Value('Interrupts enabled', 1)])], 'M4K': [Field('CU3', Bits(31), 'Controls access to coprocessor 3.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU2', Bits(30), 'Controls access to coprocessor 2.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU1', Bits(29), 'Controls access to coprocessor 1.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU0', Bits(28), 'Controls access to coprocessor 0 in User Mode.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('RP', Bits(27), 'Enables reduced power mode.'), Field('FR', Bits(26), 'Floating Register.'), Field('RE', Bits(25), 'Used to enable reverse-endian memory references while the processor is running in user mode.'), Field('Reserved', Bits(24, 23), 'Reserved.  This field is ignored on writes and reads as 0.'), Field('BEV', Bits(22), 'Controls the location of exception vectors.', [Value('Normal', 0), Value('Bootstrap', 1)]), Field('TS', Bits(21), 'TLB shutdown.'), Field('SR', Bits(20), 'Indicates that the entry through the reset exception vector was due to a Soft Reset.', [Value('Not Soft Reset (NMI or Reset, write to clear)', 0), Value('NMI (cannot write this value)', 1)]), Field('NMI', Bits(19), 'Indicates that the entry through the reset exception vector was due to an NMI.', [Value('Not NMI (Soft Reset or Reset, write to clear)', 0), Value('NMI (cannot write this value)', 1)]), Field('CEE', Bits(17), 'CorExtend Enable.'), Field('IM7-IM2', Bits(15, 10), 'Interrupt Mask${nl}(When EIC mode is not enabled. See Config3[VEIC])'), Field('IPL', Bits(15, 10), 'Interrupt Priority Level${nl}(When EIC mode is enabled. See Config3[VEIC])'), Field('IM1-IM0', Bits(9, 8), 'Interrupt Mask (release 1).'), Field('UM', Bits(4), 'Base operating mode of the processor.', [Value('Kernel Mode', 0), Value('User Mode', 1)]), Field('ERL', Bits(2), 'Error Level; Set by the processor when a Reset, Soft Reset, NMI or Cache Error exception are taken.', [Value('Normal Level', 0), Value('Error Level', 1)]), Field('EXL', Bits(1), 'Exception Level; Set by the processor when any exception other than Reset, Soft Reset, or NMI exceptions is taken.', [Value('Normal Level', 0), Value('Exception Level', 1)]), Field('IE', Bits(0), 'Interrupt Enable: Acts as the master enable for software and hardware interrupts.', [Value('Interrupts disabled', 0), Value('Interrupts enabled', 1)])], 'proAptiv.*,P5600.*': [Field('CU3', Bits(31), 'Coprocessor 3 Usable.  Because no Multiprocessing System family core has a coprocessor 3, Status[CU3] is hardwired to zero.'), Field('CU2', Bits(30), "Controls access to coprocessor 2.  CU2 is reserved for a customer's coprocessor.  Currently the Multiprocessing System family of cores does not support Coprocessor 2, so this bit is read-only and reads zero.", [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU1', Bits(29), 'Controls access to coprocessor 1.  CU1 is most often used for a floating-point unit.  When no coprocessor 1 is present, this bit is read-only and reads zero.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU0', Bits(28), 'Controls access to coprocessor 0 in User Mode.  Coprocessor 0 is always usable when the processor is running in Kernel or Debug Mode, regardless of the state of the CU[0] bit.${p}Setting Status[CU0] to 1 has the effect of allowing privileged instructions to execute in user mode, although this is not something a secure OS is likely to allow.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('RP', Bits(27), "Enables reduced power mode.  The state of the RP bit is visible on the CPU's external interface signal SI_RP.", [Value('Disable reduced power mode', 0), Value('Enable reduced power mode', 1)]), Field('FR', Bits(26), 'Floating Register.  This bit is used to control the floating-point register mode for 64-bit floating point units.${p}This bit must be ignored on write and read as zero under the following conditions  ${nl} No floating point unit is implemented  ${nl} 64-bit floating point unit is not implemented${p}If the core is equipped with an optional FPU, set this bit to 0 for MIPS I compatibility mode, which allows for 16 even FP registers, with 16 odd FP register numbers reserved for access to the high-order bits of double-precision values.', [Value('64-bit datatypes are stored in even-odd pairs of registers', 0), Value('Floating point registers can contain any datatype', 1)]), Field('RE', Bits(25), 'Reverse Endian.  Enables Reverse endianness for instructions that execute in User mode.  This feature is not supported in the Multiprocessing System core and reads 0.'), Field('MX', Bits(24), 'MIPS Extension.  Enables access to DSP ASE resources.  An attempt to execute any DSP ASE instruction before this bit has been set to 1 will cause a DSP State Disabled exception.  The state of this bit is reflected in Config3[DSPP].', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('BEV', Bits(22), 'Boot Exception Vector.  Controls the location of exception vectors.${p}When set to 1, all exception entry points are relocated to near the reset start address.', [Value('Normal', 0), Value('Bootstrap', 1)]), Field('TS', Bits(21), "TLB shutdown.  This bit is set by hardware if software attempts to create a duplicate TLB entry (which will also produce a 'machine check' exception).  It can be cleared to zero by software, but can never set to 1.${p}The id of the field originated as a 'TLB Shutdown'.  Historically, MIPS CPUs stop translating addresses when they detected invalid TLB operations."), Field('SR', Bits(20), 'Soft Reset.  The Multiprocessing System core only supports a full external reset, so this bit always reads zero.'), Field('NMI', Bits(19), 'Indicates that the entry through the reset exception vector was due to an NMI. Software can only write a 0 to this bit to clear it and cannot force a 0 to 1 transition.', [Value('Not NMI (Reset, write to clear)', 0), Value('NMI (cannot write this value)', 1)]), Field('CEE', Bits(17), "CorExtend Enable.  Enable/disable CorExtend User Defined Instructions (UDIs).${p}This signal's usage by a CorExtend block is implementation-dependent.  The presence of the CorExtend extension is indicated in Config[UDI], which is set when the core is configured.  This bit is reserved if CorExtend is not present."), Field('IM7-IM0', Bits(15, 8), "Interrupt Mask.  Bitwise interrupt enables for the eight interrupt conditions.  The state of these bits is visible in Cause[IP7-0], except in EIC mode.${p}External Interrupt Controller (EIC) mode is activated when the Config3[VEIC] is set by hardware at reset based on the state of the SI_EICPresent signal.  If this bit is set by hardware, software should set the Cause[IV] bit, then write a non-zero 'vector spacing' in the VS bit of the IntCtl register.${p}In EIC mode, IM7-2 is used as a 6-bit Status[IPL] (Interrupt Priority Level) field.  An interrupt is only triggered when the interrupt controller presents an interrupt code which is numerically higher than the current value of Status[IPL].${p}Status[IM1-0] always acts as a bitwise mask for the two software interrupt bits programmable in Cause[IP1-0]."), Field('KSU', Bits(4, 3), "These bits denote the processor's operating mode.${p}Note that the processor can also be in Kernel mode if ERL or EXL is set, regardless of the state of these bits.", [Value('Kernel Mode', 0), Value('Supervisor Mode', 1), Value('User Mode', 2), Value('Reserved', 3, '', True)]), Field('ERL', Bits(2), 'Error Level.  Set by the processor when a Reset, Soft Reset, NMI or Cache Error exception are taken.${p}When ERL is set:${nl} The processor is running in kernel mode${nl} Interrupts are disabled${nl} The ERET instruction will use the return address held in ErrorEPC instead of EPC${nl} The lower 2**29 bytes of kuseg are treated as an unmapped and uncached region.  This allows main memory to be accessed for cache errors.  The operation of the processor is UNDEFINED if the ERL bit is set while the processor is executing instructions from kuseg.', [Value('Normal Level', 0), Value('Error Level', 1)]), Field('EXL', Bits(1), 'Exception Level.  Set by the processor when any exception other than Reset, Soft Reset, or NMI exception is taken.${p}When EXL is set:${nl} The processor is running in Kernel Mode.${nl} Hardware and software interrupts are disabled.${nl} TLB Refill exceptions use the general exception vector instead of the TLB Refill vector.${nl} EPC, Cause[BD] and SRSCtl are not be updated if another exception is taken.${p}When an exception occurs and EXL is set, a nested TLB Refill exception is sent to the general exception handler (rather than to its dedicated handler) and the values in EPC, Cause[BD] and SRSCtl are not overwritten.  The result is that, after returning from the second exception, the processor jumps back to the code that was executing before the first exception occurred.', [Value('Normal Level', 0), Value('Exception Level', 1)]), Field('IE', Bits(0), 'Interrupt Enable.  Acts as the master enable for software and hardware interrupts.${p}This bit can be written using the di/ei instructions.', [Value('Interrupts disabled', 0), Value('Interrupts enabled', 1)])], 'M14K.*,M51.*': [Field('CU3', Bits(31), 'Controls access to coprocessor 3.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU2', Bits(30), 'Controls access to coprocessor 2.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU1', Bits(29), 'Controls access to coprocessor 1.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('CU0', Bits(28), 'Controls access to coprocessor 0 in User Mode.', [Value('Access not allowed', 0), Value('Access allowed', 1)]), Field('RP', Bits(27), 'Enables reduced power mode.'), Field('FR', Bits(26), 'Floating Register. This bit is used to control the floating-point register mode for     64-bit floating point units:${p}     ${tab}0${tab}Floating point registers can contain any 32-bit data type. 64-bit data types are stored in even-odd pairs of registers.${nl}     ${tab}1${tab}Floating point registers can contain any datatype.${p}     This bit must be ignored on writes and read as zero under the following conditions:${p}     ${tab}*${tab}No floating point unit is implemented${nl}     ${tab}*${tab}64-bit floating point unit is not implemented${p}     If the core is equipped with an optional FPU, set this bit to 0 for     MIPS I compatibility mode, which allows for 16 real FP registers, with 16 odd     FP register numbers reserved for access to the high-order bits of double-precision     values.'), Field('RE', Bits(25), 'Used to enable reverse-endian memory references while the processor is running in user mode.'), Field('MX', Bits(24), 'DSP ASE Enable.  If DSP ASE hardware is present, this field is read/write.  If DSP ASE hardware is not present, this field is read-only.${p}Enables access to DSP ASE resources.  An attempt to execute any DSP ASE instruction before when this bit is 0 will cause a DSP State Disabled exception.'), Field('Reserved', Bits(23), 'Reserved.  This field is ignored on writes and reads as 0.'), Field('BEV', Bits(22), 'Controls the location of exception vectors.', [Value('Normal', 0), Value('Bootstrap', 1)]), Field('TS', Bits(21), 'TLB shutdown. (Write 0 to clear)${nl}This bit is only used in the TLB-based MMU processors and is reserved in the FM-based MMU processors.'), Field('SR', Bits(20), 'Indicates that the entry through the reset exception vector was due to a Soft Reset.', [Value('Not Soft Reset (NMI or Reset, write to clear)', 0), Value('NMI (cannot write this value)', 1)]), Field('NMI', Bits(19), 'Indicates that the entry through the reset exception vector was due to an NMI.', [Value('Not NMI (Soft Reset or Reset, write to clear)', 0), Value('NMI (cannot write this value)', 1)]), Field('IM9', Bits(18), 'IM9 or IPL bit 8.'), Field('CEE', Bits(17), 'CorExtend Enable.'), Field('IM8-IM2', Bits(16, 10), 'Interrupt Mask${nl}(When EIC mode is not enabled. See Config3[VEIC])'), Field('IPL', Bits(16, 10), 'Interrupt Priority Level${nl}(When EIC mode is enabled. See Config3[VEIC])'), Field('IM1-IM0', Bits(9, 8), 'Interrupt Mask (release 1).'), Field('Reserved', Bits(7, 5), 'Reserved.  This field is ignored on writes and reads as 0.'), Field('UM', Bits(4), 'Base operating mode of the processor.', [Value('Kernel Mode', 0), Value('User Mode', 1)]), Field('Reserved', Bits(3), 'This bit is reserved.  This bit is ignored on writes and reads as zero.'), Field('ERL', Bits(2), 'Error Level; Set by the processor when a Reset, Soft Reset, NMI or Cache Error exception are taken.', [Value('Normal Level', 0), Value('Error Level', 1)]), Field('EXL', Bits(1), 'Exception Level; Set by the processor when any exception other than Reset, Soft Reset, or NMI exceptions is taken.', [Value('Normal Level', 0), Value('Exception Level', 1)]), Field('IE', Bits(0), 'Interrupt Enable: Acts as the master enable for software and hardware interrupts.', [Value('Interrupts disabled', 0), Value('Interrupts enabled', 1)])]}, 'The Status register is a read/write register that contains the operating mode, interrupt enabling, and the diagnostic states of the processor.  Fields of this register combine to create operating modes for the processor.'),
         Register('PRId', 'cp0.15.0', '', {'': [Field('CoOpt', Bits(31, 24), 'Company Option.  Should be a number between 0 and 127 higher values are reserved by MIPS Tech, LLC.'), Field('CoID', Bits(23, 16), 'Company ID.  Identifies the company that designed or manufactured the processor.'), Field('ProcID', Bits(15, 8), 'Processor ID.  Identifies the type of processor.  This field allows software to distinguish between the various types of processors.', [Value('4Kc', 128), Value('5Kc/5Kf', 129), Value('20Kc', 130), Value('4Kp/4Km', 131), Value('4KEc', 132), Value('4KEp/4KEm', 133), Value('4KSc', 134), Value('M4K', 135), Value('25Kf', 136), Value('5KEf/5KEc', 137), Value('4KEp/4KEm', 145), Value('4KSd', 146), Value('24Kf/24Kc', 147), Value('34Kf/34Kc', 149), Value('24KEf/24KEc', 150), Value('74Kf/74Kc', 151), Value('1004K', 153), Value('1074K', 154), Value('M14K', 155), Value('M14Kc', 156), Value('M14KE', 157), Value('M14KEc', 158), Value('interAptivUP', 160), Value('interAptivMP', 161), Value('proAptivUP', 162), Value('proAptivMP', 163), Value('P6600', 164), Value('M5100', 166), Value('M5150', 167), Value('P5600', 168), Value('I6400', 169), Value('I6500', 176)]), Field('Major Revision', Bits(7, 5), 'CPU major revision level.'), Field('Minor Revision', Bits(4, 2), 'CPU minor revision level.'), Field('Patch Level', Bits(1, 0), 'CPU patch revision level.')]}, 'The Processor Identification (PRId) register is a 32 bit read-only register that contains information identifying the manufacturer, manufacturer options, processor identification and revision level of the processor.', [], 32, True, 'r'),
         Register('MMID', 'cp0.4.5', '', {}, "Memory Map Identifier.${p}                 This field is written by hardware on a TLB read and by software to establish the current MemoryMapID value for TLB write and against which TLB references match each entry's TLB MemoryMapID field.", [], 32, CPUNameMatches('I6[45]00.*')),
         Register('IntCtl', 'cp0.12.1', '', {'': [Field('IPTI', Bits(31, 29), 'Counter/timer interrupt number.', [Value('HW0', 2), Value('HW1', 3), Value('HW2', 4), Value('HW3', 5), Value('HW4', 6), Value('HW5', 7)]), Field('IPPCI', Bits(28, 26), 'Performance counter overflow interrupt number.', [Value('HW0', 2), Value('HW1', 3), Value('HW2', 4), Value('HW3', 5), Value('HW4', 6), Value('HW5', 7)]), Field('IPFDCI', Bits(25, 23), 'Fast Debug Channel interrupt number.', [Value('HW0', 2), Value('HW1', 3), Value('HW2', 4), Value('HW3', 5), Value('HW4', 6), Value('HW5', 7)]), Field('VS', Bits(9, 5), 'Vector spacing.', [Value('0', 0), Value('32', 1), Value('64', 2), Value('128', 4), Value('256', 8), Value('512', 16)])], 'proAptiv.*,P5600.*,interAptiv.*,I6[45]00.*,P6600.*': [Field('IPTI', Bits(31, 29), 'For Interrupt Compatibility and Vectored Interrupt modes, this field specifies the IP number to which the Timer Interrupt request is merged, and allows software to determine whether to consider Cause[TI] for a potential interrupt.${p}The value of this bit is set by the static input, SI_IPTI[2:0].  This allows external logic to communicate the specific SI_Int hardware interrupt pin to which the SI_TimerInt signal is attached.${p}The value of this field is not meaningful if External Interrupt Controller Mode is enabled.  The external interrupt controller is expected to provide this information for that interrupt mode.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('HW0', 2), Value('HW1', 3), Value('HW2', 4), Value('HW3', 5), Value('HW4', 6), Value('HW5', 7)]), Field('IPPCI', Bits(28, 26), 'For Interrupt Compatibility and Vectored Interrupt modes, this field specifies the IP number to which the Performance Counter Interrupt request is merged, and allows software to determine whether to consider Cause[PCI] for a potential interrupt.${p}The value of this bit is set by the static input SI_IPPCI[2:0].  This allows external logic to communicate the specific SI_Int hardware interrupt pin to which the SI_PCInt signal is attached.${p}The value of this field is not meaningful if External Interrupt Controller Mode is enabled.  The external interrupt controller is expected to provide this information for that interrupt mode.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('HW0', 2), Value('HW1', 3), Value('HW2', 4), Value('HW3', 5), Value('HW4', 6), Value('HW5', 7)]), Field('IPFDCI', Bits(25, 23), 'For Interrupt Compatibility and Vectored Interrupt modes, this field specifies the IP number to which the Fast Debug Channel Interrupt request is merged, and allows software to determine whether to consider Cause[FDCI] for a potential interrupt.${p}The value of this bit is set by the static input, SI_IPFDCI[2:0].  This allows external logic to communicate the specific SI_Int hardware interrupt pin to which the SI_FDC[Int] signal is attached.${p}The value of this field is not meaningful if External Interrupt Controller Mode is enabled.  The external interrupt controller is expected to provide this information for that interrupt mode.', [Value('Reserved', 0), Value('Reserved', 1), Value('HW0', 2), Value('HW1', 3), Value('HW2', 4), Value('HW3', 5), Value('HW4', 6), Value('HW5', 7)]), Field('0', Bits(22, 10), 'Reserved.  Must be written as zero; returns zero on read.'), Field('VS', Bits(9, 5), 'Vector spacing.  If vectored interrupts are implemented (as denoted by Config3[VInt] or Config3[VEIC]), this field specifies the spacing between vectored interrupts.', [Value('0', 0), Value('32', 1), Value('64', 2), Value('128', 4), Value('256', 8), Value('512', 16)]), Field('0', Bits(4, 0), 'Reserved.  Must be written as zero; returns zero on read.')], 'M51[05]0': [Field('IPTI', Bits(31, 29), 'For Interrupt Compatibility and Vectored Interrupt modes, this field specifies the IP number to which the Timer Interrupt request is merged, and allows software to determine whether to consider Cause[TI] for a potential interrupt.${p}The value of this bit is set by the static input, SI_IPTI[2:0].  This allows external logic to communicate the specific SI_Int hardware interrupt pin to which the SI_TimerInt signal is attached.${p}The value of this field is not meaningful if External Interrupt Controller Mode is enabled.  The external interrupt controller is expected to provide this information for that interrupt mode.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('HW0', 2), Value('HW1', 3), Value('HW2', 4), Value('HW3', 5), Value('HW4', 6), Value('HW5', 7)]), Field('IPPCI', Bits(28, 26), 'For Interrupt Compatibility and Vectored Interrupt modes, this field specifies the IP number to which the Performance Counter Interrupt request is merged, and allows software to determine whether to consider Cause[PCI] for a potential interrupt.${p}The value of this bit is set by the static input SI_IPPCI[2:0].  This allows external logic to communicate the specific SI_Int hardware interrupt pin to which the SI_PCInt signal is attached.${p}The value of this field is not meaningful if External Interrupt Controller Mode is enabled.  The external interrupt controller is expected to provide this information for that interrupt mode.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('HW0', 2), Value('HW1', 3), Value('HW2', 4), Value('HW3', 5), Value('HW4', 6), Value('HW5', 7)]), Field('IPFDC', Bits(25, 23), 'For Interrupt Compatibility and Vectored Interrupt modes, this field specifies the IP number to which the Fast Debug Channel Interrupt request is merged, and allows software to determine whether to consider Cause[FDCI] for a potential interrupt.${p}The value of this bit is set by the static input, SI_IPFDCI[2:0].  This allows external logic to communicate the specific SI_Int hardware interrupt pin to which the SI_FDC[Int] signal is attached.${p}The value of this field is not meaningful if External Interrupt Controller Mode is enabled.  The external interrupt controller is expected to provide this information for that interrupt mode.', [Value('Reserved', 0), Value('Reserved', 1), Value('HW0', 2), Value('HW1', 3), Value('HW2', 4), Value('HW3', 5), Value('HW4', 6), Value('HW5', 7)]), Field('PF', Bits(22), 'Enables Vector Prefetching Feature.', [Value('Vector Prefetching disabled.', 0), Value('Vector Prefetching enabled.', 1)]), Field('ICE', Bits(21), 'For IRET instruction. Enables Interrupt Chaining.', [Value('Interrupt Chaining disabled.', 0), Value('Interrupt Chaining enabled.', 1)]), Field('StkDec', Bits(20, 16), 'For Auto-Prologue feature. This is the number of 4-byte words that is decremented from the value of GPR29.'), Field('ClrEXL', Bits(15), 'For Auto-Prologue feature and IRET instruction. If set, during Auto-Prologue and IRET interrupt chaining,the KSU/ERL/EXL fields are cleared.', [Value('Fields are not cleared by these operations.', 0), Value('Fields are cleared by these operations.', 1)]), Field('APE', Bits(14), 'Enables Auto-Prologue feature.', [Value('Auto-Prologue disabled.', 0), Value('Auto-Prologue enabled.', 1)]), Field('UseKStk', Bits(13), 'Chooses which Stack to use during Interrupt Automated Prologue.', [Value('Copy $29 of the Previous SRS to the Current SRS at the beginning of IAP.', 0), Value('Use $29 of the Current SRS at the beginning of IAP.', 1)]), Field('0', Bits(12, 10), 'Reserved.  Must be written as zero; returns zero on read.'), Field('VS', Bits(9, 5), 'Vector spacing.  If vectored interrupts are implemented (as denoted by Config3[VInt] or Config3[VEIC]), this field specifies the spacing between vectored interrupts.', [Value('0', 0), Value('32', 1), Value('64', 2), Value('128', 4), Value('256', 8), Value('512', 16)]), Field('0', Bits(4, 0), 'Reserved.  Must be written as zero; returns zero on read.')]}, 'Used to find out about interrupt wiring, and to set the "stride" for interrupt entry points in vectored-interrupt modes.', [], 32, Op('gte', Reg('Config::AR'), 1)),
         Register('DebugContextID', 'cp0.4.4', '', {}, 'The Debug Context ID register can be written to by instrumented code in the OS to set the value to the new PID (process ID) or RTOS Task ID.', [], 32, CPUNameMatches('I6[45]00.*')),
         Register('Config7iAMr2', 'cp0.16.7', 'Config7', {'interAptiv.*': [Field('WII', Bits(31), "Wait IE/IXMT Ignore: Indicates that this processor will allow an interrupt to     unblock a WAIT instruction even if IE or IXMT is preventing the interrupt from     being taken. This avoids problems using the WAIT instruction for 'bottom half'     interrupt servicing."), Field('Reserved', Bits(30, 24), 'These bits are unused and should be written as 0.'), Field('MCRO', Bits(23), 'Indicates that SAVE/RESTORE macro instructions are available as MIPS32 CorExtend opcodes.'), Field('CP', Bits(22), 'Indicates that COPYW/UCOPYW ASMACRO instructions are supported.'), Field('RAMSlp', Bits(21), 'RAM sleep. Setting to 1 disables RAM sleep modes by preventing the sleep     input to the L1 cache RAMs from being asserted.'), Field('NCWB', Bits(20), 'Non-Coherent Writeback.  When set, HitWB cacheops to a non-coherent address are written using a non-coherent CCA.'), Field('PCT', Bits(19), 'Performance Counters per TC.  This bit indicates to software that the performance counter registers are instantiated per TC rather than per processor.${p}This bit is implemented per-processor.'), Field('HCI', Bits(18), 'Hardware Cache Initialization.  Hardware sets this bit to indicate that a cache does not require initialization by software.  This bit will most likely only be set on simulation-only cache models and not on real hardware.'), Field('FPR', Bits(17), 'Floating Point Ratio.  Indicates clock ratio between integer CPU and floating point unit on interAptiv CPUs. Reads as 0 on interAptiv CPUs.${p}This bit is implemented per-processor.', [Value('FP clock frequency is the same as the integer clock', 0), Value('FP clock frequency is one-half the integer clock', 1)]), Field('AR', Bits(16), 'Alias removed. Hardware sets this bit to indicate that the L1 data cache is configured     to avoid cache aliases.'), Field('Reserved', Bits(15, 13), 'Reserved.  Write as zero.  Ignored on reads.'), Field('ICWP', Bits(12), 'Instruction cache way prediction. Setting this bit disables instruction cache way prediction.'), Field('BUSSlp', Bits(11), 'Bus sleep mode. Setting to 1 prevents the core from going to sleep while bus requests are pending.'), Field('IAR', Bits(10), 'Indicates that the interAptiv core has hardware support to remove instruction     cache aliasing. The virtual aliasing hardware can be disabled via the IVAD bit     described below.'), Field('IVAD', Bits(9), 'Instruction Virtual Aliasing disabled.  The hardware required to resolve instruction cache virtual alising is always present in the interAptiv core as noted by the defualt state of the IAR bit shown above.  However, software can the IVAD bit to enable or disable the virtual aliasing hardware for the instruction cache.${p}Setting this bit disables the hardware alias removal on the instruction cache.  If this bit is cleared, the CACHE Hit Invalidate and SYNCI instructions look up all possible aliased locations and invalidate the given cache line in all of them. This bit is Read-only if IAR = 0.     This bit is implemented per-VPE.'), Field('ES', Bits(8), "Externalize sync.  If this bit is set, and if the downstream device (toward memory) is capable of accepting SYNCs (indicated by the pin SI_SyncTxEn), the sync instruction causes a SYNC-specific transaction to go out on the external bus.  If this bit is cleared or if SI_SyncTxEn is deasserted, no transaction will go out, but all SYNC handling internal to the CPU will nevertheless be performed.${p}The sync instruction is signalled on the CPU's OCP interface as an ordering barrier transaction.  The transaction is an extension to the OCP standards, and system controllers which don't support it typically under-decode it as a read from the boot ROM area.  But that's going to be quite slow, so set this bit only if your system understands the synchronizing transaction.${p}When this bit is read, the value returned depends on the state of the SI_SyncTxEn pin.  If SI_SyncTxEn is 0, a value of 0 is returned.  If SI_SyncTxEn is 1, the value returned is the last value that was written to this bit."), Field('BTLM', Bits(7), 'Block TC on Load Miss: Setting this bit will cause a TC to be suspended once a     load miss has been detected, rather than waiting for a dependent instruction to     try to access the load data. This can increase pipeline utilization and provide     fairer allocation of miss resources, but does limit the parallel servicing of cache     misses from a single TC.  This bit is implemented per-processor.'), Field('CPOOO', Bits(6), 'Out-of-order data return on the Coprocessor interfaces: Writing 1 to this bit disables     the out-of-order data return for the FPU and COP2.'), Field('NBLSU', Bits(5), 'Non-Blocking LSU: Writing 1 to this field will lock the LSU and ALU pipelines     together. This forces LSU pipeline stalls to also stall the ALU pipeline.     This bit is implemented per-processor.'), Field('ULB', Bits(4), 'Uncached load blocking.  Set to 1 to make all uncached loads blocking (a program usually only blocks when it uses the data which is loaded).'), Field('BP', Bits(3), 'Branch prediction.  When set, no branch prediction is done, and all branches and jump stall as above.'), Field('RPS', Bits(2), 'Return prediction stack.  When set, the return address branch predictor is disabled, so jr $31 is treated just like any other jump register.  An instruction fetch stalls after the branch delay slot, until the jump instruction reaches the EC stage in the AGEN pipeline and can provide the right address.'), Field('BHT', Bits(1), "Branch history table.  When set, the branch history table is disabled and all branches are predicted taken.  This bit is don't care if Config7[BP] is set."), Field('SL', Bits(0), 'When set, non-blocking loads are disabled.  Normally the interAptiv core continues to after a load instruction, even if it misses in the D-cache, until the data is used.  When this bit is set, the CPU stalls on any D-cache load miss.')]}, "This register controls machine-specific features of the interAptiv core. A few of them are for hardware interface   adaptation, but most are for chip or system test only. They default to a 'safe' value. Most software, including bootstrap   software, can and should ignore these registers unless specifically advised to use them.", [], 32, And(CPUNameMatches('interAptiv.*'), Op('and', Reg('Config1'), 48), Op('and', Reg('Config5'), 16384))),
         Register('Config7iAMr1', 'cp0.16.7', 'Config7', {'interAptiv.*': [Field('WII', Bits(31), "Wait IE/IXMT Ignore: Indicates that this processor will allow an interrupt to     unblock a WAIT instruction even if IE or IXMT is preventing the interrupt from     being taken. This avoids problems using the WAIT instruction for 'bottom half'     interrupt servicing."), Field('Reserved', Bits(30, 22), 'These bits are unused and should be written as 0.'), Field('RAMSlp', Bits(21), 'RAM sleep. Setting to 1 disables RAM sleep modes by preventing the sleep     input to the L1 cache RAMs from being asserted.'), Field('NCWB', Bits(20), 'Non-Coherent Writeback.  When set, HitWB cacheops to a non-coherent address are written using a non-coherent CCA.'), Field('PCT', Bits(19), 'Performance Counters per TC.  This bit indicates to software that the performance counter registers are instantiated per TC rather than per processor.${p}This bit is implemented per-processor.'), Field('HCI', Bits(18), 'Hardware Cache Initialization.  Hardware sets this bit to indicate that a cache does not require initialization by software.  This bit will most likely only be set on simulation-only cache models and not on real hardware.'), Field('FPR', Bits(17), 'Floating Point Ratio.  Indicates clock ratio between integer CPU and floating point unit on interAptiv CPUs. Reads as 0 on interAptiv CPUs.${p}This bit is implemented per-processor.', [Value('FP clock frequency is the same as the integer clock', 0), Value('FP clock frequency is one-half the integer clock', 1)]), Field('AR', Bits(16), 'Alias removed. Hardware sets this bit to indicate that the L1 data cache is configured     to avoid cache aliases.'), Field('Reserved', Bits(15, 13), 'Reserved.  Write as zero.  Ignored on reads.'), Field('ICWP', Bits(12), 'Instruction cache way prediction. Setting this bit disables instruction cache way prediction.'), Field('BUSSlp', Bits(11), 'Bus sleep mode. Setting to 1 prevents the core from going to sleep while bus requests are pending.'), Field('IAR', Bits(10), 'Indicates that the interAptiv core has hardware support to remove instruction     cache aliasing. The virtual aliasing hardware can be disabled via the IVAD bit     described below.'), Field('IVAD', Bits(9), 'Instruction Virtual Aliasing disabled.  The hardware required to resolve instruction cache virtual alising is always present in the interAptiv core as noted by the defualt state of the IAR bit shown above.  However, software can the IVAD bit to enable or disable the virtual aliasing hardware for the instruction cache.${p}Setting this bit disables the hardware alias removal on the instruction cache.  If this bit is cleared, the CACHE Hit Invalidate and SYNCI instructions look up all possible aliased locations and invalidate the given cache line in all of them. This bit is Read-only if IAR = 0.     This bit is implemented per-VPE.'), Field('ES', Bits(8), "Externalize sync.  If this bit is set, and if the downstream device (toward memory) is capable of accepting SYNCs (indicated by the pin SI_SyncTxEn), the sync instruction causes a SYNC-specific transaction to go out on the external bus.  If this bit is cleared or if SI_SyncTxEn is deasserted, no transaction will go out, but all SYNC handling internal to the CPU will nevertheless be performed.${p}The sync instruction is signalled on the CPU's OCP interface as an ordering barrier transaction.  The transaction is an extension to the OCP standards, and system controllers which don't support it typically under-decode it as a read from the boot ROM area.  But that's going to be quite slow, so set this bit only if your system understands the synchronizing transaction.${p}When this bit is read, the value returned depends on the state of the SI_SyncTxEn pin.  If SI_SyncTxEn is 0, a value of 0 is returned.  If SI_SyncTxEn is 1, the value returned is the last value that was written to this bit."), Field('BTLM', Bits(7), 'Block TC on Load Miss: Setting this bit will cause a TC to be suspended once a     load miss has been detected, rather than waiting for a dependent instruction to     try to access the load data. This can increase pipeline utilization and provide     fairer allocation of miss resources, but does limit the parallel servicing of cache     misses from a single TC.  This bit is implemented per-processor.'), Field('CPOOO', Bits(6), 'Out-of-order data return on the Coprocessor interfaces: Writing 1 to this bit disables     the out-of-order data return for the FPU and COP2.'), Field('NBLSU', Bits(5), 'Non-Blocking LSU: Writing 1 to this field will lock the LSU and ALU pipelines     together. This forces LSU pipeline stalls to also stall the ALU pipeline.     This bit is implemented per-processor.'), Field('ULB', Bits(4), 'Uncached load blocking.  Set to 1 to make all uncached loads blocking (a program usually only blocks when it uses the data which is loaded).'), Field('BP', Bits(3), 'Branch prediction.  When set, no branch prediction is done, and all branches and jump stall as above.'), Field('RPS', Bits(2), 'Return prediction stack.  When set, the return address branch predictor is disabled, so jr $31 is treated just like any other jump register.  An instruction fetch stalls after the branch delay slot, until the jump instruction reaches the EC stage in the AGEN pipeline and can provide the right address.'), Field('BHT', Bits(1), "Branch history table.  When set, the branch history table is disabled and all branches are predicted taken.  This bit is don't care if Config7[BP] is set."), Field('SL', Bits(0), 'When set, non-blocking loads are disabled.  Normally the interAptiv core continues to after a load instruction, even if it misses in the D-cache, until the data is used.  When this bit is set, the CPU stalls on any D-cache load miss.')]}, "This register controls machine-specific features of the interAptiv core. A few of them are for hardware interface   adaptation, but most are for chip or system test only. They default to a 'safe' value. Most software, including bootstrap   software, can and should ignore these registers unless specifically advised to use them.", [], 32, And(CPUNameMatches('interAptiv.*'), Op('and', Reg('Config1'), 48), Not(Op('and', Reg('Config5'), 16384)))),
         Register('Config7', 'cp0.16.7', '', {'': [Field('WII', Bits(31), 'Reads 1 if wait terminates on a "disabled" interrupt.'), Field('HCI', Bits(18), 'Do not initialize caches (simulated CPUs only).'), Field('FPR', Bits(17), 'Half-speed FPU.'), Field('AR', Bits(16), 'Indicates that the D-cache is configured to avoid cache aliases.'), Field('IAR', Bits(10), 'Instruction Alias Removed.'), Field('IVA', Bits(9), 'Instruction Virtual Aliasing disabled.'), Field('ES', Bits(8), "Write 1 to get 'sync' instructions signalled on OCP interface."), Field('CPOOO', Bits(6), '1 for all CP data transfers to be strictly in program order.'), Field('NBLSU', Bits(5), 'Write 1 to stop whole CPU when load/store is pending.'), Field('ULB', Bits(4), 'Write 1 to make all uncached loads blocking.'), Field('BP', Bits(3), 'Write 1 to disable all branch prediction.'), Field('RPS', Bits(2), 'When set, the return address branch predictor is disabled, so jr $31 is treated just like any other jump register.  Instruction fetch stalls after the branch delay slot, until the jump instruction reaches the "EC" stage in the pipeline and can provide the right address.'), Field('BHT', Bits(1), "When set, the branch history table is disabled and all branches are predicted taken.  This bit is don't care if Config7[BP] is set."), Field('SL', Bits(0), 'Write 1 to disable all non-blocking loads.')], 'I6400,I6500': [Field('preset', Bits(31), 'HCI: Hardware cache initialization'), Field('DSBPK', Bits(24), 'Branch/Jump Predictions on KSeg0 and XKPhys regions', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DSMBR', Bits(23), "Disable Sleep Mode when long bus transactions pending; Core won't go to sleep mode if a long bus transaction is pending", [Value('Enabled', 0), Value('Disabled', 1)]), Field('DSM', Bits(22), "Disable Sleep Mode - Core won't go to sleep mode if set", [Value('Enabled', 0), Value('Disabled', 1)]), Field('DSUTLB', Bits(21), 'Disable Speculative Handling of uTLB Misses', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DIVA', Bits(20), 'Disable Instruction Virtual alias Avoidance', [Value('Enabled', 0), Value('Disabled', 1)]), Field('FTLBP', Bits(19, 18), 'FTLB probability.This field allows some TLBWR instruction to go to the     VTLB instead of the FTLB whenever the PageMask register matches the FTLB page     size. If the contents of the PageMask register do not match the FTLB page size, the     TLBWR instruction goes to the VTLB.', [Value('FTLB only. All TLBWR instructions go to the FTLB.', 0), Value('FTLB:VTLB = 15:1. For every 16 TLBWR instructions, 15 go to the FTLB and 1 goes to the VTLB.', 1), Value('FTLB:VTLB = 7:1. For every 8 TLBWR instructions, 7 go to the FTLB and 1 goes to the VTLB.', 2), Value('FTLB:VTLB = 3:1. For every 4 TLBWR instructions, 3 go to the FTLB and 1 goes to the VTLB.', 3)]), Field('DSSM', Bits(17), 'Disable Speculative bus fetch request for store Miss', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DSLM', Bits(16), 'Disable Speculative bus fetch request for load Miss', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DLS', Bits(15), 'Disable Light Sleep Disable $RAM mode to enter light sleep', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DDGRD', Bits(14), 'Not supported even though this field is R/W.'), Field('DSBND', Bits(13), 'Disable Store bonding. Both EXU and LSU disables store bonding feature.', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DLBND', Bits(12), 'Disable Load bonding. Both EXU and LSU disables load bonding feature.', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DSLD', Bits(11), 'Disable Speculative issue of load Disable speculative issue of load consumer.', [Value('Enabled', 0), Value('Disabled', 1)]), Field('ODCDCG', Bits(10), 'Override DCD 1 => always enable D$ Data Clock-Gater'), Field('ODCTCG', Bits(9), 'Override DCT 1 => always enable D$ Tag Clock-Gater'), Field('DBCG', Bits(8), 'Disable Block-level clock gater Disable block level clock gater', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DALU2', Bits(7), 'Disable Second ALU Disable second ALU (in LSU)', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DDWP', Bits(6), 'Disable D$ way prediction', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DIWP', Bits(5), 'Disable I$ way prediction', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DJRC', Bits(4), 'Disable Jump register cache. IFU waits for EXU to redirect for all JR excluding JR $31.', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DGHR', Bits(3), 'Disable Global history register updates', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DDBP', Bits(2), 'Disable Dynamic Branch Prediction. When DDBP = 1 and DBP = 0:      (1) Unconditional Branches are always taken;     (2) Branch backwards is always taken;     (3) Branch forwards is not taken.', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DBP', Bits(1), 'Disable Branch prediction. EXU does the branch resolution. IFU waits for EXU redirect after detecting a branch instruction', [Value('Enabled', 0), Value('Disabled', 1)]), Field('DRPS', Bits(0), 'Disable RPS. IFU waits for EXU to redirect when JR $31 is fetched.', [Value('Enabled', 0), Value('Disabled', 1)])], '1004K.*': [Field('WII', Bits(31), "Wait IE/IXMT Ignore: Indicates that this processor will allow an interrupt to unblock a WAIT instruction even if IE or IXMT is preventing the interrupt from being taken.${p}This avoids problems using the WAIT instruction for 'bottom half' interrupt servicing."), Field('NCWB', Bits(20), 'Non-Coherent Writeback.  When set, HitWB cacheops to a noncoherent address are written using a non-coherent CCA.'), Field('PCT', Bits(19), 'Performance Counters per TC: This bit indicates to software that the perfcounter registers are instantiated per TC rather than per processor.${p}This bit is implemented per-processor.'), Field('HCI', Bits(18), 'Hardware Cache Initialization: Indicates that a cache does not require initialization by software.  This bit is implemented per-processor.${p}This bit will most likely only be set on simulation-only cache models and not on real hardware.'), Field('FPR', Bits(17), 'Floating Point Ratio: Indicates clock ratio between integer CPU and floating point unit on 1004Kf CPUs.  Reads as 0 on 1004Kc CPUs.${p}  0  FP clock frequency is the same as the integer clock${nl}  1  FP clock frequency is one-half the integer clock${p}This bit is implemented per-processor.'), Field('AR', Bits(16), 'Alias removed: This bit indicates that the data cache is organized to avoid virtual aliasing problems.  This bit is only set if the data cache config and MMU type would normally cause aliasing - i.e., only for the 32KB and larger data cache and TLB-based MMU.${p}This bit is implemented per-processor.'), Field('IAR', Bits(10), 'Instruction Alias Removed: Indicates that this processor has hardware support to remove instruction cache alias.  This hardware is only present when the CPU is configured with a TLB and cache sizes 32KB and larger.  The hardware is disabled via the IVA bit.${p}This bit is implemented per-VPE'), Field('IVA', Bits(9), 'Instruction Virtual Aliasing fix disable: Setting this bit will disable the HW alias removal on the I-Cache.  If this bit is cleared, CACHE Hit Invalidate and SYNCI instructions will look up all possible aliased locations and invalidate the given cache line in all of them.${p}This bit is Read-only if IAR=0${p}This bit is implemented per-VPE'), Field('ES', Bits(8), "Externalize sync.  If this bit is set, and if the downstream device is capable of accepting SYNCs (indicated by the pin SI_SyncTxEn), the sync instruction will cause a SYNC-specific transaction to go out on the external bus.  If this bit is cleared or if SI_SyncTxEn is deasserted, no transaction will go out, but all SYNC handling internal to the core will nevertheless be performed.${p}The sync instruction will be signalled on the CPU's OCP interface as an 'ordering barrier' transaction.  The transaction is an extension to the OCPstandards, and system controllers which don't support it will typicallyunder-decode it as a read from the boot ROM area.  But that's going to be quite slow, so set this bit only if your system understands the synchronizing transaction.${p}When this bit is read, the value returned depends on the state of the SI_SyncTxEn pin.  If SI_SyncTxEn is 0, a value of 0 is returned.  If SI_SyncTxEn is 1, the value returned is the last value that was written to this bit."), Field('BTLM', Bits(7), 'Block TC on Load Miss: Setting this bit will cause a TC to be suspended once a load miss has been detected, rather than waiting for a dependent instruction to try to access the load data.  This can increase pipeline utilization and provide fairer allocation of miss resources, but does limit the parallel servicing of cache misses from a single TC.${p}This bit is implemented per-processor.'), Field('CPOOO', Bits(6), 'Out-of-order data return on the Coprocessor interfaces: Writing 1 to this bit disables the out-of-order data return for the FPU and COP2.'), Field('NBLSU', Bits(5), 'Non-Blocking LSU: Writing 1 to this field will lock the LSU and ALU pipelines together.  This forces LSU pipeline stalls to also stall the ALU pipeline.${p}This bit is implemented per-processor.'), Field('ULB', Bits(4), 'Uncached Loads Blocking: Writing 1 to this field will make all uncached loads blocking.${p}This bit is implemented per-processor.'), Field('BP', Bits(3), 'Branch Prediction: Writing 1 to this field will disable all speculative branch prediction.  The fetch unit will wait for a branch to be resolved before fetching the target or fall-through path.${p}This bit is implemented per-VPE.'), Field('RPS', Bits(2), 'Return Prediction Stack: In configurations with dynamic branch prediction logic, writing 1 to this field will disable the use of the Return Prediction Stack.  Returns (JR ra) will stall instruction fetch until the destination is calculated.${p}In configurations without dynamic branch prediction logic, this field is read-only and preset to 1.${p}This bit is implemented per-VPE.'), Field('BHT', Bits(1), 'Branch History Table: In configurations with dynamic branch prediction logic, writing 1 to this field will disable the dynamic branch prediction.  Branches will be statically predicted taken.${p}In configurations without dynamic branch prediction logic, this field is read-only and preset to 1.${p}This bit is implemented per-VPE.'), Field('SL', Bits(0), 'Scheduled Loads: Writing 1 to this field will make load misses blocking.${p}This bit is implemented per-processor.')], '74K.*,1074K.*': [Field('WII', Bits(31), 'Wait IE Ignore.  When this bit is set, an interrupt will unblock a wait instruction, even if StatusIE is preventing the interrupt from being taken.  If WII reads 0, the core remains in the wait condition forever if entered with interrupts disabled.  If set to 1, it allows OS code to avoid tricky race conditions.'), Field('FPFS', Bits(30), "Fast Prepare for Store.  When this bit is set, pref 31 will behave as specified, i.e., the prefetch instruction will only validate the data tag but not write 0's into the data cache.  By default, this bit will be 0 and pref 31 will behave like pref 30.  This means that pref 31 will validate the data tag and write 0's into the data cache array for the specified line."), Field('IHB', Bits(29), 'If IHB=1, the following behavior will be true:${p} When the core sees any explicit/implicit mtc0(cache, ll, mtc0, tlbop, eret, deret, sync-in-debug-mode, di, ei) followed by any implicit mfc0 (ehb, mfc0, eret, deret, di, ei), the pipeline will behave as if an ehb is introduced implicitly prior to executing the mfc0.  This ensures all state modification by mtc0 is completely seen by mfc0.${p} Anyjalr r31, jr r31 instruction seen by the core when CP0 is usable (i.e CU0=1 or Kernel or Debug mode as defined in the PRA) will automagically treat those instructions as jalr.hb and jr.hb.${p}If IHB=0, the following behavior will be true:${p} Programmer is responsible for resolving hazards and put ehb or .hb where appropriate.  Prior cores may have used some number of nops or ssnops to ensure that the effect of a CP0 modifying instruction is seen by a CP0 read instruction.  74K cannot guarantee such behavior with a small number of nops/ssnops.${p}Per Release2, the programmer is expected to put in an explicit ehb or .hb where needed.  If there is reason to believe that the programmer has not done this, then this bit can be enabled to get correct operation.'), Field('FPR1,', Bits(28), "Read-only fields.  Indicates frequency of the core relative to FPU.${p}2'b00: core:FPU = 1:1${nl}2'b01: core FPU = 2:1${nl}2'b10: core:FPU = 3:2${nl}2'b11: Reserved"), Field('SEHB', Bits(27), "'Slow EHB': experimental mode to accelerate CP0 sequences using ehb${p}If this bit is set, ehb will block issue of instructions from the instruction buffer until all older instructions have graduated and the pipe is empty.  By default, ehb will block issue of instructions from the instruction buffer only if there are pending explicit CP0-modifying instructions inthe pipe."), Field('CP2IO', Bits(26), 'CPU${p}Reserved for future use.'), Field('IAGN', Bits(25), 'Selective control of out-of-order behavior: issue ALU-side or load/storeside instructions (respectively) in program order.'), Field('IALU', Bits(24), 'Selective control of out-of-order behavior: issue ALU-side or load/storeside instructions (respectively) in program order.'), Field('DGHR', Bits(23), 'Disables the use of any global history in the branch predictor.'), Field('SG', Bits(22), 'Set 1 to allow only one instruction to graduate per cycle.  This has a negative impact on performance and should only be used for test purposes.'), Field('SUI', Bits(21), 'Strict Uncached Instruction (SUI) policy control.  Run uncached instruction strictly in order and (as far as possible) unpipelined.  This will be quite slow (the policy itself will introduce a 15-cycle bubble between each instruction), but you l hardly notice, because running uncached is already so slow.  Only the branch-delay-slot instruction of a branch is fetched without this bubble.${p}The advantage is that the CPU will not wander off speculatively fetching unwanted instructions from a (perhaps slow) boot memory.'), Field('HCI', Bits(18), 'Do not initialize caches (simulated CPUs only).'), Field('FPR0', Bits(17), "Read-only fields.  Indicates frequency of the core relative to FPU.${p}2'b00: core:FPU = 1:1${nl}2'b01: core FPU = 2:1${nl}2'b10: core:FPU = 3:2${nl}2'b11: Reserved"), Field('AR', Bits(16), 'Read-only field, indicating that the D-cache is configured to avoid cache aliases.${p}All the remaining fields are read/write, and control various functions.  Only one of them is likely to find real system use:'), Field('PREF', Bits(12, 11), "These two bits control the extent of prefetching of Instructions into the Instruction Cache as indicated.${nl}2'b00: Prefetch 0 cache lines on an I-cache miss in addition to fetching the missing cache line.  i.e.  Disable I-cache prefetching.${nl}2'b01: Prefetch 1 cache line (sequential next line) on an I-cache miss in addition to fetching the missing cache line.${nl}2'b10: Reserved${nl}2'b11: Prefetch 2 cache lines (sequential next 2 lines) on an I-cache miss in addition to fetching the missing cache line."), Field('IAR', Bits(10), 'Instruction Alias Removed.${p}Indicates that this processor has hardware support to remove instruction cache aliasing.  This hardware is only present when the core is configured with a TLB and cache size of 32KB and larger.  The hardware is disabled via the IVA bit.'), Field('IVA', Bits(9), 'Instruction Virtual Aliasing disabled.${p}Setting this bit will disable the HW alias removal on the I-cache.  If this bit is cleared, CACHE Hit Invalidate and SYNCI instructions will look up all possible aliased locations and invalidate the given cache line in all of them.  This bit is Read-only if IAR=0.'), Field('ES', Bits(8), "Externalize sync.  If this bit is set, and if the downstream device is capable of accepting SYNCs (indicated by the pin SI_SyncTxEn), the sync instruction will cause a SYNC-specific transaction to go out on the external bus.  If this bit is cleared or if SI_SyncTxEn is deasserted, no transaction will go out, but all SYNC handling internal to the core will nevertheless be performed.${p}The sync instruction will be signalled on the CPU's OCP interface as an 'ordering barrier' transaction.  The transaction is an extension to the OCPstandards, and system controllers which don't support it will typicallyunder-decode it as a read from the boot ROM area.  But that's going to be quite slow, so set this bit only if your system understands the synchronizing transaction.${p}When this bit is read, the value returned depends on the state of the SI_SyncTxEn pin.  If SI_SyncTxEn is 0, a value of 0 is returned.  If SI_SyncTxEn is 1, the value returned is the last value that was written to this bit."), Field('CP1IO', Bits(6), 'By default data sent from the core to a coprocessor block may be sent in an order reflecting the internal pipeline execution sequence.  Set this bit to arrange that data will be sent only in instruction order to the FPU.'), Field('ULB', Bits(4), 'Set to 1 to make all uncached loads blocking (a program usually only blocks when it uses the data which is loaded).  You should only do this when nothing else works.'), Field('BP', Bits(3), 'Write 1 to disable all branch prediction.'), Field('RPS', Bits(2), "When set, the return address branch predictor is disabled, so jr $31 is treated just like any other jump register.  Instruction fetch stalls after the branch delay slot, until the jump instruction reaches the 'EC' stage in the pipeline and can provide the right address."), Field('BHT', Bits(1), "When set, the branch history table is disabled and all branches are predicted taken.  This bit is don't care if Config7[BP] is set."), Field('SL', Bits(0), 'When set, disables non-blocking loads.  Normally the 74K core will keep running after a load instruction, even if it misses in the D-cache, until the data is used.  With this disable bit set, the CPU will stall on any load Dcache miss.')], 'proAptiv.*,P5600.*,P6600.*': [Field('WII', Bits(31), 'Wait IE Ignore.  When this bit is set, an interrupt will unblock a wait instruction, even if Status[IE] is preventing the interrupt from being taken.  If WII reads 0, the core remains in the wait condition forever if entered with interrupts disabled.  If set to 1, it allows operating system code to avoid tricky race conditions.'), Field('FPFS', Bits(30), "Fast prepare for store.  When this bit is set, pref 31 will behave as specified, i.e., the prefetch instruction will only validate the data tag but not write 0's into the data cache.${p}By default, this bit will be 0 and pref 31 will behave like pref 30.  This means that pref 31 will validate the data tag and write 0's into the data cache array for the specified line."), Field('IHB', Bits(29), 'If IHB = 1, the following behavior will be true: ${nl} When the core sees any explicit/implicit mtc0(cache, ll, mtc0, tlbop, eret, deret, sync-in-debug-mode, di, ei) followed by any implicit mfc0 (ehb, mfc0, eret, deret, di, ei), the pipeline will behave as if an ehb is introduced implicitly prior to executing the mfc0.  This ensures all state modification by mtc0 is completely seen by mfc0.  ${nl} Any jalr r31, jr r31 instruction seen by the CPU when CP0 is usable (i.e CU0=1 or Kernel or Debug mode as defined in the PRA) will automagically treat those instructions as jalr.hb and jr.hb.  If IHB = 0, the following behavior will be true:  ${nl} Programmer is responsible for resolving hazards and put ehb or .hb where appropriate.  Prior cores may have used some number of nops or ssnops to ensure that the effect of a CP0 modifying instruction is seen by a CP0 read instruction.  74K cannot guarantee such behavior with a small number of nops/ssnops.${p}Per Release2, the programmer is expected to put in an explicit ehb or .hb where needed.  If there is reason to believe that the programmer has not done this, then this bit can be enabled to get correct operation.'), Field('Reserved', Bits(28), 'Reserved.  Write as zero.  Ignored on reads.'), Field('SEHB', Bits(27), 'Slow EHB.  An experimental mode to accelerate CP0 sequences using the ehb instruction.${p}If this bit is set, ehb will block issue of instructions from the instruction buffer until all older instructions have graduated and the pipe is empty.  By default, ehb will block issue of instructions from the instruction buffer only if there are pending explicit CP0-modifying instructions in the.'), Field('Reserved', Bits(26, 24), 'Reserved.  Write as zero.  Ignored on reads.'), Field('DGHR', Bits(23), 'Disables the use of any global history in the branch predictor.'), Field('SG', Bits(22), 'Set 1 to allow only one instruction to graduate per cycle.  This has a negative impact on performance and should only be used for test purposes.'), Field('SUI', Bits(21), 'Strict Uncached Instruction (SUI) policy control.  When this bit is set, hardware runs uncached instructions strictly in order and (as far as possible) unpipelined.  This will cause a significant performance degradation as it will introduce a bubble equivalent to the depth of the pipeline between each instruction.  Only the branch-delay-slot instruction of a branch is fetched without this bubble.${p}The advantage is that the CPU will not wander off speculatively fetching unwanted instructions from a (perhaps slow) boot memory.'), Field('Reserved', Bits(20, 19), 'Reserved.  Write as zero.  Ignored on reads.'), Field('HCI', Bits(18), 'Hardware Cache Initialization.  Hardware sets this bit to indicate that a cache does not require initialization by software.  This bit will most likely only be set on simulation-only cache models and not on real hardware.'), Field('Reserved', Bits(17), 'Reserved.  Write as zero.  Ignored on reads.'), Field('AR', Bits(16), 'Hardware sets this bit to indicate that the L1 data cache is configured to avoid cache aliases.  The data cache virtual aliasing hardware is always present in this core.'), Field('Reserved', Bits(15, 13), 'Reserved.  Write as zero.  Ignored on reads.', [], None, 'proAptiv.*'), Field('Reserved', Bits(15), 'Reserved.  Write as zero.  Ignored on reads.', [], None, 'P5600'), Field('noRFO', Bits(14), 'When set, indicates that stores with CCA 4/5 may not allocate on a cache miss.', [], None, 'P5600'), Field('Reserved', Bits(13), 'Reserved.  Write as zero.  Ignored on reads.', [], None, 'P5600'), Field('Reserved', Bits(15, 13), 'Reserved.  Write as zero.  Ignored on reads.', [], None, 'P6600'), Field('PREF', Bits(12, 11), 'These two bits control the extent of prefetching of instructions into the instruction cache as indicated.', [Value('Prefetch 0 cache lines on an I-cache miss in addition to fetching the missing cache line.  i.e.  Disable I-cache prefetching', 0), Value('Prefetch 1 cache line (sequential next line) on an I-cache miss in addition to fetching the missing cache line', 1), Value('Reserved', 2, '', True), Value('Prefetch 2 cache lines (sequential next 2 lines) on an I-cache miss in addition to fetching the missing cache line', 3)]), Field('IAR', Bits(10), 'Instruction Alias Removed.  Indicates that this core has hardware support to remove instruction cache aliasing.  This hardware is only present when the core is configured with a TLB and cache size of 32KB or larger.  The virtual aliasing hardware can be disabled via the IVAD bit described below.  The instruction cache virtual aliasing hardware is always present in this core.'), Field('IVAD', Bits(9), 'Instruction Virtual Aliasing disabled.  The hardware required to resolve instruction cache virtual alising is always present in this core as noted by the defualt state of the IAR bit shown above.  However, software can the IVAD bit to enable or disable the virtual aliasing hardware for the instruction cache.${p}Setting this bit disables the hardware alias removal on the instruction cache.  If this bit is cleared, the CACHE Hit Invalidate and SYNCI instructions look up all possible aliased locations and invalidate the given cache line in all of them.'), Field('ES', Bits(8), "Externalize sync.  If this bit is set, and if the downstream device (toward memory) is capable of accepting SYNCs (indicated by the pin SI_SyncTxEn), the sync instruction causes a SYNC-specific transaction to go out on the external bus.  If this bit is cleared or if SI_SyncTxEn is deasserted, no transaction will go out, but all SYNC handling internal to the CPU will nevertheless be performed.${p}The sync instruction is signalled on the CPU's OCP interface as an ordering barrier transaction.  The transaction is an extension to the OCP standards, and system controllers which don't support it typically under-decode it as a read from the boot ROM area.  But that's going to be quite slow, so set this bit only if your system understands the synchronizing transaction.${p}When this bit is read, the value returned depends on the state of the SI_SyncTxEn pin.  If SI_SyncTxEn is 0, a value of 0 is returned.  If SI_SyncTxEn is 1, the value returned is the last value that was written to this bit."), Field('Reserved', Bits(7), 'Reserved.  Write as zero.  Ignored on reads.'), Field('CP1IO', Bits(6), 'CP1 instruction order.  By default, data sent from the core to a coprocessor block may be sent in an order reflecting the internal pipeline execution sequence.  Set this bit to arrange that data will be sent only in instruction order to the FPU.'), Field('Reserved', Bits(5), 'Reserved.  Write as zero.  Ignored on reads.', [], None, 'proAptiv.*'), Field('FPL', Bits(5), 'When this bit is set, a load is allowed to speculatively issue a line request to an address which is defined to be in the speculative region as defined by the MAAR register.', [], None, 'P5600'), Field('Reserved', Bits(5), 'Reserved.  Write as zero.  Ignored on reads.', [], None, 'P6600.*'), Field('ULB', Bits(4), 'Uncached load blocking.  Set to 1 to make all uncached loads blocking (a program usually only blocks when it uses the data which is loaded).'), Field('BP', Bits(3), 'Branch prediction.  When set, no branch prediction is done, and all branches and jump stall as above.'), Field('RPS', Bits(2), 'Return prediction stack.  When set, the return address branch predictor is disabled, so jr $31 is treated just like any other jump register.  An instruction fetch stalls after the branch delay slot, until the jump instruction reaches the EC stage in the AGEN pipeline and can provide the right address.'), Field('BHT', Bits(1), "Branch history table.  When set, the branch history table is disabled and all branches are predicted taken.  This bit is don't care if Config7[BP] is set."), Field('SL', Bits(0), 'When set, non-blocking loads are disabled.  Normally the core continues to after a load instruction, even if it misses in the D-cache, until the data is used.  When this bit is set, the CPU stalls on any D-cache load miss.')], '34K.*': [Field('WII', Bits(31), 'Reads 1 if wait terminates on a "disabled" interrupt.'), Field('PCT', Bits(19), 'Reads 1 if performance counters are replicated per-TC.'), Field('HCI', Bits(18), 'Do not initialize caches (simulated CPUs only).'), Field('FPR', Bits(17), 'Half-speed FPU.'), Field('AR', Bits(16), 'Indicates that the D-cache is configured to avoid cache aliases.'), Field('IAR', Bits(10), 'Instruction Alias Removed.'), Field('IVA', Bits(9), 'Instruction Virtual Aliasing disabled.'), Field('ES', Bits(8), "Write 1 to get 'sync' instructions signalled on OCP interface."), Field('BTLM', Bits(7)), Field('CPOOO', Bits(6), '1 for all CP data transfers to be strictly in program order.'), Field('NBLSU', Bits(5), 'Write 1 to stop whole CPU when load/store is pending.'), Field('ULB', Bits(4), 'Write 1 to make all uncached loads blocking.'), Field('BP', Bits(3), 'Write 1 to disable all branch prediction.'), Field('RPS', Bits(2), 'When set, the return address branch predictor is disabled, so jr $31 is treated just like any other jump register.  Instruction fetch stalls after the branch delay slot, until the jump instruction reaches the "EC" stage in the pipeline and can provide the right address.'), Field('BHT', Bits(1), "When set, the branch history table is disabled and all branches are predicted taken.  This bit is don't care if Config7[BP] is set."), Field('SL', Bits(0), 'Write 1 to disable all non-blocking loads.')], 'm14k.*,M51.*,M62.*': [Field('WII', Bits(31), u'Wait IE Ignore. Indicates that this processor will allow an interrupt      to unblock a WAIT instruction, even if IE is preventing the interrupt      from being taken. This avoids problems using the WAIT instruction      for \u2018bottom half\u2019 interrupt servicing.      In WII mode when IE=0, waking up from Sleep mode will not enter      an Interrupt Service Routine.', [], None, 'm14k.*,M51.*'), Field('Reserved', Bits(31), 'Reserved', [], None, 'M62.*'), Field('Reserved', Bits(30, 19), 'Reserved'), Field('HCI', Bits(18), 'Hardware Cache Initialization: Indicates that a cache does not      require initialization by software.${p}      This bit will most likely only be set on simulation-only cache models      and not on real hardware.'), Field('Reserved', Bits(17, 9), 'Reserved'), Field('ES', Bits(8), 'Externalize Sync: When asserted, SYNC instructions are externalized      and made visible to the bus. For designs that have slave controllers      unable to handle SYNC behaviors, set this bit to 0.', [], None, 'M62.*'), Field('Reserved', Bits(8), 'Reserved', [], None, 'm14k.*,M51.*'), Field('Reserved', Bits(7, 0), 'Reserved')]}, 'The Config7 register contains implementation specific configuration information.  A number of these bits are writeable to disable certain performance enhancing features within the core.', [], 32, Or(CPUNameMatches('1004K.*'), CPUNameMatches('M14K.*'), CPUNameMatches('VIRTUOSO.*'), CPUNameMatches('74K.*'), CPUNameMatches('34K.*'), CPUNameMatches('24K.*'), CPUNameMatches('5K.*'), CPUNameMatches('1074K.*'), CPUNameMatches('ProAptiv.*'), CPUNameMatches('P5600.*'), CPUNameMatches('P6600.*'), CPUNameMatches('M51[05]0.*'), CPUNameMatches('M62[05]0.*'), CPUNameMatches('I6[45]00.*'))),
         Register('Config6', 'cp0.16.6', '', {'': [Field('SPCD', Bits(14), 'Sleep state Performance Counter Disable.  When this bit is set, the performance counter core clocks are prevented from shutting down.${p}The primary use of this bit is to keep performance counters alive when the core is in sleep mode.', [Value('Performance counter enabled', 0), Value('Performance counter disabled', 1)]), Field('SYND', Bits(13), 'Synonym tag update Disable.  This bit controls the tag update behavior for loads with a Virtual Address miss but a Physical Address hit during a Dcache look-up.', [Value('update the tag', 0), Value('do not update the tag', 1)]), Field('IFUPerfCtl', Bits(12, 10), 'IFU Performance Control.  This field encodes IFU events that provide debug and performance information for the IFU pipeline.', [Value('IDU is accepting instructions, but IFU is not providing any', 0), Value('A control transfer instruction such as a branch or jump causes lost IDU bandwidth', 1), Value('A stalled instruction such as an unpredicted jump must wait for an address and thus causes lost IDU bandwidth', 2), Value('Cache prediction was correct', 3), Value('Cache prediction was incorrect', 4), Value('Cache did not predict due to invalid JR cache entry, or the instruction tag miscompared with tag in JR cache', 5), Value('Unimplemented.', 6), Value('Condition branch was taken', 7)]), Field('NMRUP', Bits(9), 'NMRU Present.  Rather than a fully random replacement on TLBWR, a table of the most recently used JTLB entries is maintained, whose entries are not replaced whenever possible.', [Value('Most Recently Used JTLB replacement scheme not present', 0), Value('Most Recently Used JTLB replacement scheme present', 1)]), Field('NMRUD', Bits(8), 'NMRU Disable.  Disable bit for NMRU JTLB replacement scheme.', [Value('TLBWR instruction uses NMRU scheme', 0), Value('TLBWR instruction uses random replacement', 1)]), Field('JRCP', Bits(1), 'JR Cache Present.  JR cache learns the target address of "Jump Register" type instructions and subsequently predicts that target address.', [Value('JR cache is not implemented', 0), Value('JR cache is implemented', 1)]), Field('JRCD', Bits(0), 'JR Cache Prediction Disable.  Disables JR target address prediction.', [Value('JR cache target address prediction is enabled', 0), Value('JR cache target address prediction is not enabled', 1)])], 'proAptiv.*': [Field('Reserved', Bits(31, 30), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('DOPC', Bits(29), 'Opcode cache disable.  Setting this bit indicates that the opcode cache is disabled.', [Value('Opcode cache is enabled', 0), Value('Opcode cache is disabled', 1)]), Field('MNAN', Bits(28), 'MIPS NaN compliance.', [Value('Default NaN compliance', 0), Value('Legacy MIPS NaN compliance', 1)]), Field('DSFW', Bits(27), 'Disable superforwarding.', [Value('Enable superforwarding', 0), Value('Disable superforwarding', 1)]), Field('DWP', Bits(26), 'Disable IFU way prediction.', [Value('Enable IFU way prediction', 0), Value('Disable IFU way prediction', 1)]), Field('DL1B', Bits(25), 'Disable L1 branch target buffer.', [Value('Enable L1 branch target buffer', 0), Value('Disable L1 branch target buffer', 1)]), Field('DNPE', Bits(24), 'Disable NOP elimination.', [Value('Enable NOP elimination', 0), Value('Disable NOP elimination', 1)]), Field('ODTG', Bits(23), 'Override data cache tag clock gater.', [Value('Enable data cache tag clock gating', 0), Value('Override data cache tag clock gating.  Enable the clock to data cache tag array always', 1)]), Field('ODDG', Bits(22), 'Override data cache data clock gater.', [Value('Enable data cache data clock gating', 0), Value('Override data cache data clock gating.  Enable the clock to data cache data array always', 1)]), Field('DLSF', Bits(21), 'Disable load/store fusion.', [Value('Enable load/store fusion', 0), Value('Disable load/store fusion', 1)]), Field('DFIS', Bits(20), 'Disable fission.', [Value('Enable fission', 0), Value('Disable load/store fusion', 1)]), Field('HITLB', Bits(19), 'Half size instruction TLB (ITLB).  When this bit is set, the ITLB becomes half of its current size.', [Value('Full size ITLB', 0), Value('Half size ITLB', 1)]), Field('HDTLB', Bits(18), 'Half size data TLB (DTLB).  When this bit is set, the DTLB becomes half of its current size.', [Value('Full size DTLB', 0), Value('Half size DTLB', 1)]), Field('FTLBP', Bits(17, 16), 'FTLB probability.  On a TLBWR instruction, if the PageMask register matches the FTLB page size, the write would be done to the FTLB.  Otherwise it would go to the VTLB.  However, for systems that use only a single page size, the FTLB would be used and most of the VTLB would be unused.${p}This field allows some TLBWR instruction to go to the VTLB instead of the FTLB whenever the PageMask register matches the FTLB page size.  If the contents of the PageMask register do not match the FTLB page size, the TLBWR instruction goes to the VTLB.', [Value('FTLB only.  All TLBWR instruction go to the FTLB', 0), Value('FTLB:VTLB = 15:1.  For every 16 TLBWR instructions, 15 go to the FTLB and 1 goes to the VTLB', 1), Value('FTLB:VTLB = 7:1.  For every 8 TLBWR instructions, 7 go to the FTLBand 1 goes to the VTLB', 2), Value('FTLB:VTLB = 3:1.  For every 4 TLBWR instructions, 3 go to the FTLB and 1 goes to the VTLB', 3)]), Field('FTLBEn', Bits(15), 'FTLB enable.  Setting this bit indicates that the FTLB is enabled.', [Value('FTLB is disabled', 0), Value('FTLB is enabled', 1)]), Field('SPCD', Bits(14), 'Sleep state performance counter disable.  When this bit is set, the performance counter clocks are prevented from shutting down.${p}The primary use of this bit is to keep performance counters alive when the proAptiv.*core is in sleep mode.', [Value('Performance counters are enabled in sleep mode', 0), Value('Performance counters are disabled in sleep mode', 1)]), Field('Reserved', Bits(13), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('IFUPerfCtl', Bits(12, 10), 'IFU Performance Control.  This field encodes IFU events that provide debug and performance information for the IFU pipeline.${p}Lost IDU bandwidth occurs when the IDU is accepting instructions, but instructions are not being provided by the IFU.  The count of these events can be seen via Performance Counters 0 or 3, and the event number 11.  In order to view the IFU Perf Ctl events, the Performance Counter Control needs to be programmed accordingly for general information on event number 11.', [Value('IDU is accepting instructions, but IFU is not providing any', 0), Value('A control transfer instruction such as a branch or jump causes lost IDU bandwidth', 1), Value('A stalled instruction such as an unpredicted jump must wait for an address and thus causes lost IDU bandwidth', 2), Value('Cache prediction was correct', 3), Value('Cache prediction was incorrect', 4), Value('Cache did not predict due to invalid JR cache entry, or the instruction tag miscompared with tag in JR cache', 5), Value('Unimplemented', 6), Value('Condition branch was taken', 7)]), Field('Reserved', Bits(9, 1), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('JRCD', Bits(0), 'Jump register cache prediction disable.  Setting this bit disables the Jump Register (JR) target address prediction.', [Value('JR cache target address prediction is enabled', 0), Value('JR cache target address prediction is not enabled', 1)])], 'P5600.*,P6600.*': [Field('Reserved', Bits(31), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('FPDSR', Bits(30), 'Floating point disable square root.', [Value('Enable floating point divide and square root', 0), Value('Disable floating point divide and square root', 1)]), Field('DOPC', Bits(29), 'Opcode cache disable.  Setting this bit indicates that the opcode cache is disabled.', [Value('Opcode cache is enabled', 0), Value('Opcode cache is disabled', 1)]), Field('Reserved', Bits(28), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P6600.*'), Field('MNAN', Bits(28), 'MIPS NaN compliance.', [Value('Default NaN compliance', 0), Value('Legacy MIPS NaN compliance', 1)], None, 'P5600.*'), Field('DSFW', Bits(27), 'Disable superforwarding.', [Value('Enable superforwarding', 0), Value('Disable superforwarding', 1)]), Field('DWP', Bits(26), 'Disable IFU way prediction.', [Value('Enable IFU way prediction', 0), Value('Disable IFU way prediction', 1)]), Field('DL1B', Bits(25), 'Disable L1 branch target buffer.', [Value('Enable L1 branch target buffer', 0), Value('Disable L1 branch target buffer', 1)]), Field('DNPE', Bits(24), 'Disable NOP elimination.', [Value('Enable NOP elimination', 0), Value('Disable NOP elimination', 1)]), Field('ODTG', Bits(23), 'Override data cache tag clock gater.', [Value('Enable data cache tag clock gating', 0), Value('Override data cache tag clock gating.  Enable the clock to data cache tag array always', 1)]), Field('ODDG', Bits(22), 'Override data cache data clock gater.', [Value('Enable data cache data clock gating', 0), Value('Override data cache data clock gating.  Enable the clock to data cache data array always', 1)]), Field('DLSB', Bits(21), 'Disable load/store bonding.', [Value('Enable load/store bonding', 0), Value('Disable load/store bonding', 1)]), Field('DFIS', Bits(20), 'Disable cracking.', [Value('Enable cracking', 0), Value('Disable cracking', 1)]), Field('HITLB', Bits(19), 'Half size instruction TLB (ITLB).  When this bit is set, the ITLB becomes half of its current size.', [Value('Full size ITLB', 0), Value('Half size ITLB', 1)]), Field('HDTLB', Bits(18), 'Half size data TLB (DTLB).  When this bit is set, the DTLB becomes half of its current size.', [Value('Full size DTLB', 0), Value('Half size DTLB', 1)]), Field('FTLBP', Bits(17, 16), 'FTLB probability.  On a TLBWR instruction, if the PageMask register matches the FTLB page size, the write would be done to the FTLB.  Otherwise it would go to the VTLB.  However, for systems that use only a single page size, the FTLB would be used and most of the VTLB would be unused.${p}This field allows some TLBWR instruction to go to the VTLB instead of the FTLB whenever the PageMask register matches the FTLB page size.  If the contents of the PageMask register do not match the FTLB page size, the TLBWR instruction goes to the VTLB.', [Value('FTLB only.  All TLBWR instruction go to the FTLB', 0), Value('FTLB:VTLB = 15:1.  For every 16 TLBWR instructions, 15 go to the FTLB and 1 goes to the VTLB', 1), Value('FTLB:VTLB = 7:1.  For every 8 TLBWR instructions, 7 go to the FTLBand 1 goes to the VTLB', 2), Value('FTLB:VTLB = 3:1.  For every 4 TLBWR instructions, 3 go to the FTLB and 1 goes to the VTLB', 3)]), Field('FTLBEn', Bits(15), 'FTLB enable.  Setting this bit indicates that the FTLB is enabled.', [Value('FTLB is disabled', 0), Value('FTLB is enabled', 1)]), Field('SPCD', Bits(14), 'Sleep state performance counter disable.  When this bit is set, the performance counter clocks are prevented from shutting down.${p}The primary use of this bit is to keep performance counters alive when the core is in sleep mode.', [Value('Performance counters are enabled in sleep mode', 0), Value('Performance counters are disabled in sleep mode', 1)]), Field('Reserved', Bits(13), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('IFUPerfCtl', Bits(12, 10), 'IFU Performance Control.  This field encodes IFU events that provide debug and performance information for the IFU pipeline.${p}Lost IDU bandwidth occurs when the IDU is accepting instructions, but instructions are not being provided by the IFU.  The count of these events can be seen via Performance Counters 0 or 3, and the event number 11.  In order to view the IFU Perf Ctl events, the Performance Counter Control needs to be programmed accordingly for general information on event number 11.', [Value('IDU is accepting instructions, but IFU is not providing any', 0), Value('A control transfer instruction such as a branch or jump causes lost IDU bandwidth', 1), Value('A stalled instruction such as an unpredicted jump must wait for an address and thus causes lost IDU bandwidth', 2), Value('Cache prediction was correct', 3), Value('Cache prediction was incorrect', 4), Value('Cache did not predict due to invalid JR cache entry, or the instruction tag miscompared with tag in JR cache', 5), Value('Unimplemented', 6), Value('Condition branch was taken', 7)]), Field('Reserved', Bits(9, 3), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P5600.*'), Field('R6', Bits(2), 'This bit, if set, indicates that the P5600 core implements the           MIPSr6 architecture. This bit is preset by hardware at build time depending           on whether the MIPSr6 functionality is implemented.', [Value('MIPSr6 is disabled.', 0), Value('MIPSr6 is enabled.', 1)], None, 'P5600.*'), Field('0', Bits(1), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P5600.*'), Field('Reserved', Bits(9, 1), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P6600.*'), Field('JRCD', Bits(0), 'Jump register cache prediction disable.  Setting this bit disables the Jump Register (JR) target address prediction.', [Value('JR cache target address prediction is enabled', 0), Value('JR cache target address prediction is not enabled', 1)])]}, 'Config6 provides information about the presence of optional extensions to the base MIPS32 architecture in addition to those specified in Config2 and Config3.', [], 32, Or(CPUNameMatches('74K.*'), CPUNameMatches('1074K.*'), CPUNameMatches('ProAptiv.*'), CPUNameMatches('P5600.*'), CPUNameMatches('P6600.*'))),
         Register('Config5', 'cp0.16.5', '', {'': [Field('K', Bits(30), 'Disable fixed segmentation configuration controls; Config[K0], Config[Ku], Config[K23].', [Value('Config[K0] overrides segment configuration cache mode for kseg0 region.  Config[Ku] , Config[K23] enabled', 0), Value('Config[K0], Config[Ku], Config[K23] disabled', 1)]), Field('CV', Bits(29), 'Cache error exception vector control.  Disables logic forcing use of kseg1 region in the event of a Cache Error exception when Status[BEV] = 0.${p}When the CV bit is cleared, bits 31:30 of the EBase Register are fixed with the value 2 10 to force the exception base address to be in the kseg0 or kseg1 unmapped virtual address segments.  Bit 29 of exception base address will be forced to 1 on Cache Error exceptions so the exception handler will be executed from the uncached kseg1 segment.${p}When the CV bit is set, the ExcBase field is expanded to include bits 31:30 to facilitate programmable memory segmentation.'), Field('EVA', Bits(28), 'This bit is always a logic one to indicate support for enhanced virtual address (EVA).'), Field('Reserved', Bits(27, 0), 'Reserved.  Must be written as zero.  Ignored on reads.')], 'I6400,I6500': [Field('M', Bits(31), 'This bit is reserved to indicate that as yet undefined configuration registers are present. With the current architectural definition, this bit should always read as a 0.'), Field('K', Bits(30), 'Set to 0 as Segmentation Control is not implemented.'), Field('CV', Bits(29), 'Set to 0 as Segmentation Control is not implemented.'), Field('EVA', Bits(28), 'Set to 0 as Enhanced Virtual Addressing instructions are not implemented.'), Field('MSAEn', Bits(27), 'MIPS SIMD Architecture (MSA) Enable.', [Value('MSA instructions and registers are disabled. Executing a MSA instruction causes a MSA Disabled exception.', 0), Value('MSA instructions and registers are enabled.', 1)]), Field('CRCP', Bits(18), 'CRC instruction support is present.'), Field('MI', Bits(17), 'Use MMID instead of ASID.'), Field('GI', Bits(16, 15), 'GINVI and GINVT Instructions supported.'), Field('XNP', Bits(13), 'This field is set to 0 if LLWP/LLDP/SCWP/SCDP instructions are present in this implementation.'), Field('DEC', Bits(11), 'Dual Endian Capability. Determines endian capability of processor. Both modes are     supported in this implementation and the processor will initially boot in little-endian     mode always. Thereafter, software can force a change in endian mode by setting a bit     in a memory-mapped external register. The endian mode change will only take effect     on subsequent reset. For current endian state, software should read Config.BE.'), Field('L2C', Bits(10), 'Config2 does not contain L2 cache information'), Field('UFE', Bits(9), 'Enable for user mode access to Config5.FRE . User mode can conditionally access Config5.FRE using CTC1 and CFC1 instructions.', [Value('An attempt by user to read/write Config5.FRE causes a Reserved Instruction exception.', 0), Value('User is allowed to write Config5.FRE (only) using CTC1, and read Config5.FRE      (only) using CFC1. A kernel can access Config5 using MTC0/MFC0. Config5.UFE      applies also to kernel use of CFC1/CTC1. Config5.UFE is reserved if: FIR.FREP is 0      or Config1.FP=0.', 1)]), Field('FRE', Bits(8), 'Enable for user mode to emulate Status.FR=0 handling on an FPU with Status.FR     hardwired to 1. User mode can conditionally access Config5.FRE using CTC1 and     CFC1 instructions.', [Value('Instructions impacted by Config5.FRE do not generate additional exception conditions.', 0), Value('The following instructions cause a Reserved Instruction exception: - All single-precision      FP arithmetic instructions. - All LWC1/LWXC1/MTC1 instructions. - All      SWC1/SWXC1/MFC1 instructions.', 1)]), Field('VP', Bits(7), 'Virtual Processor. The value of this bit must be the same for all virtual processors in a     physical core. This field is set to 1 because multi-threading features are supported. This includes CP0     Global Number register (reg = 3, sel = 1), instructions DVP/EVP, changes to EBASE     to support virtual core numbering.'), Field('SBRI', Bits(6), 'SDBBP instruction Reserved Instruction control. The purpose of this field is to restrict     availability of SDBBP to kernel mode operation. It prevents user (and supervisor) code     from entering Debug mode using SDBBP.', [Value('SDBBP instruction execution will not cause reserve instruction exception in user and supervisor modes.', 0), Value('SDBBP instruction can only be executed in kernel mode. User and supervisor execution of SDBBP will cause a Reserved Instruction exception.', 1)]), Field('MVH', Bits(5), 'This field is set to 1 if MTHC0 and MFHC0 instructions are supported.'), Field('LLB', Bits(4), 'Load-Linked Bit (LLB) is present in COP0 LLAddr. Config5.LLB is read-only 1. Additional support exists:      (1) ERETNC instruction added;     (2) CP0 LLAddr.LLB is mandatory;     (3) LLbit is software accessible through LLAddr[0];     (4) SC instruction behavior is modified.'), Field('MRP', Bits(3), 'COP0 Memory Accessibility Attribute Registers, MAAR and MAARI, are present.     This field is set to 1 because MAAR and MAARI are present. Software may program     these registers to apply additional attributes to fetch/load/store access to memory/IO     address ranges.'), Field('NF', Bits(0), 'The Nested Fault feature does not exist. This field is set to 0 in this implementation.')], 'M62[05]0': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is one to indicate the presence of Config5.'), Field('Reserved', Bits(30), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('CV', Bits(29), 'Cache Error Exception Vector control. Disables logic         forcing use of kseg1 region in the event of a Cache Error       exception when StatusBEV=0', [Value('On Cache Error exception, vector address bits 31..29 forced to place vector in kseg1.', 0), Value('On Cache Error exception, vector address uses full EBase value for bits 31..29.', 1)]), Field('Reserved', Bits(28, 14), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('UFR', Bits(13), 'Extended LL/SC family of instructions Not Present.       The LLX/SCX family of instructions is required for       Release 6 Double-Width atomic support. This support is       provided by extending the capability of legacy LL/SC       instructions.', [Value('LLX/SCX instruction family supported', 0), Value('LLX/SCX instruction family not supported', 1)]), Field('Reserved', Bits(12), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('DEC', Bits(11), 'Dual Endian Capability. Determines endian capability of processor.      If both modes are supported, then the processor will initially      boot in little-endian mode always. Thereafter, software      can force a change in endian mode by setting a bit      in a memory-mapped external register. The endian mode      change will only take effect on subsequent reset. For      current endian state, software should read ConfigBE.', [Value('Only Little-Endian mode supported. Any implementation must support Little-endian mode.', 0), Value('Both Little and Big-Endian modes supported.', 1)]), Field('Reserved', Bits(10, 7), 'Reserved.  Must be written as zero.  Returns 0 on reads.'), Field('SBRI', Bits(6), 'SDBBP instruction Reserved Instruction control.      The purpose of this field is to restrict availability of      SDBBP to kernel mode operation. It prevents user (and      supervisor) code from entering Debug mode using      SDBBP. When restricted, User (or supervisor, if supported)       execution of SDBBP will cause a Reserved Instruction      exception..', [Value('SDBBP instruction executes as defined prior to Release 6', 0), Value('SDBBP instruction can only be executed in kernel mode. ', 1)]), Field('Reserved', Bits(5), 'Reserved.  Must be written as zero.  Returns 0 on reads.'), Field('LLB', Bits(4), 'Load-Linked Bit (LLB) is present in COP0 LLAddr.'), Field('Reserved', Bits(3, 1), 'Reserved.  Must be written as zero.  Returns 0 on reads.'), Field('NFExists', Bits(0), 'Indicates that the Nested Fault feature is present.       The Nested Fault feature allows recognition of faulting       behavior within an exception handler.')], 'P5600.*,P6600.*': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is NOT used to indicate the presence of Config6 since it is defined as an implementation-specific register.'), Field('K', Bits(30), u'This bit effects the cache coherency attributes, the boot exception vector overlay, and the location of the exception vector as follows:${p}     When this bit is cleared, the following events occur:${nl}     1. The Config[K0] field is used to set the cache coherency attributes for the      kseg0 region (0x8000_0000 - 0x9FFF_FFFF).${nl}     2. Hardware creates two boot overlay segments, one for kseg0 and one for kseg1.${nl}     3. The exception vectors are forced to reside in kseg0/kseg1 by ignoring the      state of bits 31:30 of the EBase register as well as the SI_ExceptionBase[31:30]      pins and forcing them to a value of 2\u2019b10.${p}     When this bit is set, the following events occur:${nl}     1: The Config[K0] field is ignored and the cache coherency attributes are      derived from the C fields of the various segmentation control registers      (SegCtl0 - SegCtl2).${nl}     2. Hardware creates one boot overlay segment that can reside anywhere in      virtual address space.${nl}     3. The exception vectors are not forced to reside in kseg0/kseg1. Rather, bits      31:30 of the EBase register, as well as the SI_ExceptionBase[31:30] signals      and used to place the exception vectors anywhere within virtual address space.', [Value('Config[K0] is used', 0), Value('Config[K0] is ignored', 1)]), Field('CV', Bits(29), "Cache error exception vector control.  Disables logic forcing use of kseg1      region in the event of a Cache Error exception when Status[BEV] = 0.${p}     When the CV bit is cleared, bits 31:30 of the EBase Register are fixed with the      value 2'b10 to force the exception base address to be in the kseg0 or kseg1 unmapped      virtual address segments.  Bit 29 of exception base address will be forced to 1 on      Cache Error exceptions so the exception handler will be executed from the uncached kseg1 segment.${p}     When the CV bit is set, the ExcBase field is expanded to include bits 31:30 to facilitate programmable memory segmentation."), Field('EVA', Bits(28), 'This bit is always a logic one to indicate support for enhanced virtual address (EVA).'), Field('MSAEN', Bits(27), 'MIPS SIMD architecture (MSA) enable. Executing an MSA instruction while disabled causes a MSA disabled exeption.', [Value('MSA instructions and registers are disabled.', 0), Value('MSA instructions and registers are enabled.', 1)]), Field('0', Bits(26, 6), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P5600.*'), Field('0', Bits(26, 14), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P6600.*'), Field('XNP', Bits(13), 'Extended LL/SC family of instructions. The LLX/SCX family of instructions     is required for Release 6 Double-Width atomic support. This support is     provided by extending the capability of legacy LL/SC instructions.${p}     0: LLX/SCX instruction family supported${p}     1: LLX/SCX instruction family not supported${p}     This bit is always 1 in the P6600 core. This bit can be read in user mode by setting the XNP bit in the HWREna CP0     register.', [Value('LLX/SCX Supported', 0), Value('LLX/SCX Not Supported', 1)], None, 'P6600.*'), Field('0', Bits(12), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P6600.*'), Field('DEC', Bits(11), 'Dual Endian Capability. Determines endian capability of processor.If both      modes are supported, then the processor will initially boot in little-endian      mode always. Thereafter, software can force a change in endian mode by setting      a bit in a memory-mapped external register. The endian mode change      will only take effect on a subsequent reset. For current endian state, software      should read Config.BE.${p}      0: Only Little-Endian mode supported. Any implementation must support Little-endian mode.${p}      1: Both Little and Big-Endian modes supported.', [Value('Only LE Supported', 0), Value('BE and LE Supported', 1)], None, 'P6600.*'), Field('L2C', Bits(10), 'Indicates presence of COP0 Config2.     0: Config2 present. Software can read Config2 to determine L2/L3 cache configuration.     1: Config2 not present. Replaced by memory-mapped register that software can read instead.', [Value('Config2 is present', 0), Value('Config2 is not present', 1)], None, 'P6600.*'), Field('UFE', Bits(9), 'Enable for user mode access to Config5.FRE . User mode can conditionally access Config5.FRE using CTC1 and CFC1 instructions.', [Value('An attempt by user to read/write Config5.FRE causes a Reserved Instruction exception.', 0), Value('User is allowed to write Config5.FRE (only) using CTC1, and read Config5.FRE      (only) using CFC1. A kernel can access Config5 using MTC0/MFC0. Config5.UFE      applies also to kernel use of CFC1/CTC1. Config5.UFE is reserved if: FIR.FREP is 0      or Config1.FP=0.', 1)], None, 'P6600.*'), Field('FRE', Bits(8), 'Enable for user mode to emulate Status.FR=0 handling on an FPU with Status.FR     hardwired to 1. User mode can conditionally access Config5.FRE using CTC1 and     CFC1 instructions.', [Value('Instructions impacted by Config5.FRE do not generate additional exception conditions.', 0), Value('The following instructions cause a Reserved Instruction exception: - All single-precision      FP arithmetic instructions. - All LWC1/LWXC1/MTC1 instructions. - All      SWC1/SWXC1/MFC1 instructions.', 1)], None, 'P6600.*'), Field('SBRI', Bits(6), 'SDBBP instruction Reserved Instruction control. The purpose of this field is to restrict     availability of SDBBP to kernel mode operation. It prevents user (and supervisor) code     from entering Debug mode using SDBBP.', [Value('SDBBP instruction execution will not cause reserve instruction exception in user and supervisor modes.', 0), Value('SDBBP instruction can only be executed in kernel mode. User and supervisor execution of SDBBP will cause a Reserved Instruction exception.', 1)], None, 'P6600.*'), Field('MVH', Bits(5), 'Move To/From High COP0 (MTHC0/MFHC0) instructions are implemented.           In the P5600, these instructions are used for Extended Physical           Addressing (XPA). This bit is set by hardware to indicate that this function is           enabled.', [Value('MTHC0 and MFHC0 instructions are not supported.', 0), Value('MTHC0 and MFHC0 instructions are supported.', 1)]), Field('LLB', Bits(4), u'Load-Linked Bit software support present. When this bit is set, the following features are supported.${nl}      \u2022 ERETNC instruction added.${nl}      \u2022 CP0 LLAddrLLB bit must be set.${nl}      \u2022 LLbit is sofware accessible through the LLADDR[0] bit in the LLADDR register.', [Value('LLB functionality is not supported.', 0), Value('LLB functionality is supported.', 1)]), Field('MRP', Bits(3), 'COP0 Memory Accessibility Attribute Registers, MAAR and MAARI, present.       Software may program these registers to apply additional attributes to fetch,       load, or store accesses to memory/IO address ranges.', [Value('MAAR and MAARI not present.', 0), Value('MAAR and MAARI present.', 1)]), Field('UFR', Bits(2), 'This feature allows user mode access to Status[FR] with CTC1 and CFC1.', [Value('User mode FR instructions not allowed.', 0), Value('User mode FR instructions allowed.', 1)], None, 'P5600.*'), Field('0', Bits(1), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P5600.*'), Field('0', Bits(2, 1), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P6600.*'), Field('NFExists', Bits(0), 'Indicates if the Nested Fault feature is present. The Nested Fault feature      allows recognition of faulting behavior within an exception handler.')], 'interAptiv.*': [Field('Reserved', Bits(31)), Field('K', Bits(30), u'This bit effects the cache coherency attributes, the boot exception vector     overlay, and the location of the exception vector as follows:     When this bit is cleared, the following events occur:${p}     1. The ConfigK0 field is used to set the cache coherency attributes for the     kseg0 region (0x8000_0000 - 0x9FFF_FFFF).${nl}     2. Hardware creates two boot overlay segments, one for kseg0 and one for     kseg1.${nl}     3. The exception vectors are forced to reside in kseg0/kseg1 by ignoring the     state of bits 31:30 of the EBase register as well as the     SI_ExceptionBase[31:30] pins and forcing them to a value of 2\u2019b10.${p}     When this bit is set, the following events occur:${p}     1: The Configk0 field is ignored and the cache coherency attributes are     derived from the C fields of the various segmentation control registers     (SegCtl0 - SegCtl2).${nl}     2. Hardware creates one boot overlay segment that can reside anywhere in     virtual address space.${nl}     3. The exception vectors are not forced to reside in kseg0/kseg1. Rather, bits     31:30 of the EBase register, as well as the SI_ExceptionBase[31:30] signals     and used to place the exception vectors anywhere within virtual address     space.'), Field('CV', Bits(29), 'Cache error exception vector control.  Disables logic forcing use of      kseg1 region in the event of a Cache Error exception when Status[BEV] = 0.${p}     When the CV bit is cleared, bits 31:30 of the EBase Register are fixed with the      value 2 10 to force the exception base address to be in the kseg0 or kseg1 unmapped      virtual address segments.  Bit 29 of exception base address will be forced to 1 on      Cache Error exceptions so the exception handler will be executed from the uncached      kseg1 segment.${p}When the CV bit is set, the ExcBase field is expanded to include      bits 31:30 to facilitate programmable memory segmentation.'), Field('EVA', Bits(28), 'This bit is always a logic one to indicate support for enhanced virtual address (EVA).'), Field('Reserved', Bits(27, 15), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('CA2', Bits(14), 'Only exists on interAptiv MR2, 0 otherwise. Extension of Config1CA. Indicates implementation of version 2.0 of     MIPS16e, MIPS16e2. For CA2 to be 1, Config1CA must also be 1. This bit is     encoded as follows:${p}     0: Version 2.0 is not implemented.${nl}     1: Version 2.0 is implemented.'), Field('Reserved', Bits(13, 0), 'Reserved.  Must be written as zero.  Ignored on reads.')], 'm14K.*': [Field('M', Bits(31), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('Reserved', Bits(30, 3), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('UFR', Bits(2), 'Release 5 feature, This feature allows user mode access to Status[FR] with CTC1 and CFC1.'), Field('Reserved', Bits(1), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('NFExists', Bits(0), 'Indicates that the Nested Fault feature is present.       The Nested Fault feature allows recognition of faulting       behavior within an exception handler.')], 'proAptiv.*': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is NOT used to indicate the presence of Config6 since it is defined as an implementation-specific register.'), Field('K', Bits(30), 'Disable fixed segmentation configuration controls; Config[K0], Config[Ku], Config[K23].', [Value('Config[K0] overrides segment configuration cache mode for kseg0 region.  Config[Ku] , Config[K23] enabled', 0), Value('Config[K0], Config[Ku], Config[K23] disabled', 1)]), Field('CV', Bits(29), 'Cache error exception vector control.  Disables logic forcing use of kseg1 region in the event of a Cache Error exception when Status[BEV] = 0.${p}When the CV bit is cleared, bits 31:30 of the EBase Register are fixed with the value 2 10 to force the exception base address to be in the kseg0 or kseg1 unmapped virtual address segments.  Bit 29 of exception base address will be forced to 1 on Cache Error exceptions so the exception handler will be executed from the uncached kseg1 segment.${p}When the CV bit is set, the ExcBase field is expanded to include bits 31:30 to facilitate programmable memory segmentation.'), Field('EVA', Bits(28), 'This bit is always a logic one to indicate support for enhanced virtual address (EVA).'), Field('Reserved', Bits(27, 0), 'Reserved.  Must be written as zero.  Ignored on reads.')], 'M51[05]0': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is one to indicate the presence of Config5.'), Field('Reserved', Bits(30, 3), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('UFR', Bits(2), 'Release 5 feature, This feature allows user mode access to Status[FR] with CTC1 and CFC1.'), Field('Reserved', Bits(1), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('NFExists', Bits(0), 'Indicates that the Nested Fault feature is present.       The Nested Fault feature allows recognition of faulting       behavior within an exception handler.')]}, 'The Config5 register encodes additional capabilities for the address mode programming and cache error exceptions.', [], 32, Op('==', Reg('Config4::M'), 1)),
         Register('Config4', 'cp0.16.4', '', {'': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is one to indicate the presence of Config5.'), Field('IE', Bits(30, 29), 'If bit 30 of this field is set, TLBINV, TLBINVF instructions are supported and EntryHi.EHINV is supported.  Bit 29 of this field is ignored in the interAptiv core.', [Value('TLBINV, TLBINVF, EntryHi.EHINV not supported', 0), Value('TLBINV, TLBINVF, EntryHi.EHINV not supported', 1), Value('TLBINV, TLBINVF, EntryHi.EHINV supported', 2), Value('TLBINV, TLBINVF, EntryHi.EHINV supported', 3)]), Field('Reserved', Bits(28, 0), 'Reserved.  Must be written as zero.  Ignored on reads.')], 'I6400,I6500': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is one to indicate the presence of Config5.'), Field('IE', Bits(30, 29), 'This field is set to 2to indicate that TLBINV and TLBINVF are supported.'), Field('AE', Bits(28), 'This field is set to 1 as the EntryHI.ASID is extended to 10 bits.'), Field('VTLBSizeExt', Bits(27, 24), 'This field is always concatenated to the left of the most-significant bit of the Config1.MMUSize'), Field('KScrExist', Bits(23, 16), 'Indicates how many scratch registers are available to kernel-mode software       within COP0 Register 31.${p}Each bit represents a select for CP0 Register 31.        Bit 16 represents Select 0, Bit 23 represents Select 7.  If the bit is set,       the associated scratch register is implemented and available for kernel-mode       software.  Scratch registers meant for other purposes are not represented in       this field.  For example, if EJTAG is implemented, Bit 16 is preset to zero       even though DESAVE register is implemented at Select 0.  Select 1 is reserved       for future debug purposes and should not be used as a kernel scratch register,       so bit 17 is preset to zero.'), Field('FTLB Page Size', Bits(12, 8), 'Indicates the Page Size of the FTLB Array Entries.  The FTLB must be flushed of       any valid entries before this register field value is changed by software.  The       FTLB behavior is UNDEFINED if there are valid FTLB entries which were not all       programmed using a common page size.${p}Note that the MMUExtDef field must contain       have a value of 3 for this field to have meaning.  If the MMUExtDef field is 1,       this field is ignored.  This bit is set not used during reset as the FLTB is disabled       by default.  If the FTLB is not enabled, this field is ignored.', [Value('Reserved', 0, '', True), Value('4 KB', 1), Value('16 KB', 2), Value('64 KB', 3), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True), Value('Reserved', 16, '', True), Value('Reserved', 17, '', True), Value('Reserved', 18, '', True), Value('Reserved', 19, '', True), Value('Reserved', 20, '', True), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Reserved', 23, '', True), Value('Reserved', 24, '', True), Value('Reserved', 25, '', True), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Reserved', 28, '', True), Value('Reserved', 29, '', True), Value('Reserved', 30, '', True), Value('Reserved', 31, '', True)]), Field('FTLB Ways', Bits(7, 4), 'Indicates the set associativity of the FTLB array, which is fixed at 4 in this architecture.${p}This field is not used during reset as the FLTB is disabled by default.  If the FTLB is not enabled, this field is used as part the MMUSizeExt field.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('4', 2), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('FTLB Sets', Bits(3, 0), 'Indicates the number of sets per way within the FTLB array, which is fixed at 128 in this architecture.${p}This field is not used during reset as the FLTB is disabled by default.  If the FTLB is not enabled, this field is used as part the MMUSizeExt field.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('64', 6), Value('128', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)])], 'proAptiv.*,P5600.*,P6600.*': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is one to indicate the presence of Config5.'), Field('IE', Bits(30, 29), 'TLBINV instruction support.  If bit 30 of this field is set, the TLBINV       instruction is supported and can be used to invalidate any ASID or GuestID.        Bit 29 of this field is ignored in this core.', [Value('TLBINV instruction not supported', 0), Value('TLBINV instruction not supported', 1), Value('TLBINV instruction supported', 2), Value('TLBINV instruction supported', 3)]), Field('AE', Bits(28), 'If this bit is set, then EntryHI.ASID is extended to 10 bits.', [], None, 'P6600.*'), Field('VTLBSizeExt', Bits(27, 24), 'VTLB size extension. This field is used to extend the size of the VTLB. This      field is always concatenated to the left of the most-significant bit of the      Config1MMUSize. In the P6600 core the VTLB size is fixed. Hence this field      is not used.', [], None, 'P6600.*'), Field('Reserved', Bits(28, 24), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'proAptiv.*,P5600.*'), Field('KScrExist', Bits(23, 16), 'Indicates how many scratch registers are available to kernel-mode software       within COP0 Register 31.${p}Each bit represents a select for CP0 Register 31.        Bit 16 represents Select 0, Bit 23 represents Select 7.  If the bit is set,       the associated scratch register is implemented and available for kernel-mode       software.  Scratch registers meant for other purposes are not represented in       this field.  For example, if EJTAG is implemented, Bit 16 is preset to zero       even though DESAVE register is implemented at Select 0.  Select 1 is reserved       for future debug purposes and should not be used as a kernel scratch register,       so bit 17 is preset to zero.'), Field('Reserved', Bits(15, 13), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'P6600.*'), Field('MMUExtDef', Bits(15, 14), 'MMU Extension Definition.  This 2-bit field defines how Config4[12:0] is to be interpreted.', [Value('Reserved', 0, '', True), Value('Config4[7:0] used as MMUSizeExt', 1), Value('Reserved', 2, '', True), Value('Config4[12:8] is FTLB page size, Config4[7:4] is FTLB sets, Config4[3:0] is FTLB ways.', 3)], None, 'proAptiv.*,P5600.*'), Field('Reserved', Bits(13), 'Reserved.  Must be written as zero.  Ignored on reads.', [], None, 'proAptiv.*,P5600.*'), Field('FTLB Page Size', Bits(12, 8), 'Indicates the Page Size of the FTLB Array Entries.  The FTLB must be flushed of       any valid entries before this register field value is changed by software.  The       FTLB behavior is UNDEFINED if there are valid FTLB entries which were not all       programmed using a common page size.${p}Note that the MMUExtDef field must contain       have a value of 3 for this field to have meaning.  If the MMUExtDef field is 1,       this field is ignored.  This bit is set not used during reset as the FLTB is disabled       by default.  If the FTLB is not enabled, this field is ignored.', [Value('Reserved', 0, '', True), Value('4 KB', 1), Value('16 KB', 2), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True), Value('Reserved', 16, '', True), Value('Reserved', 17, '', True), Value('Reserved', 18, '', True), Value('Reserved', 19, '', True), Value('Reserved', 20, '', True), Value('Reserved', 21, '', True), Value('Reserved', 22, '', True), Value('Reserved', 23, '', True), Value('Reserved', 24, '', True), Value('Reserved', 25, '', True), Value('Reserved', 26, '', True), Value('Reserved', 27, '', True), Value('Reserved', 28, '', True), Value('Reserved', 29, '', True), Value('Reserved', 30, '', True), Value('Reserved', 31, '', True)]), Field('FTLB Ways', Bits(7, 4), 'Indicates the set associativity of the FTLB array, which is fixed at 4 in this architecture.${p}This field is not used during reset as the FLTB is disabled by default.  If the FTLB is not enabled, this field is used as part the MMUSizeExt field.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('4', 2), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('FTLB Sets', Bits(3, 0), 'Indicates the number of sets per way within the FTLB array, which is fixed at 128 in this architecture.${p}This field is not used during reset as the FLTB is disabled by default.  If the FTLB is not enabled, this field is used as part the MMUSizeExt field.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('128', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)])], 'M51[05]0,M62[05]0': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is one to indicate the presence of Config5.'), Field('Reserved', Bits(30, 24), 'Reserved.  Must be written as zero.  Ignored on reads.'), Field('KScrExist', Bits(23, 16), 'Indicates how many scratch registers are available to kernel-mode software       within COP0 Register 31.${p}Each bit represents a select for CP0 Register 31.        Bit 16 represents Select 0, Bit 23 represents Select 7.  If the bit is set,       the associated scratch register is implemented and available for kernel-mode       software.  Scratch registers meant for other purposes are not represented in       this field.  For example, if EJTAG is implemented, Bit 16 is preset to zero       even though DESAVE register is implemented at Select 0.  Select 1 is reserved       for future debug purposes and should not be used as a kernel scratch register,       so bit 17 is preset to zero.'), Field('Reserved', Bits(15, 0), 'Reserved.  Must be written as zero.  Ignored on reads.')]}, 'The Config4 register encodes additional capabilities.', [], 32, Op('==', Reg('Config3::M'), 1)),
         Register('Config3', 'cp0.16.3', '', {'': [Field('M', Bits(31), '1 if Config4 exists (it does not on 24K,34K,74K family cores).'), Field('CMGCR', Bits(29), '1 if Coherence Manager memory-mapped Global Configuration Register Space is implemented.', [Value('CM GCR space is not implemented', 0), Value('CM GCR space is implemented', 1)]), Field('IPLW', Bits(22, 21), 'Width of Status[IPL] and Cause[RIPL] fields.', [Value('IPL and RIPL fields are 6-bits in width', 0), Value('IPL and RIPL fields are 8-bits in width', 1), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True)]), Field('MMAR', Bits(20, 18), 'microMIPS32 Architecture revision level.', [Value('Release3/MIPSr3', 0), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('MCU', Bits(17), '1 if MIPS MCU ASE is implemented.', [Value('MCU ASE is not implemented', 0), Value('MCU ASE isimplemented', 1)]), Field('ISAOn-Exc', Bits(16), 'Reflects the Instruction Set Architecture used after vectoring to an exception.  Affects all exceptions whose offsets are relative to EBase.', [Value('MIPS32is used on entrance to an exception vector', 0), Value('microMIPS is used on entrance to an exception vector', 1)]), Field('ISA', Bits(15, 14), 'Indicates Instruction Set Availability.', [Value('Only MIPS32 Instruction Set is implemented', 0), Value('Only microMIPS32 is implemented', 1), Value('Both MIPS32and microMIPS32 ISAs are implemented.  MIPS32 ISA used when coming out of reset', 2), Value('Both MIPS32and microMIPS32 ISAs are implemented.  microMIPS32 ISA used when coming out of reset', 3)]), Field('ULRI', Bits(13), '1 if CPU has a UserLocal register.', [Value('UserLocal register is not implemented', 0), Value('UserLocal register is implemented', 1)]), Field('RXI', Bits(12), '1 if RIE and XIE bits exist within the PageGrain register.', [Value('The RIE and XIE bits are not implemented within the PageGrain register', 0), Value('The RIE and XIE bits are implemented within the PageGrain register', 1)]), Field('DSP2P', Bits(11), '1 if MIPS DSP ASE Revision 2 implemented.', [Value('Revision 2 of the MIPS DSP ASE is not implemented', 0), Value('Revision 2 of the MIPS DSP ASE is implemented', 1)]), Field('DSPP', Bits(10), '1 if CPU implements rev 2 of the DSP ASE.', [Value('MIPS DSP ASE is not implemented', 0), Value('MIPS DSP ASE is implemented', 1)]), Field('CTXTC', Bits(9), '1 if ContextConfig registers is implemented and the width of the BadVPN2 field within the Config register register depends on the contents of the ContextConfig register.', [Value('ContextConfig is not implemented', 0), Value('ContextConfig is implemented', 1)]), Field('ITL', Bits(8), '1 if MIPS IFlowTraceTM mechanism implemented.', [Value('MIPS IFlowTrace is not implemented', 0), Value('MIPS IFlowTrace is implemented', 1)]), Field('LPA', Bits(7), '1 denotes the presence of support for large physical addresses on MIPS64 processors.  Not used by MIPS32 processors and returns zero on read.'), Field('VEIC', Bits(6), "1 if 'EIC'-compatible interrupt controller is fitted.", [Value('Support for EIC interrupt mode is not implemented', 0), Value('Support for EIC interrupt mode is implemented', 1)]), Field('VInt', Bits(5), '1 if CPU supports vectored interrupts.', [Value('Vector interrupts are not implemented', 0), Value('Vector interrupts are implemented', 1)]), Field('SP', Bits(4), '1 if CPU supports 1K page sizes.', [Value('Small page support is not implemented', 0), Value('Small page support is implemented', 1)]), Field('CDMM', Bits(3), '1 if Common Device Memory Map implemented.', [Value('CDMM is not implemented', 0), Value('CDMM is implemented', 1)]), Field('MT', Bits(2), '1 if CPU includes the multithreading ASE .', [Value('MIPS MT ASE is not implemented', 0), Value('MIPS MT ASE is implemented', 1)]), Field('SM', Bits(1), "1 if CPU includes the 'SmartMIPS' ASE.", [Value('SmartMIPS ASE is not implemented', 0), Value('SmartMIPS ASE is implemented', 1)]), Field('TL', Bits(0), '1 if CPU includes PDtrace instruction tracing.', [Value('Trace logic is not implemented', 0), Value('Trace logic is implemented', 1)])], 'I6400,I6500': [Field('M', Bits(31), '1 if Config4 exists.'), Field('BPG', Bits(30), '1 if Big Pages feature is implemented.  This bit indicates that TLB pages larger than 256 MB are supported and that C0_PageMask Register is 64-bits wide.', [Value('Big Pages are not implemented', 0), Value('Big Pages are implemented', 1)]), Field('CMGCR', Bits(29), '1 if Coherence Manager memory-mapped Global Configuration Register Space is implemented.', [Value('CM GCR space is not implemented', 0), Value('CM GCR space is implemented', 1)]), Field('MSAP', Bits(28), 'MIPS SIMD Architecture (MSA) is implemented. This field is set to 1 as the MSA Module is implemented.'), Field('BP', Bits(27), 'BadInstrP register implemented. This bit indicates whether the faulting prior branch instruction word register is present. This field is set to 1.'), Field('BI', Bits(26), 'BadInstr register implemented. This bit indicates whether the faulting instruction word register is present. This field is set to 1.'), Field('SC', Bits(25), 'This field is set to 0 because Segment Control was not implemented.'), Field('PW', Bits(24), 'This field is set to 0 because Page Table Walking was not implemented.'), Field('VZ', Bits(23), 'MIPS Virtualization Module implemented. This bit indicates whether the Virtualization Module is present. This field is set to 1 because the virtualization Module is implemented.'), Field('IPLW', Bits(22, 21), 'Width of Status[IPL] and Cause[RIPL] fields.', [Value('IPL and RIPL fields are 6-bits in width', 0), Value('IPL and RIPL fields are 8-bits in width', 1), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True)]), Field('MMAR', Bits(20, 18), 'microMIPS32 Architecture revision level.', [Value('Release3/MIPSr3', 0), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('MCU', Bits(17), '1 if MIPS MCU ASE is implemented.', [Value('MCU ASE is not implemented', 0), Value('MCU ASE isimplemented', 1)]), Field('ISAOnExc', Bits(16), 'Reflects the Instruction Set Architecture used after vectoring to an exception.  Affects all exceptions whose offsets are relative to EBase.', [Value('MIPS32is used on entrance to an exception vector', 0), Value('microMIPS is used on entrance to an exception vector', 1)]), Field('ISA', Bits(15, 14), 'Indicates Instruction Set Availability.', [Value('Only MIPS32 Instruction Set is implemented', 0), Value('Only microMIPS32 is implemented', 1), Value('Both MIPS32and microMIPS32 ISAs are implemented.  MIPS32 ISA used when coming out of reset', 2), Value('Both MIPS32and microMIPS32 ISAs are implemented.  microMIPS32 ISA used when coming out of reset', 3)]), Field('ULRI', Bits(13), '1 if CPU has a UserLocal register.', [Value('UserLocal register is not implemented', 0), Value('UserLocal register is implemented', 1)]), Field('RXI', Bits(12), '1 if RIE and XIE bits exist within the PageGrain register.', [Value('The RIE and XIE bits are not implemented within the PageGrain register', 0), Value('The RIE and XIE bits are implemented within the PageGrain register', 1)]), Field('DSP2P', Bits(11), '1 if MIPS DSP ASE Revision 2 implemented.', [Value('Revision 2 of the MIPS DSP ASE is not implemented', 0), Value('Revision 2 of the MIPS DSP ASE is implemented', 1)]), Field('DSPP', Bits(10), '1 if CPU implements rev 2 of the DSP ASE.', [Value('MIPS DSP ASE is not implemented', 0), Value('MIPS DSP ASE is implemented', 1)]), Field('CTXTC', Bits(9), '1 if ContextConfig registers is implemented and the width of the BadVPN2 field within the Config register register depends on the contents of the ContextConfig register.', [Value('ContextConfig is not implemented', 0), Value('ContextConfig is implemented', 1)]), Field('ITL', Bits(8), '1 if MIPS IFlowTraceTM mechanism implemented.', [Value('MIPS IFlowTrace is not implemented', 0), Value('MIPS IFlowTrace is implemented', 1)]), Field('LPA', Bits(7), '1 denotes the presence of support for large physical addresses on MIPS64 processors.  Not used by MIPS32 processors and returns zero on read.'), Field('VEIC', Bits(6), "1 if 'EIC'-compatible interrupt controller is fitted.", [Value('Support for EIC interrupt mode is not implemented', 0), Value('Support for EIC interrupt mode is implemented', 1)]), Field('VInt', Bits(5), '1 if CPU supports vectored interrupts.', [Value('Vector interrupts are not implemented', 0), Value('Vector interrupts are implemented', 1)]), Field('SP', Bits(4), '1 if CPU supports 1K page sizes.', [Value('Small page support is not implemented', 0), Value('Small page support is implemented', 1)]), Field('CDMM', Bits(3), '1 if Common Device Memory Map implemented.', [Value('CDMM is not implemented', 0), Value('CDMM is implemented', 1)]), Field('MT', Bits(2), '1 if CPU includes the multithreading ASE .', [Value('MIPS MT ASE is not implemented', 0), Value('MIPS MT ASE is implemented', 1)]), Field('SM', Bits(1), "1 if CPU includes the 'SmartMIPS' ASE.", [Value('SmartMIPS ASE is not implemented', 0), Value('SmartMIPS ASE is implemented', 1)]), Field('TL', Bits(0), '1 if CPU includes PDtrace instruction tracing.', [Value('Trace logic is not implemented', 0), Value('Trace logic is implemented', 1)])], 'proAptiv.*,P5600.*,P6600.*': [Field('M', Bits(31), '1 if Config4 exists'), Field('0', Bits(30), 'This field must be written as zero; returns zero on read.', [], None, 'P5600.*'), Field('BPG', Bits(30), '1 if Big Pages feature is implemented.  This bit indicates that TLB pages larger than 256 MB are supported and that C0_PageMask Register is 64-bits wide.', [Value('Big Pages are not implemented', 0), Value('Big Pages are implemented', 1)], None, 'P6600.*'), Field('0', Bits(30), 'This field must be written as zero; returns zero on read.', [], None, 'ProAptiv.*'), Field('BPG', Bits(30), 'Big pages. This bit is always 1 to indicate that TLB pages larger than 256 MB     are supported and that the CP0 PageMask Register is 64-bits wide.', [], None, 'P6600.*'), Field('CMGCR', Bits(29), 'This bit is read as 1 to indicate that Global Control Register Space in the Coherence Manager (CM) is implemented.', [Value('CM GCR register space is not implemented', 0), Value('CM GCR register space is implemented', 1)]), Field('0', Bits(28, 26), 'This field must be written as zero; returns zero on read.', [], None, 'ProAptiv.*'), Field('MSAP', Bits(28), 'MIPS SIMD architecture implemented. This bit indicates if the MIPS SIMD architecture is implemented.', [Value('MSA Module not implemented.', 0), Value('MSA Module is implemented', 1)], None, 'P5600,P6600'), Field('BP', Bits(27), 'BadInstrP register implemented.  This bit indicates whether the faulting prior branch instruction word register is present.', [], None, 'P5600,P6600'), Field('BI', Bits(26), 'BadInstr register implemented.  This bit indicates whether the faulting branch instruction word register is present.', [], None, 'P5600,P6600'), Field('SC', Bits(25), 'Segmentation Control implemented.  This bit indicates whether the Segmentation Control registers SegCtl0, SegCtl1 and SegCtl2 are present.', [Value('Segmentation control is not implemented', 0), Value('Segmentation control is implemented', 1)]), Field('PW', Bits(24), 'HardWare page table walk implemented. This bit indicates whether the page table walking registers PWBase, PWField and PWSize are present.', [Value('Page table walking not implemented', 0), Value('Page table walking is implemented', 1)], None, 'P5600,P6600'), Field('VZ', Bits(23), 'Virtualization Module implemented.', [Value('Virtualization Module is not implemented.', 0), Value('Virtualization Module is implemented', 1)], None, 'P5600,P6600'), Field('0', Bits(24, 16), 'Must be written as zero; returns zero on read.', [], None, 'proAptiv.*'), Field('0', Bits(22, 16), 'Must be written as zero; returns zero on read.', [], None, 'P5600,P6600'), Field('ISA', Bits(15, 14), 'Indicates the instruction set availability.  These bits are always 0 to indicate MIPS32.'), Field('ULRI', Bits(13), 'Reads 1 to indicate that the UserLocal Register is implemented.'), Field('RXI', Bits(12), 'Reads 1 to indicate that the RIE and XIE fields exist in the PageGrain register.'), Field('DSP2P', Bits(11), 'Reads 1 to indicate that Revision 2 of the MIPS DSP ASE is implemented.'), Field('DSPP', Bits(10), 'Reads 1 to indicate that the MIPS DSP ASE extension is implemented.'), Field('CTXTC', Bits(9), 'Reads 1 to indicate that the ContextConfig register is implemented.  The width of the BadVPN2 field in the Context register depends on the contents of the ContextConfig register.'), Field('0', Bits(8, 7), 'Must be written as zero; returns zero on read.', [], None, 'proAptiv.*'), Field('0', Bits(8), 'Must be written as zero; returns zero on read.', [], None, 'P5600,P6600'), Field('LPA', Bits(7), u'Large physical address support is implemented, and the PageGrain register exists.${nl}The following Coprocessor 0 fields and associated control are present if this bit is a 1:${p}     \u2022 Modifications to the EntryLo0/1, EntryHi, and BadVaddr registers to support physical addresses larger than 36 bits i.e., the XPA feature of the P5600.${nl}\u2022 Modifications to other optional COP0 registers with PA : LLAddr, ITagLo and DTagLo.${nl}\u2022 PageGrain${nl}\u2022 Config5[MVH]', [], None, 'P5600,P6600'), Field('VEIC', Bits(6), 'Read-only bit from the core input signal SI_EICPresent, which should be set in the SoC to alert software to the availability of an EIC-compatible interrupt controller.', [Value('Support for EIC interrupt mode is not implemented', 0), Value('Support for EIC interrupt mode is implemented', 1)]), Field('VInt', Bits(5), 'Reads 1 to indicate the CPU can handle vectored interrupts.'), Field('SP', Bits(4), 'Reads 0 to indicate the CPU does not support 1 Kbyte pages.'), Field('CDMM', Bits(3), 'Reads 1 to indicate the Common Device Memory Map (CDMM) is implemented.'), Field('MT', Bits(2), 'Reads 0 to indicate this core does not include the MIPS MT (multi-threading) ASE.'), Field('SM', Bits(1), 'Reads 0 to indicate the CPU does not include the SmartMIPS ASE.'), Field('TL', Bits(0), 'Reads 1 if Trace Logic is implemented.')], 'interAptiv.*': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is one to indicate the presence of Config4.'), Field('0', Bits(30), 'This field must be written as zero; returns zero on read.'), Field('CMGCR', Bits(29), 'This bit is read as 1 to indicate that Global Control Register Space in the Coherence Manager (CM) is implemented.', [Value('CM GCR register space is not implemented', 0), Value('CM GCR register space is implemented', 1)]), Field('0', Bits(28, 26), 'This field must be written as zero; returns zero on read.'), Field('SC', Bits(25), 'Segmentation Control implemented.  This bit indicates whether the Segmentation Control registers SegCtl0, SegCtl1 and SegCtl2 are present.', [Value('Segmentation control is not implemented', 0), Value('Segmentation control is implemented', 1)]), Field('0', Bits(24, 14), 'Must be written as zero; returns zero on read.'), Field('ULRI', Bits(13), 'Reads 1 to indicate that the UserLocal Register is implemented.'), Field('0', Bits(12, 11), 'Must be written as zero; returns zero on read.'), Field('DSPP', Bits(10), 'Reads 1 to indicate that the MIPS DSP ASE extension is implemented.'), Field('0', Bits(9, 7), 'Must be written as zero; returns zero on read.'), Field('VEIC', Bits(6), 'Read-only bit from the core input signal SI_EICPresent, which should be set in the SoC to alert software to the availability of an EIC-compatible interrupt controller.', [Value('Support for EIC interrupt mode is not implemented', 0), Value('Support for EIC interrupt mode is implemented', 1)]), Field('VInt', Bits(5), 'Reads 1 to indicate the CPU can handle vectored interrupts.'), Field('SP', Bits(4), 'Reads 0 to indicate the CPU does not support 1 Kbyte pages.'), Field('CDMM', Bits(3), 'Reads 1 to indicate the Common Device Memory Map (CDMM) is implemented.'), Field('MT', Bits(2), 'Reads 1 to indicate the interAptiv core does include the MIPS MT (multi-threading) ASE.'), Field('SM', Bits(1), 'Reads 0 to indicate the CPU does not include the SmartMIPS ASE.'), Field('TL', Bits(0), 'Reads 1 if Trace Logic is implemented.')], 'M51[05]0,M62[05]0': [Field('M', Bits(31), 'Configuration continuation bit.  This bit is one to indicate the presence of Config4.'), Field('0', Bits(30, 28), 'This field must be written as zero; returns zero on read.'), Field('BP', Bits(27), 'BadInstrP register implemented.  This bit is one to indicate the presence of BadInstrP register.'), Field('BI', Bits(26), 'BadInstr register implemented.  This bit is one to indicate the presence of BadInstr register.'), Field('0', Bits(25, 24), 'This field must be written as zero; returns zero on read.'), Field('VZ', Bits(23), 'Virtualization Module implemented.', [Value('Virtualization Module is not implemented.', 0), Value('Virtualization Module is implemented', 1)], None, 'M51[05]0'), Field('0', Bits(23), 'This field must be written as zero; returns zero on read.', [], None, 'M62[05]0'), Field('IPLW', Bits(22, 21), 'Width of the StatusIPL and CauseRIPL fields.', [Value('IPL and RIPL fields are 6-bits in width.', 0), Value('IPL and RIPL fields are 8-bits in width.', 1), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True)]), Field('MMAR', Bits(20, 18), 'microMIPS32 Architecture revision level.', [Value('Release3/MIPSr3', 0), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('MCU', Bits(17), '1 if MIPS MCU ASE is implemented.', [Value('MCU ASE is not implemented', 0), Value('MCU ASE isimplemented', 1)]), Field('ISAOn-Exc', Bits(16), 'Reflects the Instruction Set Architecture used after vectoring to an exception.  Affects all exceptions whose offsets are relative to EBase.', [Value('MIPS32is used on entrance to an exception vector', 0), Value('microMIPS is used on entrance to an exception vector', 1)]), Field('ISA', Bits(15, 14), 'Indicates Instruction Set Availability.', [Value('Only MIPS32 Instruction Set is implemented', 0), Value('Only microMIPS32 is implemented', 1), Value('Both MIPS32and microMIPS32 ISAs are implemented.  MIPS32 ISA used when coming out of reset', 2), Value('Both MIPS32and microMIPS32 ISAs are implemented.  microMIPS32 ISA used when coming out of reset', 3)], None, 'M51[05]0'), Field('ISA', Bits(15, 14), 'Indicates Instruction Set Availability.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Both MIPS32and microMIPS32 ISAs are implemented.  MIPS32 ISA used when coming out of reset', 2), Value('Both MIPS32and microMIPS32 ISAs are implemented.  microMIPS32 ISA used when coming out of reset', 3)], None, 'M62[05]0'), Field('ULRI', Bits(13), '1 if CPU has a UserLocal register.', [Value('UserLocal register is not implemented', 0), Value('UserLocal register is implemented', 1)]), Field('RXI', Bits(12), '1 if RIE and XIE bits exist within the PageGrain register.', [Value('The RIE and XIE bits are not implemented within the PageGrain register', 0), Value('The RIE and XIE bits are implemented within the PageGrain register', 1)]), Field('DSP2P', Bits(11), '1 if MIPS DSP ASE Revision 2 implemented.', [Value('Revision 2 of the MIPS DSP ASE is not implemented', 0), Value('Revision 2 of the MIPS DSP ASE is implemented', 1)]), Field('DSPP', Bits(10), '1 if CPU implements rev 2 of the DSP ASE.', [Value('MIPS DSP ASE is not implemented', 0), Value('MIPS DSP ASE is implemented', 1)]), Field('0', Bits(9), 'This field must be written as zero; returns zero on read.'), Field('ITL', Bits(8), '1 if MIPS IFlowTraceTM mechanism implemented.', [Value('MIPS IFlowTrace is not implemented', 0), Value('MIPS IFlowTrace is implemented', 1)]), Field('LPA', Bits(7), '1 denotes the presence of support for large physical addresses on MIPS64 processors.  Not used by MIPS32 processors and returns zero on read.'), Field('VEIC', Bits(6), "1 if 'EIC'-compatible interrupt controller is fitted.", [Value('Support for EIC interrupt mode is not implemented', 0), Value('Support for EIC interrupt mode is implemented', 1)]), Field('VInt', Bits(5), '1 if CPU supports vectored interrupts.', [Value('Vector interrupts are not implemented', 0), Value('Vector interrupts are implemented', 1)]), Field('SP', Bits(4), '1 if CPU supports 1K page sizes.', [Value('Small page support is not implemented', 0), Value('Small page support is implemented', 1)]), Field('CDMM', Bits(3), '1 if Common Device Memory Map implemented.', [Value('CDMM is not implemented', 0), Value('CDMM is implemented', 1)]), Field('0', Bits(2), 'Must be written as zero; returns zero on read.'), Field('SM', Bits(1), "1 if CPU includes the 'SmartMIPS' ASE.", [Value('SmartMIPS ASE is not implemented', 0), Value('SmartMIPS ASE is implemented', 1)]), Field('TL', Bits(0), 'Trace Logic implemented. This bit indicates whether PC or data trace is implemented.', [Value('Trace logic is not implemented', 0), Value('Trace logic is implemented', 1)])]}, 'The Config3 register encodes additional capabilities.', [], 32, Op('==', Reg('Config2::M'), 1), 'r'),
         Register('Config2', 'cp0.16.2', '', {'': [Field('M', Bits(31), '1 if Config3 exists (it does on all 24K,34K,74K family cores).'), Field('TU', Bits(30, 28), 'Implementation-specific tertiary cache control or status bits.'), Field('TS', Bits(27, 24), 'No of L3 cache sets per way.', [Value('64', 0), Value('128', 1), Value('256', 2), Value('512', 3), Value('1024', 4), Value('2048', 5), Value('4096', 6), Value('8192', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('TL', Bits(23, 20), 'L3 cache line size.', [Value('No cache present', 0), Value('4', 1), Value('8', 2), Value('16', 3), Value('32', 4), Value('64', 5), Value('128', 6), Value('256', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('TA', Bits(19, 16), 'L3 cache associativity.', [Value('Direct Mapped', 0), Value('2', 1), Value('3', 2), Value('4', 3), Value('5', 4), Value('6', 5), Value('7', 6), Value('8', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('SU', Bits(15, 13), 'Reserved for CPU-specific L2 cache information.'), Field('L2B', Bits(12), "Set to disable ('bypass') L2 cache"), Field('SS', Bits(11, 8), 'No of L2 cache sets per way.', [Value('64', 0), Value('128', 1), Value('256', 2), Value('512', 3), Value('1024', 4), Value('2048', 5), Value('4096', 6), Value('8192', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('SL', Bits(7, 4), 'L2 cache line size.', [Value('No cache present', 0), Value('4', 1), Value('8', 2), Value('16', 3), Value('32', 4), Value('64', 5), Value('128', 6), Value('256', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('SA', Bits(3, 0), 'L2 cache associativity.', [Value('Direct Mapped', 0), Value('2', 1), Value('3', 2), Value('4', 3), Value('5', 4), Value('6', 5), Value('7', 6), Value('8', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)])], 'I6400,I6500': [Field('M', Bits(31), '1 if Config3 exists.')], 'proAptiv.*,P5600.*,P6600.*': [Field('M', Bits(31), 'Continuation bit, 1 if Config3 is implemented.  This bit is set by hardware if the Config3 register is implemented.'), Field('TU', Bits(30, 28), 'Reserved for extra control/status bits for an L3 cache, if fitted.  These bits are always zero because this core does not support an L3 cache.'), Field('TS', Bits(27, 24), 'L3 cache number of sets per way.  The TL field is reset to zero to indicate that an L3 cache is not supported in this core.'), Field('TL', Bits(23, 20), 'L3 cache line size.  The TL field is reset to zero to indicate that an L3 cache is not supported in this core.'), Field('TA', Bits(19, 16), 'L3 cache associativity.  The TL field is reset to zero to indicate that an L3 cache is not supported in this core.'), Field('SU', Bits(15, 13), 'Reserved for more secondary cache control/status bits, when required.  Not used on the L2 cache option available this core.  These bits should always be zero.'), Field('L2B', Bits(12), "L2 cache bypass.  Setting this bit disables or bypasses the L2 cache.  Setting this bit also forces Config2[SL] to 0.  Based on this information,     most operating system code will conclude that there isn't an L2 cache on the system, which can be useful.${p}For systems which include an L2 cache in a     single core environment, writing a 1 to this bit sets the L2_Bypass output from this core.${p}Driving the L2_Bypass output directs the L2 cache to go into     bypass mode.  The L2 cache responds by assertion its L2_Bypassed output pin.  The value of L2_Bypassed is returned when the L2B bit is read.${p}When this bit     is set through a write operation, a subsequent read of this bit will not indicate a logic 1 until the L2 has asserted the L2_Bypassed signal indicating that it has been bypassed."), Field('SS', Bits(11, 8), 'L2 cache number of sets per way.  This field indicates the number of sets per way in the L2 cache of the Multiprocessing Systems (MPS) and is written by hardware at reset based on the state of the L2_Sets[3:0] signals.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('512 sets per way', 3), Value('1024 sets per way', 4), Value('2048 sets per way', 5), Value('4096 sets per way', 6), Value('8192 sets per way', 7), Value('16384 sets per way', 8), Value('32768 sets per way', 9), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('SL', Bits(7, 4), 'L2 data cache line size.  In the Multiprocessing Systems, the L2 cache line size can be configured at 32 or 64 bytes.  This field is written by hardware at reset based on the state of the L2_LineSize[3:0] signals.${p}A value of zero in this field indicates means no cache.', [Value('No Cache', 0), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('32 byte line size', 4), Value('64 byte line size', 5), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('SA', Bits(3, 0), 'L2 cache associativity.  In the Multiprocessing Systems, the L2 cache associativity is fixed at 8 ways.  This field is written by hardware at reset based on the state of the L2_Assoc[3:0] signals.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('8 ways', 4), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('8 ways', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)])], 'interAptiv.*': [Field('M', Bits(31), 'Continuation bit, 1 if Config3 is implemented.  This bit is set by hardware if the Config3 register is implemented.'), Field('TU', Bits(30, 28), 'Implementation specific L3 cache control.  The TU field is reset to zero. However, CACHE and CACHEE operations to the L3 caches are supported.'), Field('TS', Bits(27, 24), 'L3 cache number of sets per way.  The TS field is reset to zero. However, CACHE and CACHEE operations to the L3 caches are supported.'), Field('TL', Bits(23, 20), 'L3 cache line size.  The TL field is reset to zero. However, CACHE and CACHEE operations to the L3 caches are supported.'), Field('TA', Bits(19, 16), 'L3 cache associativity.  The TA field is reset to zero. However, CACHE and CACHEE operations to the L3 caches are supported.'), Field('SU', Bits(15, 13), 'Reserved.'), Field('L2B', Bits(12), "L2 cache bypass.  Setting this bit disables or bypasses the L2 cache.  Setting this bit also forces Config2[SL] to 0.  Based on this information,     most operating system code will conclude that there isn't an L2 cache on the system, which can be useful.${p}For systems which include an L2 cache in a     single core environment, writing a 1 to this bit sets the L2_Bypass output from this core.${p}Driving the L2_Bypass output directs the L2 cache to go into     bypass mode.  The L2 cache responds by assertion its L2_Bypassed output pin.  The value of L2_Bypassed is returned when the L2B bit is read.${p}When this bit     is set through a write operation, a subsequent read of this bit will not indicate a logic 1 until the L2 has asserted the L2_Bypassed signal indicating that it has been bypassed."), Field('SS', Bits(11, 8), 'L2 cache number of sets per way.  This field indicates the number of sets per way in the L2 cache of the Multiprocessing Systems (MPS) and is written by hardware at reset based on the state of the L2_Sets[3:0] signals.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('512 sets per way', 3), Value('1024 sets per way', 4), Value('2048 sets per way', 5), Value('4096 sets per way', 6), Value('8192 sets per way', 7), Value('16384 sets per way', 8), Value('32768 sets per way', 9), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('SL', Bits(7, 4), 'L2 data cache line size.  In the Multiprocessing Systems, the L2 cache line size can be configured at 32 or 64 bytes.  This field is written by hardware at reset based on the state of the L2_LineSize[3:0] signals.${p}A value of zero in this field indicates means no cache.', [Value('No Cache', 0), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('32 byte line size', 4), Value('64 byte line size', 5), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)]), Field('SA', Bits(3, 0), 'L2 cache associativity.  In the Multiprocessing Systems, the L2 cache associativity is fixed at 8 ways.  This field is written by hardware at reset based on the state of the L2_Assoc[3:0] signals.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('8 ways', 4), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('8 ways', 7), Value('Reserved', 8, '', True), Value('Reserved', 9, '', True), Value('Reserved', 10, '', True), Value('Reserved', 11, '', True), Value('Reserved', 12, '', True), Value('Reserved', 13, '', True), Value('Reserved', 14, '', True), Value('Reserved', 15, '', True)])], 'M51[05]0,M62[05]0': [Field('M', Bits(31), u'This bit is hardwired to \u20181\u2019 to indicate the presence of the Config3 register.')]}, 'The Config2 register encodes level 2 and level 3 cache configurations.', [], 32, Op('==', Reg('Config1::M'), 1)),
         Register('Config1', 'cp0.16.1', '', {'': [Field('M', Bits(31), 'Continuation bit, set to 1 to indicate that Config2 is implemented.'), Field('MMUSize', Bits(30, 25), 'Number of TLB entries minus 1.'), Field('IS', Bits(24, 22), 'No of L1 I-cache sets per way.', [Value('64', 0), Value('128', 1), Value('256', 2), Value('512', 3), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('IL', Bits(21, 19), 'L1 I-cache line size: (2^(x+1)) bytes.', [Value('No Icache present', 0), Value('4 bytes', 1), Value('8 bytes', 2), Value('16 bytes', 3), Value('32 bytes', 4), Value('64 bytes', 5), Value('128 bytes', 6), Value('Reserved', 7, '', True)]), Field('IA', Bits(18, 16), 'L1 I-cache associativity.', [Value('Direct mapped', 0), Value('2-way', 1), Value('3-way', 2), Value('4-way', 3), Value('5-way', 4), Value('6-way', 5), Value('7-way', 6), Value('8-way', 7)]), Field('DS', Bits(15, 13), 'No of L1 D-cache sets per way.', [Value('64', 0), Value('128', 1), Value('256', 2), Value('512', 3), Value('1024', 4), Value('2048', 5), Value('4096', 6), Value('32', 7)]), Field('DL', Bits(12, 10), 'L1 D-cache line size.', [Value('No Dcache present', 0), Value('4 bytes', 1), Value('8 bytes', 2), Value('16 bytes', 3), Value('32 bytes', 4), Value('64 bytes', 5), Value('128 bytes', 6), Value('Reserved', 7, '', True)]), Field('DA', Bits(9, 7), 'L1 D-cache associativity.', [Value('Direct mapped', 0), Value('2-way', 1), Value('3-way', 2), Value('4-way', 3), Value('5-way', 4), Value('6-way', 5), Value('7-way', 6), Value('8-way', 7)]), Field('C2', Bits(6), '1 if this CPU has a co-processor 2.', [Value('No coprocessor 2 implemented', 0), Value('Coprocessor 2 implemented', 1)]), Field('MD', Bits(5), '1 if the FPU includes MDMX instructions.'), Field('PC', Bits(4), '1 if there is at least one performance counter.', [Value('No performance counter registers implemented', 0), Value('Performance counter registers implemented', 1)]), Field('WR', Bits(3), '1 if there is at least one CP0 watchpoint.', [Value('No watch registers implemented', 0), Value('Watch registers implemented', 1)]), Field('CA', Bits(2), '1 if the CPU handles MIPS16e instructions.', [Value('MIPS16e not implemented', 0), Value('MIPS16e implemented', 1)]), Field('EP', Bits(1), '1 if there is an EJTAG unit.', [Value('No EJTAG implemented', 0), Value('EJTAG implemented', 1)]), Field('FP', Bits(0), '1 if there is an FPU.', [Value('No FPU implemented', 0), Value('FPU implemented', 1)])], 'proAptiv.*,P5600.*,P6600.*,interAptiv.*': [Field('M', Bits(31), 'Continuation bit, set to 1 to indicate that Config2 is implemented.'), Field('MMUSize', Bits(30, 25), 'This field contains the number of entries in the TLB minus one.  The field is read as 0 decimal if the TLB is not implemented.', [], None, 'InterAptiv.*'), Field('MMUSize', Bits(30, 25), 'The size of the VTLB array (the array has MMUSize + 1 entries).  Refer to the Config4 register for more information.', [], None, 'proAptiv.*,P5600'), Field('IS', Bits(24, 22), 'L1 Instruction cache number of sets per way.  This field indicates the number of sets per way in the L1 instruction cache.${nl}Because the line size and associativity are fixed for the instruction cache as defined in the IL and IA fields below, the IS field is used to determine the overall cache size as follows:${nl}The instruction cache size is the IS sets/way x 32 bytes/line x 4 sets per way.', [Value('64 sets per way (equates to 8 KByte instruction cache)', 0), Value('128 sets per way (equates to 16 KByte instruction cache)', 1), Value('256 sets per way (equates to 32 KByte instruction cache)', 2), Value('512 sets per way (equates to 64 KByte instruction cache)', 3), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('32 sets per way (equates to 4 KByte instruction cache)', 7)], None, 'InterAptiv.*'), Field('IS', Bits(24, 22), 'L1 Instruction cache number of sets per way.  This field indicates the number of sets per way in the L1 instruction cache.${nl}Because the line size and associativity are fixed for the instruction cache as defined in the IL and IA fields below, the IS field is used to determine the overall cache size as follows:${nl}The instruction cache size is the IS sets/way x 32 bytes/line x 4 sets per way.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('256 sets per way (equates to 32 KByte instruction cache)', 2), Value('512 sets per way (equates to 64 KByte instruction cache)', 3), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)], None, 'proAptiv.*,P5600,P6600.*'), Field('IL', Bits(21, 19), 'L1 Instruction cache line size.  In this core, the instruction cache line size is fixed at 32 bytes.${nl}A value of zero in this field indicates means no cache.', [Value('No Cache', 0), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('32 byte line size', 4), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('IA', Bits(18, 16), 'L1 Instruction cache associativity.  In this core, the instruction cache associativity is fixed at 4 ways.${nl}A default value of 3 indicates a 4-way set associative instruction cache.  Refer to the IS field above to determine how to calculate the size of the L1 instruction cache.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('4-ways', 3), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('DS', Bits(15, 13), 'L1 Data cache number of sets per way.  This field indicates the number of sets per way in the L1 data cache.${nl}Because the line size and associativity are fixed for the data cache as defined in the DL and DA fields below, the DS field is used to determine the overall cache size as follows:${nl}The data cache size is the DS sets/way x 32 bytes/line x 4 sets per way.', [Value('64 sets per way (equates to 8 KByte data cache)', 0), Value('128 sets per way (equates to 16 KByte data cache)', 1), Value('256 sets per way (equates to 32 KByte data cache)', 2), Value('512 sets per way (equates to 64 KByte data cache)', 3), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('32 sets per way (equates to 4 KByte data cache)', 7)], None, 'InterAptiv.*'), Field('DS', Bits(15, 13), 'L1 Data cache number of sets per way.  This field indicates the number of sets per way in the L1 data cache.${nl}Because the line size and associativity are fixed for the data cache as defined in the DL and DA fields below, the DS field is used to determine the overall cache size as follows:${nl}The data cache size is the DS sets/way x 32 bytes/line x 4 sets per way.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('256 sets per way (equates to 32 KByte data cache)', 2), Value('512 sets per way (equates to 64 KByte data cache)', 3), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)], None, 'proAptiv.*,P5600,P6600.*'), Field('DL', Bits(12, 10), 'L1 data cache line size.  In this core, the data cache line size is fixed at 32 bytes.${nl}A value of zero in this field indicates no cache.', [Value('No Cache', 0), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('32 byte line size', 4), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('DA', Bits(9, 7), 'L1 data cache associativity.  In this core, the data cache associativity is fixed at 4 ways.${nl}A default value of 3 indicates a 4-way set associative data cache.', [Value('Reserved', 0, '', True), Value('Reserved', 1, '', True), Value('Reserved', 2, '', True), Value('4-ways', 3), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('C2', Bits(6), 'This bit is cleared to indicate that a coprocessor 2 does not exist in the system (that would be a customer-designed coprocessor).'), Field('MD', Bits(5), "MDMX ASE present.  A logic '0' indicates that the MDMX ASE is not implemented in the floating point unit of this core.${nl}Note that if the FPU is not implemented, this bit has no meaning."), Field('PC', Bits(4), 'Performance Counter registers implemented.  This bit reads 1 if there is at least one performance counter implemented.'), Field('WR', Bits(3), 'Watchpoint registers present.  This bit reads 1 if Watchpoint registers have been implemented.'), Field('CA', Bits(2), 'MIPS16e present.  This bit reads 1 if the MIPS16e compressed-code instruction set is available.'), Field('EP', Bits(1), 'EJTAG unit present.  This bit always reads 1 as the EJTAG debug unit is provided on this core.'), Field('FP', Bits(0), 'Floating Point Unit present.  This bit is set to indicate that a floating point unit is present.  The floating point unit is optional on this core.', [Value('No FPU present', 0), Value('FPU present', 1)])]}, 'The Config1 register is an adjunct to the Config register and encodes additional information about capabilities present on the core.  All fields in the Config1 register are read-only.', [], 32, True, 'r'),
         Register('Config', 'cp0.16.0', '', {'': [Field('M', Bits(31), '1 indicates Config1 exists.'), Field('K23', Bits(30, 28), 'kseg2 and kseg3 cacheability and coherence attribute.'), Field('KU', Bits(27, 25), 'Specifies the kuseg cacheability and coherence attribute.'), Field('ISP', Bits(24), '1 if I-side scratchpad is fitted.'), Field('DSP', Bits(23), '1 if D-side scratchpad is fitted.'), Field('UDI', Bits(22), "1 if this CPU has 'CorExtend' (used-defined) instructions."), Field('SB', Bits(21), "'Simple BE' -- 1 if only simple partial-word transfers."), Field('MDU', Bits(20), 'MDU Implementation.', [Value('HPMDU', 0, 'High-performance MDU'), Value('LCMDU', 1, 'Low-cost MDU')]), Field('MM', Bits(18), 'Set 1 to let software reduce available cache ways.'), Field('BM', Bits(16), '1 if CPU can use sub-block burst order.'), Field('BE', Bits(15), '1 for big-endian, 0 for little-endian.', [Value('LE', 0, 'Little endian'), Value('BE', 1, 'Big endian')]), Field('AT', Bits(14, 13), 'MIPS32 vs MIPS64', [Value('MIPS32', 0, 'MIPS32 or microMIPS32'), Value('MIPS64/32', 1, 'MIPS64 or microMIPS64 with access only to 32-bit compatibility segments'), Value('MIPS64', 2, 'MIPS64 or microMIPS64 with access to all address segments'), Value('Reserved', 3, '', True)]), Field('AR', Bits(12, 10), 'MIPS32/64 rev level implemented.', [Value('R1', 0, 'Release 1'), Value('R2/R3/R5', 1, 'Release 2, Release 3, or Release 5'), Value('R6', 2, 'Release 6'), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('MT', Bits(9, 7), 'MMU hardware available.', [Value('None', 0), Value('TLB', 1, 'Standard TLB'), Value('BAT', 2, 'BAT'), Value('FMT', 3, 'Fixed Mapping'), Value('Dual', 4, 'Dual VTLB and FTLB')]), Field('K0', Bits(2, 0), 'Cache coherency attributes for kseg0.')], 'I6[45]00.*': [Field('M', Bits(31), '1 indicates Config1 exists.'), Field('BE', Bits(15), '1 for big-endian, 0 for little-endian.', [Value('LE', 0, 'Little endian'), Value('BE', 1, 'Big endian')]), Field('AT', Bits(14, 13), 'MIPS32 vs MIPS64', [Value('MIPS32', 0, 'MIPS32 or microMIPS32'), Value('MIPS64/32', 1, 'MIPS64 or microMIPS64 with access only to 32-bit compatibility segments'), Value('MIPS64', 2, 'MIPS64 or microMIPS64 with access to all address segments'), Value('Reserved', 3, '', True)]), Field('AR', Bits(12, 10), 'MIPS32/64 rev level implemented.', [Value('R1', 0, 'Release 1'), Value('R2/R3/R5', 1, 'Release 2, Release 3, or Release 5'), Value('R6', 2, 'Release 6'), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('MT', Bits(9, 7), 'MMU hardware available.', [Value('None', 0), Value('TLB', 1, 'Standard TLB'), Value('BAT', 2, 'BAT'), Value('FMT', 3, 'Fixed Mapping'), Value('Dual', 4, 'Dual VTLB and FTLB')]), Field('VI', Bits(3), 'Virtual instruction cache. This field is set to 0 to indicate that the L1 instruction cache is physically tagged.'), Field('K0', Bits(2, 0), 'Kseg0 cacheability and coherency attribute. Writes of unsupported values are ignored.')], 'proAptiv.*,P5600.*,P6600.*': [Field('M', Bits(31), '1 indicates Config1 exists.'), Field('K23', Bits(30, 28), 'This field is unused in this core.'), Field('KU', Bits(27, 25), 'This field is unused in this core.'), Field('ISP', Bits(24), '1 if I-side scratchpad is fitted.'), Field('DSP', Bits(23), '1 if D-side scratchpad is fitted.'), Field('UDI', Bits(22), "1 if this CPU has 'CorExtend' (used-defined) instructions."), Field('SB', Bits(21), "'Simple BE' -- 1 if only simple partial-word transfers."), Field('0', Bits(20, 19), 'Reserved.  Must be written as zero; returns zero on read.'), Field('MM', Bits(18), 'Set 1 to let software reduce available cache ways.'), Field('0', Bits(17), 'Reserved.  Must be written as zero; returns zero on read.'), Field('BM', Bits(16), '1 if CPU can use sub-block burst order.'), Field('BE', Bits(15), '1 for big-endian, 0 for little-endian.', [Value('LE', 0, 'Little endian'), Value('BE', 1, 'Big endian')]), Field('AT', Bits(14, 13), 'MIPS32 vs MIPS64', [Value('MIPS32', 0, 'MIPS32 or microMIPS32'), Value('MIPS64/32', 1, 'MIPS64 or microMIPS64 with access only to 32-bit compatibility segments'), Value('MIPS64', 2, 'MIPS64 or microMIPS64 with access to all address segments'), Value('Reserved', 3, '', True)]), Field('AR', Bits(12, 10), 'MIPS32/64 rev level implemented.', [Value('R1', 0, 'Release 1'), Value('R2/R3/R5', 1, 'Release 2, Release 3, or Release 5'), Value('R6', 2, 'Release 6'), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('MT', Bits(9, 7), 'MMU hardware available.', [Value('Reserved', 0, '', True), Value('VTLB', 1, 'VTLB only'), Value('Reserved', 2, '', True), Value('Reserved', 3, '', True), Value('Dual', 4, 'VTLB and FTLB')]), Field('0', Bits(6, 4), 'Reserved.  Must be written as zero; returns zero on read.'), Field('VI', Bits(3), 'Virtual instruction cache (using both virtual indexing and virtual tags).', [Value('NotVirtual', 0, 'Instruction Cache is not virtual'), Value('Virtual', 1, 'Instruction Cache is virtual')]), Field('K0', Bits(2, 0), 'Cache coherency attributes for kseg0.')], 'M5100.*,M6200.*': [Field('M', Bits(31), '1 indicates Config1 exists.'), Field('K23', Bits(30, 28), 'This field controls the cacheability of the kseg2 and kseg3 address segments in FM implementations.', [Value('Cacheable, noncoherent, write-through, no write allocate', 0), Value('Cacheable, noncoherent, write-through, write allocate', 1), Value('Uncached', 2), Value('Cacheable, noncoherent, write-back, write allocate', 3)]), Field('KU', Bits(27, 25), 'This field controls the cacheability of the kuseg and useg address segments in FM implementations.', [Value('Cacheable, noncoherent, write-through, no write allocate', 0), Value('Cacheable, noncoherent, write-through, write allocate', 1), Value('Uncached', 2), Value('Cacheable, noncoherent, write-back, write allocate', 3)]), Field('0', Bits(24, 23), 'Reserved.  Must be written as zero; returns zero on read.'), Field('UDI', Bits(22), "1 if this CPU has 'CorExtend' (used-defined) instructions."), Field('SB', Bits(21), "'Simple BE' -- 1 if only simple partial-word transfers.", [], None, 'M5100.*'), Field('0', Bits(21), 'Must be written as 0. Returns zero on reads.', [], None, 'M6200.*'), Field('MDU', Bits(20), 'This bit indicates the type of Multiply/Divide Unit present.', [Value('Fast, high-performance MDU', 0), Value('Iterative, area-efficient MDU', 1)]), Field('0', Bits(19, 17), 'Reserved.  Must be written as zero; returns zero on read.'), Field('DS', Bits(16), 'Dual SRAM interface.', [Value('Unified instruction/data SRAM interface', 0), Value('Dual instruction/data SRAM interfaces', 1)], None, 'M5100.*'), Field('0', Bits(16), 'Must be written as 0. Returns zero on reads.', [], None, 'M6200.*'), Field('BE', Bits(15), '1 for big-endian, 0 for little-endian.', [Value('LE', 0, 'Little endian'), Value('BE', 1, 'Big endian')]), Field('AT', Bits(14, 13), 'MIPS32 vs MIPS64', [Value('MIPS32', 0, 'MIPS32 or microMIPS32'), Value('MIPS64/32', 1, 'MIPS64 or microMIPS64 with access only to 32-bit compatibility segments'), Value('MIPS64', 2, 'MIPS64 or microMIPS64 with access to all address segments'), Value('Reserved', 3, '', True)]), Field('AR', Bits(12, 10), 'MIPS32/64 rev level implemented.', [Value('R1', 0, 'Release 1'), Value('R2/R3/R5', 1, 'Release 2, Release 3, or Release 5'), Value('R6', 2, 'Release 6'), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('MT', Bits(9, 7), 'MMU hardware available.', [Value('Reserved', 0, '', True), Value('VTLB', 1, 'VTLB only'), Value('Reserved', 2, '', True), Value('Fixed Mapping', 3), Value('Dual', 4, 'VTLB and FTLB')]), Field('0', Bits(6, 3), 'Reserved.  Must be written as zero; returns zero on read.'), Field('K0', Bits(2, 0), 'Kseg0 coherency algorithm.', [Value('Uncached', 2), Value('Cached', 3)])], 'M5150.*': [Field('M', Bits(31), '1 indicates Config1 exists.'), Field('K23', Bits(30, 28), 'This field controls the cacheability of the kseg2 and kseg3 address segments in FM implementations.', [Value('Cacheable, noncoherent, write-through, no write allocate', 0), Value('Cacheable, noncoherent, write-through, write allocate', 1), Value('Uncached', 2), Value('Cacheable, noncoherent, write-back, write allocate', 3)]), Field('KU', Bits(27, 25), 'This field controls the cacheability of the kuseg and useg address segments in FM implementations.', [Value('Cacheable, noncoherent, write-through, no write allocate', 0), Value('Cacheable, noncoherent, write-through, write allocate', 1), Value('Uncached', 2), Value('Cacheable, noncoherent, write-back, write allocate', 3)]), Field('ISP', Bits(24), 'Indicates whether Instruction ScratchPad RAM is present.                  Set by the ISP_Present static input pin, if scratchpad was                                       enabled when the core was built.', [Value('No instruction ScratchPad is present.', 0), Value('Instruction ScratchPad is present.', 1)]), Field('DSP', Bits(23), 'Indicates whether Data ScratchPad RAM is present.                  Set by the DSP_Present static input pin, if scratchpad was                                       enabled when the core was built.', [Value('No data ScratchPad is present.', 0), Value('Data ScratchPad is present.', 1)]), Field('UDI', Bits(22), 'This bit indicates that CorExtend User Defined Instructions have been implemented.', [Value('No User Defined Instructions are implemented.', 0), Value('User Defined Instructions are implemented.', 1)]), Field('SB', Bits(21), 'Indicates whether SimpleBE bus mode is enabled. This bit is hardwired to 1 to indicate only simple byte enables allowed on bus interface.'), Field('MDU', Bits(20), 'This bit indicates the type of Multiply/Divide Unit present.', [Value('Fast, high-performance MDU', 0), Value('Iterative, area-efficient MDU', 1)]), Field('WC', Bits(19), "Reserved diagnostic bit. Please refer to MD00213 'Cache Configuration Application Note'."), Field('MM', Bits(18, 17), 'This bit indicates whether merging is enabled in the 32 byte collapsing write buffer. Set via SI_MergeMode[1:0] input pins.', [Value('No Merging', 0), Value('Merging Allowed', 2)]), Field('BM', Bits(16), 'This bit is hardwired to 0 to indicate burst order is sequential.'), Field('BE', Bits(15), 'Indicates the endian mode in which the processor is running. Set via SI_Endian input pin.', [Value('LE', 0, 'Little endian'), Value('BE', 1, 'Big endian')]), Field('AT', Bits(14, 13), 'Architecture type implemented by the processor. MIPS32 vs MIPS64', [Value('MIPS32', 0, 'MIPS32 or microMIPS32'), Value('MIPS64/32', 1, 'MIPS64 or microMIPS64 with access only to 32-bit compatibility segments'), Value('MIPS64', 2, 'MIPS64 or microMIPS64 with access to all address segments'), Value('Reserved', 3, '', True)]), Field('AR', Bits(12, 10), 'MIPS32/64 Revision level.', [Value('R1', 0, 'Release 1'), Value('R2/R3/R5', 1, 'Release 2, Release 3, or Release 5'), Value('R6', 2, 'Release 6'), Value('Reserved', 3, '', True), Value('Reserved', 4, '', True), Value('Reserved', 5, '', True), Value('Reserved', 6, '', True), Value('Reserved', 7, '', True)]), Field('MT', Bits(9, 7), 'MMU hardware available.', [Value('Reserved', 0, '', True), Value('Standard TLB', 1, 'VTLB only'), Value('Fixed Mapping', 3)]), Field('0', Bits(6, 3), 'Reserved.  Must be written as zero; returns zero on read.'), Field('K0', Bits(2, 0), 'Kseg0 coherency algorithm.', [Value('Cacheable, noncoherent, write-through, no write allocate', 0), Value('Cacheable, noncoherent, write-through, write allocate', 1), Value('Uncached', 2), Value('Cacheable, noncoherent, write-back, write allocate', 3)])]}, 'The Config register specifies various configuration and capabilities information.'),
         Register('DataLo', 'cp0.28.1', '', {}, 'The DataLo register is a register that acts as the interface to the cache data array and is intended for diagnostic operations         only. The Index Load Tag operation of the CACHE instruction reads the corresponding data values into the DataLo register. If the         WST bit in the ErrCtl register is set, then the contents of DataLo can be written to the cache data array by doing an Index Store         Data CACHE instruction. Note that the M5150 core does not implement the DataHi register.', [], 32, CPUNameMatches('M5150')),
         Register('TagLo_1', 'cp0.28.0', 'TagLo (WST=1)', {'': [Field('WSDP', Bits(23, 20), 'Dirty Parity (Optional). This field contains the value read from the WS array during a CACHE Index           Load WS operation. If the PO field of the ErrCtl register is asserted, then this field is used to store           the dirty parity bits during a CACHE Index Store WS operation.'), Field('WSD', Bits(19, 16), 'Dirty bits. This field contains the value read from the WS array after a CACHE Index Load WS operation.           It is used to store into the WS array during CACHE Index Store WS operations.'), Field('WSLRU', Bits(15, 10), 'This field contains the value read from the WS array after a CACHE Index Load WS operation. It is used           to store into the WS array during CACHE Index Store WS operations.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(6), 'Reserved.  Must be written as zero; returns zero on read.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.')]}, 'The Index Store Tag and Index Load Tag operations of the CACHE instruction use the TagLo register as the source of tag information.         Note that the M5150 core does not ent the TagHi register.', [], 32, And(CPUNameMatches('M5150'), Op('==', Reg('ErrCtl::WST'), 1))),
         Register('TagLo', 'cp0.28.0', 'TagLo (WST==0)', {'': [Field('PA', Bits(31, 10), 'This field contains the physical address of the cache line. Bit 31 corresponds to           bit 31 of the PA and bit 10 corresponds to bit 10 of the PA.'), Field('0', Bits(9, 8), 'Reserved.  Must be written as zero; returns zero on read.'), Field('V', Bits(7), 'This field indicates whether the cache line is valid.'), Field('D', Bits(6), 'This field indicates whether the cache line is dirty.  It will only be set if bit 7 (valid) is also set.'), Field('L', Bits(5), 'Specifies the lock bit for the cache tag. When this bit is set, and the valid bit is set, the corresponding cache line will not be replaced by the cache replacement algorithm.'), Field('0', Bits(4, 1), 'Reserved.  Must be written as zero; returns zero on read.'), Field('P', Bits(0), 'Specifies the parity bit for the cache tag. This bit is updated with tag array parity on CACHE Index Load Tag operations and used as tag array parity on Index Store Tag operations when the PO bit of the ErrCtl register is set.')]}, 'The Index Store Tag and Index Load Tag operations of the CACHE instruction use the TagLo register as the source of tag information.         Note that the M5150 core does not ent the TagHi register.', [], 32, And(CPUNameMatches('M5150'), Op('==', Reg('ErrCtl::WST'), 0))),
         Register('L23DataHi', 'cp0.29.5', '', {'interAptiv.*,proAptiv.*,P5600.*': [Field('DATA', Bits(31, 0), 'High-order data read from the cache data array.')]}, 'The L23DataHi register is a register that acts as the interface to the cache data array and is intended for diagnostic operations only.  The Index Load Tag operation of the CACHE instruction reads the corresponding data values into the L23DataHi register.  If the WST bit in the ErrCtl register is set, then the contents of L23DataHi can be written to the cache data array by doing an Index Store Data CACHE instruction.', [], 32, Or(And(Op('gt', Reg('Config2::SL'), 0), Or(CPUNameMatches('InterAptiv.*'), CPUNameMatches('ProAptiv.*'), CPUNameMatches('P5600.*'))), Op('==', Condition('Has_L2_Registers'), True))),
         Register('DErrCTL', 'cp0.26.0', '', {}, 'DCache Parity/ECC error control and status', [], 32, CPUNameMatches('20Kc')),
         Register('IErrCTL', 'cp0.26.1', '', {}, 'ICache Parity/ECC error control and status', [], 32, CPUNameMatches('20Kc')),
         Register('IDataHi', 'cp0.29.1', '', {'proAptiv.*,interAptiv.*,P5600.*': [Field('DATA', Bits(31, 0), 'High-order data read from the cache data array.')]}, 'The IDataHi register is a register that acts as the interface to the cache data array and is intended for diagnostic operations only.  The Index Load Tag operation of the CACHE instruction reads the corresponding data values into the IDataHi register.  If the WST bit in the ErrCtl register is set, then the contents of IDataHi can be written to the cache data array by doing an Index Store Data CACHE instruction.  If the SPR bit in the ErrCtl register is set, then the contents of IDataHi can be written to the scratchpad RAM data array by doing an Index Store Data CACHE instruction.', [], 32, Or(CPUNameMatches('5K.*'), CPUNameMatches('20Kc'), CPUNameMatches('24K.*'), CPUNameMatches('1004K.*'), CPUNameMatches('34K.*'), CPUNameMatches('74K.*'), CPUNameMatches('1074K.*'), CPUNameMatches('InterAptiv.*'), CPUNameMatches('ProAptiv.*'), CPUNameMatches('P5600.*'))),
         Register('DDataLo', 'cp0.28.3', '', {'proAptiv.*,interAptiv.*,P5600.*': [Field('DATA', Bits(31, 0), 'Low-order data read from the cache data array.')]}, 'The DDataLo register is a register that acts as the interface to the data cache data array and is intended for diagnostic operations only.  The Index Load Tag operation of the CACHE instruction reads the corresponding data values into the DDataLo register.  If the WST bit in the ErrCtl register is set, then the contents of DDataLo can be written to the cache data array by doing an Index Store Data CACHE instruction.  If the SPR bit in the ErrCtl register is set, then the contents of DDataLo can be written to the scratchpad RAM data array by doing an Index Store Data CACHE instruction.', [], 32, Op('==', Condition('Has_ITagLo_DTagLo'), True)),
         Register('CacheErr', 'cp0.27.0', '', {'': [Field('ER', Bits(31), 'Error Reference.  Indicates the type of reference that encountered an error.'), Field('EC', Bits(30), 'Indicates the cache level at which the error was detected.'), Field('ED', Bits(29), 'Error in cache data field.'), Field('ET', Bits(28), 'Error in cache tag.'), Field('ES', Bits(27), 'Parity error doing a cache-coherence snoop.'), Field('EE', Bits(26), 'Parity error when reading from memory.'), Field('EB', Bits(25), 'Errors on both I-fetch and load/store.'), Field('EF', Bits(24), 'Various kinds of unrecoverable error.'), Field('SP', Bits(23), 'Error on a scratchpad memory access.'), Field('EW', Bits(22), 'Error reading modified (dirty) or way-select bits.'), Field('Way', Bits(21, 20), 'Cache way where error occurred.'), Field('Index', Bits(19, 0), 'Cache index where error occurred.')], 'M5100': [Field('ER', Bits(31), 'Error Reference. Indicates the type of reference that encountered an error.', [Value('Instruction', 0), Value('Data', 1)]), Field('EB', Bits(30), 'Error Both. Indicates that a data SRAM parity error occurred in addition to an instruction SRAM parity error.', [Value('No additional data SRAM parity error', 0), Value('Additional data SRam parity error', 1)]), Field('Addr', Bits(29, 0), 'Error address. Specifies on which address the error was detected.')], 'proAptiv.*,P5600.*': [Field('EREC', Bits(31, 30), 'This 2-bit field indicates the block where the error occurred and is encoded as follows:\\n\\n  00  L1 instruction cache error\\n  01  External cache error\\n  10  L1 dat cache error\\n  11  FTLB error'), Field('ED & ET', Bits(29, 28), 'The encoding of these two bits depends on the state of the EREC field above.  If the state of this feld contains an encoding of 00, 01, or 10, indicating a cache error, the encoding of this field is as follows:\\n\\n  00  No tag or data RAM error detected\\n  01  Primary tag RAM error\\n  10  Data RAM error\\n  11  Duplicate tag RAM error\\n\\nIf the state of the EREC feld contains an encoding of 11, indicating a TLB error, the encoding of this field is as follows.\\n\\nA parity error in the FTLB tag sets the ET bit (28), while a parity error in the FTLB data sets the ED bit (29).  One or both of these bits may be set.'), Field('ES', Bits(27), 'Error source.  In a multi-core system, this bit Reads 0 if error was caused by internal processor and 1 if external snoop request.\\n\\nIn a single-core system, this bit is not supported.'), Field('EE', Bits(26), 'Error external: In a multi-core system, this bit Indicates that a parity error was seen on a coherent L1 cache in another CPU.\\n\\nIn a single-core system, this bit is not supported.'), Field('EB', Bits(25), 'If EC equals 0 indicating an error in the L1 cache, this bit is EB, indicating Error in Both caches.  If data and instruction-fetch error are reported on the same instruction, it is unrecoverable.  If so, the rest of the register reports on the instruction-fetch error.\\n\\nIf EC equals 1 indicating an error in the L2 or higher cache, this bit is EM, indicating Error in Multiple locations.'), Field('EF', Bits(24), "Unrecoverable (fatal) error (other than the EB type above).  Some parity errors can be fixed by invalidating the cache line and relying on good data from memory.  However, if this bit is set, it indicates the error cannot be fixed.  Here are some possible scenarios of when the EF bit might be set by hardware:\\n\\n Dirty parity error in dirty line being displaced from cache\\n Line being displaced from cache has a tag parity error.\\n The line being displaced from cache tag indicates it has been written by the CPU since it was obtained from memory (the line is 'dirty' and needs a write-back), but it has a data parity error.\\n Writeback store miss and CacheErrEW error.\\n At least one more cache error happened concurrently with or after this one, but before the original error reached the cache error exception handler.\\n If EC equals 0, and a second L2 error occurs when an earlier L2 error is pending."), Field('SP', Bits(23), 'Error affecting a Scratchpad RAM access.'), Field('EW', Bits(22), 'Parity error on way-selection RAM array.'), Field('Way', Bits(21, 19), 'If EC equals 0, bit 19 is unused.  Bits 21:20 indicate the way-number of the cache entry where the error occurred.  It is not valid if a Scratchpad RAM error is detected (SP=1).\\n\\nIf EC equals 1, indicating an L2 or higher-level cache error, bits 21:19 indicate the way-number of the cache entry where the error occurred.\\n\\nOn a FTLB error, bits 20:19 indicate the number of ways in each set.  Bit 21 is not used on a FTLB error.'), Field('DR', Bits(18), "A 1 bit indicates that the reported error affected the cache-line 'dirty' bits.  This bit is only meaningful in case of an L1 data cache access."), Field('Index', Bits(16, 0), "The cache index or Scratchpad RAM index of the double word entry where the error occurred.  The way of the faulty cache is written by hardware in the Way field.  The CacheErr bits [16:0] represents the Address index bits [19:3].\\n\\nThe index-type cache instruction will need an 'index' with the way bits glued on top of this cache-entry field; you know how to put that together, because the shape of the cache is defined in the Config1-2 registers.\\n\\nOn a TLB error, this field indicates the number of sets in the FTLB.  The number of bits is implementation dependent and is always right-justified in the Index field.")], 'interAptiv.*': [Field('ER-EC', Bits(31, 30), 'This 2-bit field indicates the block where the error occurred.\\n\\nEncoding:\\n  00  Uncorrected L1 instruction cache or instruction scratchpad error\\n  01  Secondary cache error\\n  10  Uncorrected L1 data cache or data scratchpad error\\n  11  Corrected L1 cache or scratchpad error'), Field('ED-ET', Bits(29, 28), 'The encoding of these two bits depends on the state of the ER:EC field above.\\n\\nEncoding:\\n  00  No tag or data RAM error detected\\n  01  Primary tag RAM error\\n  10  Primary data RAM error\\n  11  Duplicate tag RAM error'), Field('ES', Bits(27), 'Error source.  Indicates whether error was caused by internal processor or external snoop request.\\n\\nEncoding:\\n  0  Error on internal request\\n  1  Error on external request'), Field('EE', Bits(26), 'Error external.  Indicates that a parity error was seen on a coherent L1 cache in another core.'), Field('EB', Bits(25), 'Error Both. Indicates that a cache error occurred in multiple instruction or data cache arrays.\\n\\nEncoding:\\n  0  No additional data cache error\\n  1  Additional data cache error\\n\\nIn the case of multiple errors, the Tag ram error has the highest priority, followed by the Data ram error, followed by the Way Select ram. Only the highest priority error information is recorded in the CacheErr register.'), Field('EF', Bits(24), 'Error Fatal.  Indicates that a fatal cache error has occurred. There are a few situations where software will not be able to get all information about a cache error from the CacheErr register. These situations are fatal because software cannot determine which memory locations have been affected by the error. To enable software to detect these cases, the EF bit (bit 24) has been added to the CacheErr register. The following cases are indicated as fatal cache errors by the EF bit:\\n\\n Dirty parity error in dirty victim (dirty bit cleared)\\n Tag parity error in dirty victim\\n Data parity error in dirty victim\\n WB store miss and EW error at the requested index\\n Dual/Triple errors from different transactions, e.g. scheduled and non-scheduled load\\n Multiple data cache errors detected before the first instruction of the cache error handler is issued\\n\\nIn addition to the above, simultaneous instruction and data cache errors as indicated by CacheErr[EB] will cause information about the data cache error to be unavailable. However, that situation is not indicated by CacheErr[EF].'), Field('SP', Bits(23), 'Scratchpad. Indicates a Scratchpad RAM parity error.'), Field('EW', Bits(22), 'Error Way.  Indicates a parity error on the dirty bits that are stored in the way selection RAM array.'), Field('Way', Bits(21, 20), 'Way.  Specifies the cache way in which the error was detected. It is not valid if a Tag RAM error is detected (ET=1) or Scratchpad RAM error is detected (SP=1).'), Field('Index', Bits(19, 0), 'Index.  Specifies the cache or Scratchpad RAM index of the double word in which the error was detected. The way of the faulty cache is written by hardware in the Way field. Software must combine the Way and Index read in this register with cache configuration information in the Config1 register in order to obtain an index which can be used in an indexed CACHE instruction to access the faulty cache data or tag. Note that Index is aligned as a byte index, so it does not need to be shifted by software before it is used in an indexed CACHE instruction. Index bits [4:3] are undefined upon tag RAM errors, and Index bits above the MSB actually used for cache indexing will also be undefined.\\nBits [19:16] are only used for errors in the Scratchpad RAM.')]}, 'The CacheErr register provides an interface with the cache error-detection logic.', [], 32, CPUNameMatches('5K.*, 20Kc, 24K.*, 1004K.*, M14K.*, 74K.*, 34K.*, InterAptiv.*, 1074K.*, ProAptiv.*,P5600.*,M51[05]0'), 'r')]}
